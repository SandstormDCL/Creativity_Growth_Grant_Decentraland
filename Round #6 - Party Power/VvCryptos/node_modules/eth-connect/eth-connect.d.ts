/**
 * @public
 */
export declare interface AbiConstructor {
    type: 'constructor';
    anonymous?: boolean;
    constant?: boolean;
    inputs?: AbiInput[];
    name?: string;
    outputs?: AbiOutput[];
    payable?: boolean;
    stateMutability?: StateMutabilityType;
    gas?: number;
}

/**
 * @public
 */
export declare interface AbiEvent {
    type: 'event';
    anonymous?: boolean;
    constant?: boolean;
    inputs?: AbiInput[];
    name?: string;
    outputs?: AbiOutput[];
    payable?: boolean;
    stateMutability?: StateMutabilityType;
    gas?: number;
}

/**
 * @public
 */
export declare interface AbiFallback {
    type: 'fallback';
    anonymous?: boolean;
    constant?: boolean;
    inputs?: AbiInput[];
    name?: string;
    outputs?: AbiOutput[];
    payable?: boolean;
    stateMutability?: StateMutabilityType;
    gas?: number;
}

/**
 * @public
 */
export declare interface AbiFunction {
    type: 'function';
    anonymous?: boolean;
    constant?: boolean;
    inputs?: AbiInput[];
    name?: string;
    outputs?: AbiOutput[];
    payable?: boolean;
    stateMutability?: StateMutabilityType;
    gas?: number;
}

/**
 * @public
 */
export declare interface AbiInput extends AbiOutput {
    indexed?: boolean;
}

/**
 * @public
 */
export declare type AbiItem = AbiFunction | AbiEvent | AbiConstructor | AbiFallback | AbiItemGeneric;

/**
 * @public
 */
export declare interface AbiItemGeneric {
    type: string;
    anonymous?: boolean;
    constant?: boolean;
    inputs?: AbiInput[];
    name?: string;
    outputs?: AbiOutput[];
    payable?: boolean;
    stateMutability?: StateMutabilityType;
    gas?: number;
}

/**
 * @public
 */
export declare interface AbiOutput {
    name: string;
    type: string;
    components?: AbiOutput[];
    internalType?: string;
}

/**
 * @public
 */
export declare type AbiType = 'function' | 'constructor' | 'event' | 'fallback';

export declare abstract class AbstractFilter<ReceivedLog, TransformedLog = ReceivedLog> {
    requestManager: RequestManager;
    isStarted: boolean;
    isDisposed: boolean;
    formatter: (x: ReceivedLog) => TransformedLog;
    protected filterId: IFuture<Data>;
    protected callbacks: ((message: TransformedLog) => void)[];
    protected stopSemaphore: IFuture<any>;
    constructor(requestManager: RequestManager);
    watch(callback: (message: TransformedLog) => void): Promise<void>;
    start(): Promise<void>;
    stop(): Promise<void>;
    protected abstract getNewFilter(): Promise<Data>;
    protected abstract getChanges(): Promise<ReceivedLog[]>;
    protected abstract uninstall(): Promise<boolean>;
    /**
     * Adds the callback and sets up the methods, to iterate over the results.
     */
    private poll;
}

/**
 * Hex string of 20 bytes
 * @public
 */
export declare type Address = string;

export declare function BigNumber(n: BigNumber.Value, base?: number): BigNumber;

export declare namespace BigNumber {

    /** See `BigNumber.config` (alias `BigNumber.set`) and `BigNumber.clone`. */
    export interface Config {

        /**
         * An integer, 0 to 1e+9. Default value: 20.
         *
         * The maximum number of decimal places of the result of operations involving division, i.e.
         * division, square root and base conversion operations, and exponentiation when the exponent is
         * negative.
         *
         * ```ts
         * BigNumber.config({ DECIMAL_PLACES: 5 })
         * BigNumber.set({ DECIMAL_PLACES: 5 })
         * ```
         */
        DECIMAL_PLACES?: number;

        /**
         * An integer, 0 to 8. Default value: `BigNumber.ROUND_HALF_UP` (4).
         *
         * The rounding mode used in operations that involve division (see `DECIMAL_PLACES`) and the
         * default rounding mode of the `decimalPlaces`, `precision`, `toExponential`, `toFixed`,
         * `toFormat` and `toPrecision` methods.
         *
         * The modes are available as enumerated properties of the BigNumber constructor.
         *
         * ```ts
         * BigNumber.config({ ROUNDING_MODE: 0 })
         * BigNumber.set({ ROUNDING_MODE: BigNumber.ROUND_UP })
         * ```
         */
        ROUNDING_MODE?: BigNumber.RoundingMode;

        /**
         * An integer, 0 to 1e+9, or an array, [-1e+9 to 0, 0 to 1e+9].
         * Default value: `[-7, 20]`.
         *
         * The exponent value(s) at which `toString` returns exponential notation.
         *
         * If a single number is assigned, the value is the exponent magnitude.
         *
         * If an array of two numbers is assigned then the first number is the negative exponent value at
         * and beneath which exponential notation is used, and the second number is the positive exponent
         * value at and above which exponential notation is used.
         *
         * For example, to emulate JavaScript numbers in terms of the exponent values at which they begin
         * to use exponential notation, use `[-7, 20]`.
         *
         * ```ts
         * BigNumber.config({ EXPONENTIAL_AT: 2 })
         * new BigNumber(12.3)         // '12.3'        e is only 1
         * new BigNumber(123)          // '1.23e+2'
         * new BigNumber(0.123)        // '0.123'       e is only -1
         * new BigNumber(0.0123)       // '1.23e-2'
         *
         * BigNumber.config({ EXPONENTIAL_AT: [-7, 20] })
         * new BigNumber(123456789)    // '123456789'   e is only 8
         * new BigNumber(0.000000123)  // '1.23e-7'
         *
         * // Almost never return exponential notation:
         * BigNumber.config({ EXPONENTIAL_AT: 1e+9 })
         *
         * // Always return exponential notation:
         * BigNumber.config({ EXPONENTIAL_AT: 0 })
         * ```
         *
         * Regardless of the value of `EXPONENTIAL_AT`, the `toFixed` method will always return a value in
         * normal notation and the `toExponential` method will always return a value in exponential form.
         * Calling `toString` with a base argument, e.g. `toString(10)`, will also always return normal
         * notation.
         */
        EXPONENTIAL_AT?: number | [number, number];

        /**
         * An integer, magnitude 1 to 1e+9, or an array, [-1e+9 to -1, 1 to 1e+9].
         * Default value: `[-1e+9, 1e+9]`.
         *
         * The exponent value(s) beyond which overflow to Infinity and underflow to zero occurs.
         *
         * If a single number is assigned, it is the maximum exponent magnitude: values wth a positive
         * exponent of greater magnitude become Infinity and those with a negative exponent of greater
         * magnitude become zero.
         *
         * If an array of two numbers is assigned then the first number is the negative exponent limit and
         * the second number is the positive exponent limit.
         *
         * For example, to emulate JavaScript numbers in terms of the exponent values at which they
         * become zero and Infinity, use [-324, 308].
         *
         * ```ts
         * BigNumber.config({ RANGE: 500 })
         * BigNumber.config().RANGE     // [ -500, 500 ]
         * new BigNumber('9.999e499')   // '9.999e+499'
         * new BigNumber('1e500')       // 'Infinity'
         * new BigNumber('1e-499')      // '1e-499'
         * new BigNumber('1e-500')      // '0'
         *
         * BigNumber.config({ RANGE: [-3, 4] })
         * new BigNumber(99999)         // '99999'      e is only 4
         * new BigNumber(100000)        // 'Infinity'   e is 5
         * new BigNumber(0.001)         // '0.01'       e is only -3
         * new BigNumber(0.0001)        // '0'          e is -4
         * ```
         * The largest possible magnitude of a finite BigNumber is 9.999...e+1000000000.
         * The smallest possible magnitude of a non-zero BigNumber is 1e-1000000000.
         */
        RANGE?: number | [number, number];

        /**
         * A boolean: `true` or `false`. Default value: `false`.
         *
         * The value that determines whether cryptographically-secure pseudo-random number generation is
         * used. If `CRYPTO` is set to true then the random method will generate random digits using
         * `crypto.getRandomValues` in browsers that support it, or `crypto.randomBytes` if using a
         * version of Node.js that supports it.
         *
         * If neither function is supported by the host environment then attempting to set `CRYPTO` to
         * `true` will fail and an exception will be thrown.
         *
         * If `CRYPTO` is `false` then the source of randomness used will be `Math.random` (which is
         * assumed to generate at least 30 bits of randomness).
         *
         * See `BigNumber.random`.
         *
         * ```ts
         * // Node.js
         * global.crypto = require('crypto')
         *
         * BigNumber.config({ CRYPTO: true })
         * BigNumber.config().CRYPTO       // true
         * BigNumber.random()              // 0.54340758610486147524
         * ```
         */
        CRYPTO?: boolean;

        /**
         * An integer, 0, 1, 3, 6 or 9. Default value: `BigNumber.ROUND_DOWN` (1).
         *
         * The modulo mode used when calculating the modulus: `a mod n`.
         * The quotient, `q = a / n`, is calculated according to the `ROUNDING_MODE` that corresponds to
         * the chosen `MODULO_MODE`.
         * The remainder, `r`, is calculated as: `r = a - n * q`.
         *
         * The modes that are most commonly used for the modulus/remainder operation are shown in the
         * following table. Although the other rounding modes can be used, they may not give useful
         * results.
         *
         * Property           | Value | Description
         * :------------------|:------|:------------------------------------------------------------------
         *  `ROUND_UP`        |   0   | The remainder is positive if the dividend is negative.
         *  `ROUND_DOWN`      |   1   | The remainder has the same sign as the dividend.
         *                    |       | Uses 'truncating division' and matches JavaScript's `%` operator .
         *  `ROUND_FLOOR`     |   3   | The remainder has the same sign as the divisor.
         *                    |       | This matches Python's `%` operator.
         *  `ROUND_HALF_EVEN` |   6   | The IEEE 754 remainder function.
         *  `EUCLID`          |   9   | The remainder is always positive.
         *                    |       | Euclidian division: `q = sign(n) * floor(a / abs(n))`
         *
         * The rounding/modulo modes are available as enumerated properties of the BigNumber constructor.
         *
         * See `modulo`.
         *
         * ```ts
         * BigNumber.config({ MODULO_MODE: BigNumber.EUCLID })
         * BigNumber.set({ MODULO_MODE: 9 })          // equivalent
         * ```
         */
        MODULO_MODE?: BigNumber.ModuloMode;

        /**
         * An integer, 0 to 1e+9. Default value: 0.
         *
         * The maximum precision, i.e. number of significant digits, of the result of the power operation
         * - unless a modulus is specified.
         *
         * If set to 0, the number of significant digits will not be limited.
         *
         * See `exponentiatedBy`.
         *
         * ```ts
         * BigNumber.config({ POW_PRECISION: 100 })
         * ```
         */
        POW_PRECISION?: number;

        /**
         * An object including any number of the properties shown below.
         *
         * The object configures the format of the string returned by the `toFormat` method.
         * The example below shows the properties of the object that are recognised, and
         * their default values.
         *
         * Unlike the other configuration properties, the values of the properties of the `FORMAT` object
         * will not be checked for validity - the existing object will simply be replaced by the object
         * that is passed in.
         *
         * See `toFormat`.
         *
         * ```ts
         * BigNumber.config({
         *   FORMAT: {
         *     // string to prepend
         *     prefix: '',
         *     // the decimal separator
         *     decimalSeparator: '.',
         *     // the grouping separator of the integer part
         *     groupSeparator: ',',
         *     // the primary grouping size of the integer part
         *     groupSize: 3,
         *     // the secondary grouping size of the integer part
         *     secondaryGroupSize: 0,
         *     // the grouping separator of the fraction part
         *     fractionGroupSeparator: ' ',
         *     // the grouping size of the fraction part
         *     fractionGroupSize: 0,
         *     // string to append
         *     suffix: ''
         *   }
         * })
         * ```
         */
        FORMAT?: BigNumber.Format;

        /**
         * The alphabet used for base conversion. The length of the alphabet corresponds to the maximum
         * value of the base argument that can be passed to the BigNumber constructor or `toString`.
         *
         * Default value: `'0123456789abcdefghijklmnopqrstuvwxyz'`.
         *
         * There is no maximum length for the alphabet, but it must be at least 2 characters long,
         * and it must not contain whitespace or a repeated character, or the sign indicators '+' and
         * '-', or the decimal separator '.'.
         *
         * ```ts
         * // duodecimal (base 12)
         * BigNumber.config({ ALPHABET: '0123456789TE' })
         * x = new BigNumber('T', 12)
         * x.toString()                // '10'
         * x.toString(12)              // 'T'
         * ```
         */
        ALPHABET?: string;
    }

    /** See `FORMAT` and `toFormat`. */
    export interface Format {

        /** The string to prepend. */
        prefix?: string;

        /** The decimal separator. */
        decimalSeparator?: string;

        /** The grouping separator of the integer part. */
        groupSeparator?: string;

        /** The primary grouping size of the integer part. */
        groupSize?: number;

        /** The secondary grouping size of the integer part. */
        secondaryGroupSize?: number;

        /** The grouping separator of the fraction part. */
        fractionGroupSeparator?: string;

        /** The grouping size of the fraction part. */
        fractionGroupSize?: number;

        /** The string to append. */
        suffix?: string;
    }

    export interface Instance {

        /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */
        readonly c: number[] | null;

        /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */
        readonly e: number | null;

        /** The sign of the value of this BigNumber, -1, 1, or null. */
        readonly s: number | null;

        [key: string]: any;
    }

    export type Constructor = typeof BigNumber;
    export type ModuloMode = 0 | 1 | 3 | 6 | 9;
    export type RoundingMode = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
    export type Value = string | number | Instance;
}

export declare class BigNumber implements BigNumber.Instance {

    /** Used internally to identify a BigNumber instance. */
    private readonly _isBigNumber: true;

    /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */
    readonly c: number[] | null;

    /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */
    readonly e: number | null;

    /** The sign of the value of this BigNumber, -1, 1, or null. */
    readonly s: number | null;

    /**
     * Returns a new instance of a BigNumber object with value `n`, where `n` is a numeric value in
     * the specified `base`, or base 10 if `base` is omitted or is `null` or `undefined`.
     *
     * ```ts
     * x = new BigNumber(123.4567)              // '123.4567'
     * // 'new' is optional
     * y = BigNumber(x)                         // '123.4567'
     * ```
     *
     * If `n` is a base 10 value it can be in normal (fixed-point) or exponential notation.
     * Values in other bases must be in normal notation. Values in any base can have fraction digits,
     * i.e. digits after the decimal point.
     *
     * ```ts
     * new BigNumber(43210)                     // '43210'
     * new BigNumber('4.321e+4')                // '43210'
     * new BigNumber('-735.0918e-430')          // '-7.350918e-428'
     * new BigNumber('123412421.234324', 5)     // '607236.557696'
     * ```
     *
     * Signed `0`, signed `Infinity` and `NaN` are supported.
     *
     * ```ts
     * new BigNumber('-Infinity')               // '-Infinity'
     * new BigNumber(NaN)                       // 'NaN'
     * new BigNumber(-0)                        // '0'
     * new BigNumber('.5')                      // '0.5'
     * new BigNumber('+2')                      // '2'
     * ```
     *
     * String values in hexadecimal literal form, e.g. `'0xff'`, are valid, as are string values with
     * the octal and binary prefixs `'0o'` and `'0b'`. String values in octal literal form without the
     * prefix will be interpreted as decimals, e.g. `'011'` is interpreted as 11, not 9.
     *
     * ```ts
     * new BigNumber(-10110100.1, 2)            // '-180.5'
     * new BigNumber('-0b10110100.1')           // '-180.5'
     * new BigNumber('ff.8', 16)                // '255.5'
     * new BigNumber('0xff.8')                  // '255.5'
     * ```
     *
     * If a base is specified, `n` is rounded according to the current `DECIMAL_PLACES` and
     * `ROUNDING_MODE` settings. This includes base 10, so don't include a `base` parameter for decimal
     * values unless this behaviour is desired.
     *
     * ```ts
     * BigNumber.config({ DECIMAL_PLACES: 5 })
     * new BigNumber(1.23456789)                // '1.23456789'
     * new BigNumber(1.23456789, 10)            // '1.23457'
     * ```
     *
     * An error is thrown if `base` is invalid.
     *
     * There is no limit to the number of digits of a value of type string (other than that of
     * JavaScript's maximum array size). See `RANGE` to set the maximum and minimum possible exponent
     * value of a BigNumber.
     *
     * ```ts
     * new BigNumber('5032485723458348569331745.33434346346912144534543')
     * new BigNumber('4.321e10000000')
     * ```
     *
     * BigNumber `NaN` is returned if `n` is invalid (unless `BigNumber.DEBUG` is `true`, see below).
     *
     * ```ts
     * new BigNumber('.1*')                    // 'NaN'
     * new BigNumber('blurgh')                 // 'NaN'
     * new BigNumber(9, 2)                     // 'NaN'
     * ```
     *
     * To aid in debugging, if `BigNumber.DEBUG` is `true` then an error will be thrown on an
     * invalid `n`. An error will also be thrown if `n` is of type number with more than 15
     * significant digits, as calling `toString` or `valueOf` on these numbers may not result in the
     * intended value.
     *
     * ```ts
     * console.log(823456789123456.3)          //  823456789123456.2
     * new BigNumber(823456789123456.3)        // '823456789123456.2'
     * BigNumber.DEBUG = true
     * // 'Error: Number has more than 15 significant digits'
     * new BigNumber(823456789123456.3)
     * // 'Error: Not a base 2 number'
     * new BigNumber(9, 2)
     * ```
     *
     * A BigNumber can also be created from an object literal.
     * Use `isBigNumber` to check that it is well-formed.
     *
     * ```ts
     * new BigNumber({ s: 1, e: 2, c: [ 777, 12300000000000 ], _isBigNumber: true })    // '777.123'
     * ```
     *
     * @param n A numeric value.
     * @param base The base of `n`, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).
     */
    constructor(n: BigNumber.Value, base?: number);

    /**
     * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this
     * BigNumber.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * x = new BigNumber(-0.8)
     * x.absoluteValue()           // '0.8'
     * ```
     */
    absoluteValue(): BigNumber;

    /**
     * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this
     * BigNumber.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * x = new BigNumber(-0.8)
     * x.abs()                     // '0.8'
     * ```
     */
    abs(): BigNumber;

    /**
     *  Returns |                                                               |
     * :-------:|:--------------------------------------------------------------|
     *     1    | If the value of this BigNumber is greater than the value of `n`
     *    -1    | If the value of this BigNumber is less than the value of `n`
     *     0    | If this BigNumber and `n` have the same value
     *  `null`  | If the value of either this BigNumber or `n` is `NaN`
     *
     * ```ts
     *
     * x = new BigNumber(Infinity)
     * y = new BigNumber(5)
     * x.comparedTo(y)                 // 1
     * x.comparedTo(x.minus(1))        // 0
     * y.comparedTo(NaN)               // null
     * y.comparedTo('110', 2)          // -1
     * ```
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    comparedTo(n: BigNumber.Value, base?: number): number;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode
     * `roundingMode` to a maximum of `decimalPlaces` decimal places.
     *
     * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of
     * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is
     * ±`Infinity` or `NaN`.
     *
     * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.
     *
     * Throws if `decimalPlaces` or `roundingMode` is invalid.
     *
     * ```ts
     * x = new BigNumber(1234.56)
     * x.decimalPlaces()                      // 2
     * x.decimalPlaces(1)                     // '1234.6'
     * x.decimalPlaces(2)                     // '1234.56'
     * x.decimalPlaces(10)                    // '1234.56'
     * x.decimalPlaces(0, 1)                  // '1234'
     * x.decimalPlaces(0, 6)                  // '1235'
     * x.decimalPlaces(1, 1)                  // '1234.5'
     * x.decimalPlaces(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'
     * x                                      // '1234.56'
     * y = new BigNumber('9.9e-101')
     * y.decimalPlaces()                      // 102
     * ```
     *
     * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.
     * @param [roundingMode] Rounding mode, integer, 0 to 8.
     */
    decimalPlaces(): number | null;
    decimalPlaces(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode
     * `roundingMode` to a maximum of `decimalPlaces` decimal places.
     *
     * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of
     * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is
     * ±`Infinity` or `NaN`.
     *
     * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.
     *
     * Throws if `decimalPlaces` or `roundingMode` is invalid.
     *
     * ```ts
     * x = new BigNumber(1234.56)
     * x.dp()                                 // 2
     * x.dp(1)                                // '1234.6'
     * x.dp(2)                                // '1234.56'
     * x.dp(10)                               // '1234.56'
     * x.dp(0, 1)                             // '1234'
     * x.dp(0, 6)                             // '1235'
     * x.dp(1, 1)                             // '1234.5'
     * x.dp(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'
     * x                                      // '1234.56'
     * y = new BigNumber('9.9e-101')
     * y.dp()                                 // 102
     * ```
     *
     * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.
     * @param [roundingMode] Rounding mode, integer, 0 to 8.
     */
    dp(): number | null;
    dp(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded
     * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.
     *
     * ```ts
     * x = new BigNumber(355)
     * y = new BigNumber(113)
     * x.dividedBy(y)                  // '3.14159292035398230088'
     * x.dividedBy(5)                  // '71'
     * x.dividedBy(47, 16)             // '5'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    dividedBy(n: BigNumber.Value, base?: number): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded
     * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.
     *
     * ```ts
     * x = new BigNumber(355)
     * y = new BigNumber(113)
     * x.div(y)                    // '3.14159292035398230088'
     * x.div(5)                    // '71'
     * x.div(47, 16)               // '5'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    div(n: BigNumber.Value, base?: number): BigNumber;

    /**
     * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by
     * `n`.
     *
     * ```ts
     * x = new BigNumber(5)
     * y = new BigNumber(3)
     * x.dividedToIntegerBy(y)              // '1'
     * x.dividedToIntegerBy(0.7)            // '7'
     * x.dividedToIntegerBy('0.f', 16)      // '5'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    dividedToIntegerBy(n: BigNumber.Value, base?: number): BigNumber;

    /**
     * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by
     * `n`.
     *
     * ```ts
     * x = new BigNumber(5)
     * y = new BigNumber(3)
     * x.idiv(y)                       // '1'
     * x.idiv(0.7)                     // '7'
     * x.idiv('0.f', 16)               // '5'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    idiv(n: BigNumber.Value, base?: number): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.
     * raised to the power `n`, and optionally modulo a modulus `m`.
     *
     * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and
     * `ROUNDING_MODE` settings.
     *
     * As the number of digits of the result of the power operation can grow so large so quickly,
     * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is
     * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).
     *
     * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant
     * digits will be calculated, and that the method's performance will decrease dramatically for
     * larger exponents.
     *
     * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is
     * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will
     * be performed as `x.exponentiatedBy(n).modulo(m)` with a `POW_PRECISION` of 0.
     *
     * Throws if `n` is not an integer.
     *
     * ```ts
     * Math.pow(0.7, 2)                    // 0.48999999999999994
     * x = new BigNumber(0.7)
     * x.exponentiatedBy(2)                // '0.49'
     * BigNumber(3).exponentiatedBy(-2)    // '0.11111111111111111111'
     * ```
     *
     * @param n The exponent, an integer.
     * @param [m] The modulus.
     */
    exponentiatedBy(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;
    exponentiatedBy(n: number, m?: BigNumber.Value): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.
     * raised to the power `n`, and optionally modulo a modulus `m`.
     *
     * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and
     * `ROUNDING_MODE` settings.
     *
     * As the number of digits of the result of the power operation can grow so large so quickly,
     * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is
     * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).
     *
     * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant
     * digits will be calculated, and that the method's performance will decrease dramatically for
     * larger exponents.
     *
     * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is
     * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will
     * be performed as `x.pow(n).modulo(m)` with a `POW_PRECISION` of 0.
     *
     * Throws if `n` is not an integer.
     *
     * ```ts
     * Math.pow(0.7, 2)                   // 0.48999999999999994
     * x = new BigNumber(0.7)
     * x.pow(2)                           // '0.49'
     * BigNumber(3).pow(-2)               // '0.11111111111111111111'
     * ```
     *
     * @param n The exponent, an integer.
     * @param [m] The modulus.
     */
    pow(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;
    pow(n: number, m?: BigNumber.Value): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber rounded to an integer using
     * rounding mode `rm`.
     *
     * If `rm` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.
     *
     * Throws if `rm` is invalid.
     *
     * ```ts
     * x = new BigNumber(123.456)
     * x.integerValue()                        // '123'
     * x.integerValue(BigNumber.ROUND_CEIL)    // '124'
     * y = new BigNumber(-12.7)
     * y.integerValue()                        // '-13'
     * x.integerValue(BigNumber.ROUND_DOWN)    // '-12'
     * ```
     *
     * @param {BigNumber.RoundingMode} [rm] The roundng mode, an integer, 0 to 8.
     */
    integerValue(rm?: BigNumber.RoundingMode): BigNumber;

    /**
     * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns
     * `false`.
     *
     * As with JavaScript, `NaN` does not equal `NaN`.
     *
     * ```ts
     * 0 === 1e-324                           // true
     * x = new BigNumber(0)
     * x.isEqualTo('1e-324')                  // false
     * BigNumber(-0).isEqualTo(x)             // true  ( -0 === 0 )
     * BigNumber(255).isEqualTo('ff', 16)     // true
     *
     * y = new BigNumber(NaN)
     * y.isEqualTo(NaN)                // false
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    isEqualTo(n: BigNumber.Value, base?: number): boolean;

    /**
     * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns
     * `false`.
     *
     * As with JavaScript, `NaN` does not equal `NaN`.
     *
     * ```ts
     * 0 === 1e-324                    // true
     * x = new BigNumber(0)
     * x.eq('1e-324')                  // false
     * BigNumber(-0).eq(x)             // true  ( -0 === 0 )
     * BigNumber(255).eq('ff', 16)     // true
     *
     * y = new BigNumber(NaN)
     * y.eq(NaN)                       // false
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    eq(n: BigNumber.Value, base?: number): boolean;

    /**
     * Returns `true` if the value of this BigNumber is a finite number, otherwise returns `false`.
     *
     * The only possible non-finite values of a BigNumber are `NaN`, `Infinity` and `-Infinity`.
     *
     * ```ts
     * x = new BigNumber(1)
     * x.isFinite()                    // true
     * y = new BigNumber(Infinity)
     * y.isFinite()                    // false
     * ```
     */
    isFinite(): boolean;

    /**
     * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise
     * returns `false`.
     *
     * ```ts
     * 0.1 > (0.3 - 0.2)                             // true
     * x = new BigNumber(0.1)
     * x.isGreaterThan(BigNumber(0.3).minus(0.2))    // false
     * BigNumber(0).isGreaterThan(x)                 // false
     * BigNumber(11, 3).isGreaterThan(11.1, 2)       // true
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    isGreaterThan(n: BigNumber.Value, base?: number): boolean;

    /**
     * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise
     * returns `false`.
     *
     * ```ts
     * 0.1 > (0.3 - 0                     // true
     * x = new BigNumber(0.1)
     * x.gt(BigNumber(0.3).minus(0.2))    // false
     * BigNumber(0).gt(x)                 // false
     * BigNumber(11, 3).gt(11.1, 2)       // true
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    gt(n: BigNumber.Value, base?: number): boolean;

    /**
     * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,
     * otherwise returns `false`.
     *
     * ```ts
     * (0.3 - 0.2) >= 0.1                                  // false
     * x = new BigNumber(0.3).minus(0.2)
     * x.isGreaterThanOrEqualTo(0.1)                       // true
     * BigNumber(1).isGreaterThanOrEqualTo(x)              // true
     * BigNumber(10, 18).isGreaterThanOrEqualTo('i', 36)   // true
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    isGreaterThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;

    /**
     * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,
     * otherwise returns `false`.
     *
     * ```ts
     * (0.3 - 0.2) >= 0.1                    // false
     * x = new BigNumber(0.3).minus(0.2)
     * x.gte(0.1)                            // true
     * BigNumber(1).gte(x)                   // true
     * BigNumber(10, 18).gte('i', 36)        // true
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    gte(n: BigNumber.Value, base?: number): boolean;

    /**
     * Returns `true` if the value of this BigNumber is an integer, otherwise returns `false`.
     *
     * ```ts
     * x = new BigNumber(1)
     * x.isInteger()                   // true
     * y = new BigNumber(123.456)
     * y.isInteger()                   // false
     * ```
     */
    isInteger(): boolean;

    /**
     * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns
     * `false`.
     *
     * ```ts
     * (0.3 - 0.2) < 0.1                       // true
     * x = new BigNumber(0.3).minus(0.2)
     * x.isLessThan(0.1)                       // false
     * BigNumber(0).isLessThan(x)              // true
     * BigNumber(11.1, 2).isLessThan(11, 3)    // true
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    isLessThan(n: BigNumber.Value, base?: number): boolean;

    /**
     * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns
     * `false`.
     *
     * ```ts
     * (0.3 - 0.2) < 0.1                       // true
     * x = new BigNumber(0.3).minus(0.2)
     * x.lt(0.1)                               // false
     * BigNumber(0).lt(x)                      // true
     * BigNumber(11.1, 2).lt(11, 3)            // true
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    lt(n: BigNumber.Value, base?: number): boolean;

    /**
     * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,
     * otherwise returns `false`.
     *
     * ```ts
     * 0.1 <= (0.3 - 0.2)                                 // false
     * x = new BigNumber(0.1)
     * x.isLessThanOrEqualTo(BigNumber(0.3).minus(0.2))   // true
     * BigNumber(-1).isLessThanOrEqualTo(x)               // true
     * BigNumber(10, 18).isLessThanOrEqualTo('i', 36)     // true
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    isLessThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;

    /**
     * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,
     * otherwise returns `false`.
     *
     * ```ts
     * 0.1 <= (0.3 - 0.2)                  // false
     * x = new BigNumber(0.1)
     * x.lte(BigNumber(0.3).minus(0.2))    // true
     * BigNumber(-1).lte(x)                // true
     * BigNumber(10, 18).lte('i', 36)      // true
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    lte(n: BigNumber.Value, base?: number): boolean;

    /**
     * Returns `true` if the value of this BigNumber is `NaN`, otherwise returns `false`.
     *
     * ```ts
     * x = new BigNumber(NaN)
     * x.isNaN()                       // true
     * y = new BigNumber('Infinity')
     * y.isNaN()                       // false
     * ```
     */
    isNaN(): boolean;

    /**
     * Returns `true` if the value of this BigNumber is negative, otherwise returns `false`.
     *
     * ```ts
     * x = new BigNumber(-0)
     * x.isNegative()                  // true
     * y = new BigNumber(2)
     * y.isNegative()                  // false
     * ```
     */
    isNegative(): boolean;

    /**
     * Returns `true` if the value of this BigNumber is positive, otherwise returns `false`.
     *
     * ```ts
     * x = new BigNumber(-0)
     * x.isPositive()                  // false
     * y = new BigNumber(2)
     * y.isPositive()                  // true
     * ```
     */
    isPositive(): boolean;

    /**
     * Returns `true` if the value of this BigNumber is zero or minus zero, otherwise returns `false`.
     *
     * ```ts
     * x = new BigNumber(-0)
     * x.isZero()                 // true
     * ```
     */
    isZero(): boolean;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber minus `n`.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * 0.3 - 0.1                       // 0.19999999999999998
     * x = new BigNumber(0.3)
     * x.minus(0.1)                    // '0.2'
     * x.minus(0.6, 20)                // '0'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    minus(n: BigNumber.Value, base?: number): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer
     * remainder of dividing this BigNumber by `n`.
     *
     * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`
     * setting of this BigNumber constructor. If it is 1 (default value), the result will have the
     * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the
     * limits of double precision) and BigDecimal's `remainder` method.
     *
     * The return value is always exact and unrounded.
     *
     * See `MODULO_MODE` for a description of the other modulo modes.
     *
     * ```ts
     * 1 % 0.9                         // 0.09999999999999998
     * x = new BigNumber(1)
     * x.modulo(0.9)                   // '0.1'
     * y = new BigNumber(33)
     * y.modulo('a', 33)               // '3'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    modulo(n: BigNumber.Value, base?: number): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer
     * remainder of dividing this BigNumber by `n`.
     *
     * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`
     * setting of this BigNumber constructor. If it is 1 (default value), the result will have the
     * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the
     * limits of double precision) and BigDecimal's `remainder` method.
     *
     * The return value is always exact and unrounded.
     *
     * See `MODULO_MODE` for a description of the other modulo modes.
     *
     * ```ts
     * 1 % 0.9                      // 0.09999999999999998
     * x = new BigNumber(1)
     * x.mod(0.9)                   // '0.1'
     * y = new BigNumber(33)
     * y.mod('a', 33)               // '3'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    mod(n: BigNumber.Value, base?: number): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * 0.6 * 3                                // 1.7999999999999998
     * x = new BigNumber(0.6)
     * y = x.multipliedBy(3)                  // '1.8'
     * BigNumber('7e+500').multipliedBy(y)    // '1.26e+501'
     * x.multipliedBy('-a', 16)               // '-6'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    multipliedBy(n: BigNumber.Value, base?: number): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * 0.6 * 3                         // 1.7999999999999998
     * x = new BigNumber(0.6)
     * y = x.times(3)                  // '1.8'
     * BigNumber('7e+500').times(y)    // '1.26e+501'
     * x.times('-a', 16)               // '-6'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    times(n: BigNumber.Value, base?: number): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber negated, i.e. multiplied by -1.
     *
     * ```ts
     * x = new BigNumber(1.8)
     * x.negated()                     // '-1.8'
     * y = new BigNumber(-1.3)
     * y.negated()                     // '1.3'
     * ```
     */
    negated(): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber plus `n`.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * 0.1 + 0.2                       // 0.30000000000000004
     * x = new BigNumber(0.1)
     * y = x.plus(0.2)                 // '0.3'
     * BigNumber(0.7).plus(x).plus(y)  // '1.1'
     * x.plus('0.1', 8)                // '0.225'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    plus(n: BigNumber.Value, base?: number): BigNumber;

    /**
     * Returns the number of significant digits of the value of this BigNumber, or `null` if the value
     * of this BigNumber is ±`Infinity` or `NaN`.
     *
     * If `includeZeros` is true then any trailing zeros of the integer part of the value of this
     * BigNumber are counted as significant digits, otherwise they are not.
     *
     * Throws if `includeZeros` is invalid.
     *
     * ```ts
     * x = new BigNumber(9876.54321)
     * x.precision()                         // 9
     * y = new BigNumber(987000)
     * y.precision(false)                    // 3
     * y.precision(true)                     // 6
     * ```
     *
     * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.
     */
    precision(includeZeros?: boolean): number;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of
     * `significantDigits` significant digits using rounding mode `roundingMode`.
     *
     * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.
     *
     * Throws if `significantDigits` or `roundingMode` is invalid.
     *
     * ```ts
     * x = new BigNumber(9876.54321)
     * x.precision(6)                         // '9876.54'
     * x.precision(6, BigNumber.ROUND_UP)     // '9876.55'
     * x.precision(2)                         // '9900'
     * x.precision(2, 1)                      // '9800'
     * x                                      // '9876.54321'
     * ```
     *
     * @param significantDigits Significant digits, integer, 1 to 1e+9.
     * @param [roundingMode] Rounding mode, integer, 0 to 8.
     */
    precision(significantDigits: number, roundingMode?: BigNumber.RoundingMode): BigNumber;

    /**
     * Returns the number of significant digits of the value of this BigNumber,
     * or `null` if the value of this BigNumber is ±`Infinity` or `NaN`.
     *
     * If `includeZeros` is true then any trailing zeros of the integer part of
     * the value of this BigNumber are counted as significant digits, otherwise
     * they are not.
     *
     * Throws if `includeZeros` is invalid.
     *
     * ```ts
     * x = new BigNumber(9876.54321)
     * x.sd()                         // 9
     * y = new BigNumber(987000)
     * y.sd(false)                    // 3
     * y.sd(true)                     // 6
     * ```
     *
     * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.
     */
    sd(includeZeros?: boolean): number;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of
     * `significantDigits` significant digits using rounding mode `roundingMode`.
     *
     * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.
     *
     * Throws if `significantDigits` or `roundingMode` is invalid.
     *
     * ```ts
     * x = new BigNumber(9876.54321)
     * x.sd(6)                           // '9876.54'
     * x.sd(6, BigNumber.ROUND_UP)       // '9876.55'
     * x.sd(2)                           // '9900'
     * x.sd(2, 1)                        // '9800'
     * x                                 // '9876.54321'
     * ```
     *
     * @param significantDigits Significant digits, integer, 1 to 1e+9.
     * @param [roundingMode] Rounding mode, integer, 0 to 8.
     */
    sd(significantDigits: number, roundingMode?: BigNumber.RoundingMode): BigNumber;

    /**
     * Returns a BigNumber whose value is the value of this BigNumber shifted by `n` places.
     *
     * The shift is of the decimal point, i.e. of powers of ten, and is to the left if `n` is negative
     * or to the right if `n` is positive.
     *
     * The return value is always exact and unrounded.
     *
     * Throws if `n` is invalid.
     *
     * ```ts
     * x = new BigNumber(1.23)
     * x.shiftedBy(3)                      // '1230'
     * x.shiftedBy(-3)                     // '0.00123'
     * ```
     *
     * @param n The shift value, integer, -9007199254740991 to 9007199254740991.
     */
    shiftedBy(n: number): BigNumber;

    /**
     * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded
     * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.
     *
     * The return value will be correctly rounded, i.e. rounded as if the result was first calculated
     * to an infinite number of correct digits before rounding.
     *
     * ```ts
     * x = new BigNumber(16)
     * x.squareRoot()                  // '4'
     * y = new BigNumber(3)
     * y.squareRoot()                  // '1.73205080756887729353'
     * ```
     */
    squareRoot(): BigNumber;

    /**
     * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded
     * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.
     *
     * The return value will be correctly rounded, i.e. rounded as if the result was first calculated
     * to an infinite number of correct digits before rounding.
     *
     * ```ts
     * x = new BigNumber(16)
     * x.sqrt()                  // '4'
     * y = new BigNumber(3)
     * y.sqrt()                  // '1.73205080756887729353'
     * ```
     */
    sqrt(): BigNumber;

    /**
     * Returns a string representing the value of this BigNumber in exponential notation rounded using
     * rounding mode `roundingMode` to `decimalPlaces` decimal places, i.e with one digit before the
     * decimal point and `decimalPlaces` digits after it.
     *
     * If the value of this BigNumber in exponential notation has fewer than `decimalPlaces` fraction
     * digits, the return value will be appended with zeros accordingly.
     *
     * If `decimalPlaces` is omitted, or is `null` or `undefined`, the number of digits after the
     * decimal point defaults to the minimum number of digits necessary to represent the value
     * exactly.
     *
     * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.
     *
     * Throws if `decimalPlaces` or `roundingMode` is invalid.
     *
     * ```ts
     * x = 45.6
     * y = new BigNumber(x)
     * x.toExponential()               // '4.56e+1'
     * y.toExponential()               // '4.56e+1'
     * x.toExponential(0)              // '5e+1'
     * y.toExponential(0)              // '5e+1'
     * x.toExponential(1)              // '4.6e+1'
     * y.toExponential(1)              // '4.6e+1'
     * y.toExponential(1, 1)           // '4.5e+1'  (ROUND_DOWN)
     * x.toExponential(3)              // '4.560e+1'
     * y.toExponential(3)              // '4.560e+1'
     * ```
     *
     * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.
     * @param [roundingMode] Rounding mode, integer, 0 to 8.
     */
    toExponential(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;
    toExponential(): string;

    /**
     * Returns a string representing the value of this BigNumber in normal (fixed-point) notation
     * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`.
     *
     * If the value of this BigNumber in normal notation has fewer than `decimalPlaces` fraction
     * digits, the return value will be appended with zeros accordingly.
     *
     * Unlike `Number.prototype.toFixed`, which returns exponential notation if a number is greater or
     * equal to 10**21, this method will always return normal notation.
     *
     * If `decimalPlaces` is omitted or is `null` or `undefined`, the return value will be unrounded
     * and in normal notation. This is also unlike `Number.prototype.toFixed`, which returns the value
     * to zero decimal places. It is useful when normal notation is required and the current
     * `EXPONENTIAL_AT` setting causes `toString` to return exponential notation.
     *
     * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.
     *
     * Throws if `decimalPlaces` or `roundingMode` is invalid.
     *
     * ```ts
     * x = 3.456
     * y = new BigNumber(x)
     * x.toFixed()                     // '3'
     * y.toFixed()                     // '3.456'
     * y.toFixed(0)                    // '3'
     * x.toFixed(2)                    // '3.46'
     * y.toFixed(2)                    // '3.46'
     * y.toFixed(2, 1)                 // '3.45'  (ROUND_DOWN)
     * x.toFixed(5)                    // '3.45600'
     * y.toFixed(5)                    // '3.45600'
     * ```
     *
     * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.
     * @param [roundingMode] Rounding mode, integer, 0 to 8.
     */
    toFixed(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;
    toFixed(): string;

    /**
     * Returns a string representing the value of this BigNumber in normal (fixed-point) notation
     * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`, and formatted
     * according to the properties of the `format` or `FORMAT` object.
     *
     * The formatting object may contain some or all of the properties shown in the examples below.
     *
     * If `decimalPlaces` is omitted or is `null` or `undefined`, then the return value is not
     * rounded to a fixed number of decimal places.
     *
     * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.
     *
     * If `format` is omitted or is `null` or `undefined`, `FORMAT` is used.
     *
     * Throws if `decimalPlaces`, `roundingMode`, or `format` is invalid.
     *
     * ```ts
     * fmt = {
     *   decimalSeparator: '.',
     *   groupSeparator: ',',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   fractionGroupSeparator: ' ',
     *   fractionGroupSize: 0
     * }
     *
     * x = new BigNumber('123456789.123456789')
     *
     * // Set the global formatting options
     * BigNumber.config({ FORMAT: fmt })
     *
     * x.toFormat()                              // '123,456,789.123456789'
     * x.toFormat(3)                             // '123,456,789.123'
     *
     * // If a reference to the object assigned to FORMAT has been retained,
     * // the format properties can be changed directly
     * fmt.groupSeparator = ' '
     * fmt.fractionGroupSize = 5
     * x.toFormat()                              // '123 456 789.12345 6789'
     *
     * // Alternatively, pass the formatting options as an argument
     * fmt = {
     *   decimalSeparator: ',',
     *   groupSeparator: '.',
     *   groupSize: 3,
     *   secondaryGroupSize: 2
     * }
     *
     * x.toFormat()                              // '123 456 789.12345 6789'
     * x.toFormat(fmt)                           // '12.34.56.789,123456789'
     * x.toFormat(2, fmt)                        // '12.34.56.789,12'
     * x.toFormat(3, BigNumber.ROUND_UP, fmt)    // '12.34.56.789,124'
     * ```
     *
     * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.
     * @param [roundingMode] Rounding mode, integer, 0 to 8.
     * @param [format] Formatting options object. See `BigNumber.Format`.
     */
    toFormat(decimalPlaces: number, roundingMode: BigNumber.RoundingMode, format?: BigNumber.Format): string;
    toFormat(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;
    toFormat(decimalPlaces?: number): string;
    toFormat(decimalPlaces: number, format: BigNumber.Format): string;
    toFormat(format: BigNumber.Format): string;

    /**
     * Returns an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to `max_denominator`.
     * If a maximum denominator, `max_denominator`, is not specified, or is `null` or `undefined`, the
     * denominator will be the lowest value necessary to represent the number exactly.
     *
     * Throws if `max_denominator` is invalid.
     *
     * ```ts
     * x = new BigNumber(1.75)
     * x.toFraction()                  // '7, 4'
     *
     * pi = new BigNumber('3.14159265358')
     * pi.toFraction()                 // '157079632679,50000000000'
     * pi.toFraction(100000)           // '312689, 99532'
     * pi.toFraction(10000)            // '355, 113'
     * pi.toFraction(100)              // '311, 99'
     * pi.toFraction(10)               // '22, 7'
     * pi.toFraction(1)                // '3, 1'
     * ```
     *
     * @param [max_denominator] The maximum denominator, integer > 0, or Infinity.
     */
    toFraction(max_denominator?: BigNumber.Value): [BigNumber, BigNumber];

    /** As `valueOf`. */
    toJSON(): string;

    /**
     * Returns the value of this BigNumber as a JavaScript primitive number.
     *
     * Using the unary plus operator gives the same result.
     *
     * ```ts
     * x = new BigNumber(456.789)
     * x.toNumber()                    // 456.789
     * +x                              // 456.789
     *
     * y = new BigNumber('45987349857634085409857349856430985')
     * y.toNumber()                    // 4.598734985763409e+34
     *
     * z = new BigNumber(-0)
     * 1 / z.toNumber()                // -Infinity
     * 1 / +z                          // -Infinity
     * ```
     */
    toNumber(): number;

    /**
     * Returns a string representing the value of this BigNumber rounded to `significantDigits`
     * significant digits using rounding mode `roundingMode`.
     *
     * If `significantDigits` is less than the number of digits necessary to represent the integer
     * part of the value in normal (fixed-point) notation, then exponential notation is used.
     *
     * If `significantDigits` is omitted, or is `null` or `undefined`, then the return value is the
     * same as `n.toString()`.
     *
     * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.
     *
     * Throws if `significantDigits` or `roundingMode` is invalid.
     *
     * ```ts
     * x = 45.6
     * y = new BigNumber(x)
     * x.toPrecision()                 // '45.6'
     * y.toPrecision()                 // '45.6'
     * x.toPrecision(1)                // '5e+1'
     * y.toPrecision(1)                // '5e+1'
     * y.toPrecision(2, 0)             // '4.6e+1'  (ROUND_UP)
     * y.toPrecision(2, 1)             // '4.5e+1'  (ROUND_DOWN)
     * x.toPrecision(5)                // '45.600'
     * y.toPrecision(5)                // '45.600'
     * ```
     *
     * @param [significantDigits] Significant digits, integer, 1 to 1e+9.
     * @param [roundingMode] Rounding mode, integer 0 to 8.
     */
    toPrecision(significantDigits: number, roundingMode?: BigNumber.RoundingMode): string;
    toPrecision(): string;

    /**
     * Returns a string representing the value of this BigNumber in base `base`, or base 10 if `base`
     * is omitted or is `null` or `undefined`.
     *
     * For bases above 10, and using the default base conversion alphabet (see `ALPHABET`), values
     * from 10 to 35 are represented by a-z (the same as `Number.prototype.toString`).
     *
     * If a base is specified the value is rounded according to the current `DECIMAL_PLACES` and
     * `ROUNDING_MODE` settings, otherwise it is not.
     *
     * If a base is not specified, and this BigNumber has a positive exponent that is equal to or
     * greater than the positive component of the current `EXPONENTIAL_AT` setting, or a negative
     * exponent equal to or less than the negative component of the setting, then exponential notation
     * is returned.
     *
     * If `base` is `null` or `undefined` it is ignored.
     *
     * Throws if `base` is invalid.
     *
     * ```ts
     * x = new BigNumber(750000)
     * x.toString()                    // '750000'
     * BigNumber.config({ EXPONENTIAL_AT: 5 })
     * x.toString()                    // '7.5e+5'
     *
     * y = new BigNumber(362.875)
     * y.toString(2)                   // '101101010.111'
     * y.toString(9)                   // '442.77777777777777777778'
     * y.toString(32)                  // 'ba.s'
     *
     * BigNumber.config({ DECIMAL_PLACES: 4 });
     * z = new BigNumber('1.23456789')
     * z.toString()                    // '1.23456789'
     * z.toString(10)                  // '1.2346'
     * ```
     *
     * @param [base] The base, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).
     */
    toString(base?: number): string;

    /**
     * As `toString`, but does not accept a base argument and includes the minus sign for negative
     * zero.
     *
     * ``ts
     * x = new BigNumber('-0')
     * x.toString()                    // '0'
     * x.valueOf()                     // '-0'
     * y = new BigNumber('1.777e+457')
     * y.valueOf()                     // '1.777e+457'
     * ```
     */
    valueOf(): string;

    /** Helps ES6 import. */
    private static readonly default?: BigNumber.Constructor;

    /** Helps ES6 import. */
    private static readonly BigNumber?: BigNumber.Constructor;

    /** Rounds away from zero. */
    static readonly ROUND_UP: 0;

    /** Rounds towards zero. */
    static readonly ROUND_DOWN: 1;

    /** Rounds towards Infinity. */
    static readonly ROUND_CEIL: 2;

    /** Rounds towards -Infinity. */
    static readonly ROUND_FLOOR: 3;

    /** Rounds towards nearest neighbour. If equidistant, rounds away from zero . */
    static readonly ROUND_HALF_UP: 4;

    /** Rounds towards nearest neighbour. If equidistant, rounds towards zero. */
    static readonly ROUND_HALF_DOWN: 5;

    /** Rounds towards nearest neighbour. If equidistant, rounds towards even neighbour. */
    static readonly ROUND_HALF_EVEN: 6;

    /** Rounds towards nearest neighbour. If equidistant, rounds towards Infinity. */
    static readonly ROUND_HALF_CEIL: 7;

    /** Rounds towards nearest neighbour. If equidistant, rounds towards -Infinity. */
    static readonly ROUND_HALF_FLOOR: 8;

    /** See `MODULO_MODE`. */
    static readonly EUCLID: 9;

    /**
     * To aid in debugging, if a `BigNumber.DEBUG` property is `true` then an error will be thrown
     * if the BigNumber constructor receives an invalid `BigNumber.Value`, or if `BigNumber.isBigNumber`
     * receives a BigNumber instance that is malformed.
     *
     * ```ts
     * // No error, and BigNumber NaN is returned.
     * new BigNumber('blurgh')    // 'NaN'
     * new BigNumber(9, 2)        // 'NaN'
     * BigNumber.DEBUG = true
     * new BigNumber('blurgh')    // '[BigNumber Error] Not a number'
     * new BigNumber(9, 2)        // '[BigNumber Error] Not a base 2 number'
     * ```
     *
     * An error will also be thrown if a `BigNumber.Value` is of type number with more than 15
     * significant digits, as calling `toString` or `valueOf` on such numbers may not result
     * in the intended value.
     *
     * ```ts
     * console.log(823456789123456.3)       //  823456789123456.2
     * // No error, and the returned BigNumber does not have the same value as the number literal.
     * new BigNumber(823456789123456.3)     // '823456789123456.2'
     * BigNumber.DEBUG = true
     * new BigNumber(823456789123456.3)
     * // '[BigNumber Error] Number primitive has more than 15 significant digits'
     * ```
     *
     * Check that a BigNumber instance is well-formed:
     *
     * ```ts
     * x = new BigNumber(10)
     *
     * BigNumber.DEBUG = false
     * // Change x.c to an illegitimate value.
     * x.c = NaN
     * // No error, as BigNumber.DEBUG is false.
     * BigNumber.isBigNumber(x)    // true
     *
     * BigNumber.DEBUG = true
     * BigNumber.isBigNumber(x)    // '[BigNumber Error] Invalid BigNumber'
     * ```
     */
    static DEBUG?: boolean;

    /**
     * Returns a new independent BigNumber constructor with configuration as described by `object`, or
     * with the default configuration if object is `null` or `undefined`.
     *
     * Throws if `object` is not an object.
     *
     * ```ts
     * BigNumber.config({ DECIMAL_PLACES: 5 })
     * BN = BigNumber.clone({ DECIMAL_PLACES: 9 })
     *
     * x = new BigNumber(1)
     * y = new BN(1)
     *
     * x.div(3)                        // 0.33333
     * y.div(3)                        // 0.333333333
     *
     * // BN = BigNumber.clone({ DECIMAL_PLACES: 9 }) is equivalent to:
     * BN = BigNumber.clone()
     * BN.config({ DECIMAL_PLACES: 9 })
     * ```
     *
     * @param [object] The configuration object.
     */
    static clone(object?: BigNumber.Config): BigNumber.Constructor;

    /**
     * Configures the settings that apply to this BigNumber constructor.
     *
     * The configuration object, `object`, contains any number of the properties shown in the example
     * below.
     *
     * Returns an object with the above properties and their current values.
     *
     * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the
     * properties.
     *
     * ```ts
     * BigNumber.config({
     *     DECIMAL_PLACES: 40,
     *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,
     *     EXPONENTIAL_AT: [-10, 20],
     *     RANGE: [-500, 500],
     *     CRYPTO: true,
     *     MODULO_MODE: BigNumber.ROUND_FLOOR,
     *     POW_PRECISION: 80,
     *     FORMAT: {
     *         groupSize: 3,
     *         groupSeparator: ' ',
     *         decimalSeparator: ','
     *     },
     *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
     * });
     *
     * BigNumber.config().DECIMAL_PLACES        // 40
     * ```
     *
     * @param object The configuration object.
     */
    static config(object?: BigNumber.Config): BigNumber.Config;

    /**
     * Returns `true` if `value` is a BigNumber instance, otherwise returns `false`.
     *
     * If `BigNumber.DEBUG` is `true`, throws if a BigNumber instance is not well-formed.
     *
     * ```ts
     * x = 42
     * y = new BigNumber(x)
     *
     * BigNumber.isBigNumber(x)             // false
     * y instanceof BigNumber               // true
     * BigNumber.isBigNumber(y)             // true
     *
     * BN = BigNumber.clone();
     * z = new BN(x)
     * z instanceof BigNumber               // false
     * BigNumber.isBigNumber(z)             // true
     * ```
     *
     * @param value The value to test.
     */
    static isBigNumber(value: any): value is BigNumber;

    /**
     * Returns a BigNumber whose value is the maximum of the arguments.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * x = new BigNumber('3257869345.0378653')
     * BigNumber.maximum(4e9, x, '123456789.9')      // '4000000000'
     *
     * arr = [12, '13', new BigNumber(14)]
     * BigNumber.maximum.apply(null, arr)            // '14'
     * ```
     *
     * @param n A numeric value.
     */
    static maximum(...n: BigNumber.Value[]): BigNumber;

    /**
     * Returns a BigNumber whose value is the maximum of the arguments.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * x = new BigNumber('3257869345.0378653')
     * BigNumber.max(4e9, x, '123456789.9')      // '4000000000'
     *
     * arr = [12, '13', new BigNumber(14)]
     * BigNumber.max.apply(null, arr)            // '14'
     * ```
     *
     * @param n A numeric value.
     */
    static max(...n: BigNumber.Value[]): BigNumber;

    /**
     * Returns a BigNumber whose value is the minimum of the arguments.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * x = new BigNumber('3257869345.0378653')
     * BigNumber.minimum(4e9, x, '123456789.9')          // '123456789.9'
     *
     * arr = [2, new BigNumber(-14), '-15.9999', -12]
     * BigNumber.minimum.apply(null, arr)                // '-15.9999'
     * ```
     *
     * @param n A numeric value.
     */
    static minimum(...n: BigNumber.Value[]): BigNumber;

    /**
     * Returns a BigNumber whose value is the minimum of the arguments.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * x = new BigNumber('3257869345.0378653')
     * BigNumber.min(4e9, x, '123456789.9')             // '123456789.9'
     *
     * arr = [2, new BigNumber(-14), '-15.9999', -12]
     * BigNumber.min.apply(null, arr)                   // '-15.9999'
     * ```
     *
     * @param n A numeric value.
     */
    static min(...n: BigNumber.Value[]): BigNumber;

    /**
     * Returns a new BigNumber with a pseudo-random value equal to or greater than 0 and less than 1.
     *
     * The return value will have `decimalPlaces` decimal places, or less if trailing zeros are
     * produced. If `decimalPlaces` is omitted, the current `DECIMAL_PLACES` setting will be used.
     *
     * Depending on the value of this BigNumber constructor's `CRYPTO` setting and the support for the
     * `crypto` object in the host environment, the random digits of the return value are generated by
     * either `Math.random` (fastest), `crypto.getRandomValues` (Web Cryptography API in recent
     * browsers) or `crypto.randomBytes` (Node.js).
     *
     * To be able to set `CRYPTO` to true when using Node.js, the `crypto` object must be available
     * globally:
     *
     * ```ts
     * global.crypto = require('crypto')
     * ```
     *
     * If `CRYPTO` is true, i.e. one of the `crypto` methods is to be used, the value of a returned
     * BigNumber should be cryptographically secure and statistically indistinguishable from a random
     * value.
     *
     * Throws if `decimalPlaces` is invalid.
     *
     * ```ts
     * BigNumber.config({ DECIMAL_PLACES: 10 })
     * BigNumber.random()              // '0.4117936847'
     * BigNumber.random(20)            // '0.78193327636914089009'
     * ```
     *
     * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.
     */
    static random(decimalPlaces?: number): BigNumber;

    /**
     * Returns a BigNumber whose value is the sum of the arguments.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * x = new BigNumber('3257869345.0378653')
     * BigNumber.sum(4e9, x, '123456789.9')      // '7381326134.9378653'
     *
     * arr = [2, new BigNumber(14), '15.9999', 12]
     * BigNumber.sum.apply(null, arr)            // '43.9999'
     * ```
     *
     * @param n A numeric value.
     */
    static sum(...n: BigNumber.Value[]): BigNumber;

    /**
     * Configures the settings that apply to this BigNumber constructor.
     *
     * The configuration object, `object`, contains any number of the properties shown in the example
     * below.
     *
     * Returns an object with the above properties and their current values.
     *
     * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the
     * properties.
     *
     * ```ts
     * BigNumber.set({
     *     DECIMAL_PLACES: 40,
     *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,
     *     EXPONENTIAL_AT: [-10, 20],
     *     RANGE: [-500, 500],
     *     CRYPTO: true,
     *     MODULO_MODE: BigNumber.ROUND_FLOOR,
     *     POW_PRECISION: 80,
     *     FORMAT: {
     *         groupSize: 3,
     *         groupSeparator: ' ',
     *         decimalSeparator: ','
     *     },
     *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
     * });
     *
     * BigNumber.set().DECIMAL_PLACES        // 40
     * ```
     *
     * @param object The configuration object.
     */
    static set(object?: BigNumber.Config): BigNumber.Config;
}

/**
 * @public
 */
export declare type BlockIdentifier = Quantity | Tag;

/**
 * @public
 */
export declare type BlockObject = {
    /** the block number. null when its pending block. */
    number: Quantity;
    /** hash of the block. null when its pending block. */
    hash: TxHash;
    /** hash of the parent block. */
    parentHash: TxHash;
    /** hash of the generated proof-of-work. null when its pending block. 8 Bytes  */
    nonce: Data;
    /** SHA3 of the uncles data in the block. */
    sha3Uncles: TxHash;
    /** the bloom filter for the logs of the block. null when its pending block. 256 Bytes */
    logsBloom: Data;
    /** the root of the transaction trie of the block. */
    transactionsRoot: TxHash;
    /** the root of the final state trie of the block. */
    stateRoot: TxHash;
    /** the root of the receipts trie of the block. */
    receiptsRoot: TxHash;
    /** the address of the beneficiary to whom the mining rewards were given. */
    miner: Address;
    /** integer of the difficulty for this block. */
    difficulty: BigNumber;
    /** integer of the total difficulty of the chain until this block. */
    totalDifficulty: BigNumber;
    /** the "extra data" field of this block. */
    extraData: Data;
    /** integer the size of this block in bytes. */
    size: Quantity;
    /** the maximum gas allowed in this block. */
    gasLimit: Quantity;
    /** the total used gas by all transactions in this block. */
    gasUsed: Quantity;
    /** the unix timestamp for when the block was collated. */
    timestamp: Quantity;
    /** Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter. */
    transactions: Array<TxHash> | Array<TransactionObject>;
    /** Array of uncle hashes */
    uncles: Array<TxHash>;
};

/**
 * @public
 */
export declare function bytesToHex(bytes: Uint8Array): string;

/**
 * Decodes an Uint8Array or hex string into a UTF-8 string
 * @public
 */
export declare function bytesToUtf8String(bytesOrHexString: Uint8Array | string): string;

export declare type Callback = (err: Error | null, message?: any) => void;

/**
 * SolidityCoder prototype should be used to encode/decode solidity params of any type
 */
export declare namespace coder {
    /**
     * Should be used to encode list of params
     *
     * @method encodeParams
     * @param {Array} types
     * @param {Array} params
     * @return {string} encoded list of params
     */
    export function encodeParams(types: ReadonlyArray<Readonly<AbiOutput | string>>, params: any[]): string;
    /**
     * Should be used to decode list of params
     *
     * @method decodeParam
     * @param {Array} types
     * @param {string} bytes
     * @return {Array} array of plain params
     */
    export function decodeParams(outputs: ReadonlyArray<Readonly<AbiOutput | string>>, bytes: string): any;
}

export declare function concatBytes(...buffers: Uint8Array[]): Uint8Array;

/**
 * @public
 */
export declare type ConfirmedTransaction = TransactionObject & {
    type: TransactionType.confirmed;
    receipt: TransactionReceipt;
};

/**
 * @public
 * Should be called to create new contract instance
 */
export declare class Contract {
    requestManager: RequestManager;
    abi: AbiItem[];
    address: string;
    allEvents: (options: FilterOptions) => Promise<EthFilter>;
    events: {
        [key: string]: EventFilterCreator;
    };
    transactionHash: string | null;
    constructor(requestManager: RequestManager, abi: AbiItem[], address: string);
}

/**
 * @public
 * Should be called to create new ContractFactory instance
 */
export declare class ContractFactory {
    requestManager: RequestManager;
    abi: any[];
    constructor(requestManager: RequestManager, abi: any[]);
    /**
     * Should be called to create new contract on a blockchain
     */
    deploy(param1: any, param2: any, options: TransactionOptions): Promise<Contract>;
    deploy(param1: any, options: TransactionOptions): Promise<Contract>;
    deploy(options: TransactionOptions): Promise<Contract>;
    /**
     * Should be called to get access to existing contract on a blockchain
     *
     * @param address - The contract address
     */
    at(address: string): Promise<Contract>;
}

/**
 * Hex string
 * @public
 */
export declare type Data = string;

/**
 * @public
 */
export declare type DroppedTransaction = {
    type: TransactionType.dropped;
    hash: string;
    nonce: number;
};

/**
 * @public
 */
export declare namespace eth {
    const eth_getBalance: Method<BigNumber>;
    const eth_getStorageAt: Method<string>;
    const eth_getCode: Method<string>;
    const eth_getBlockByHash: Method<BlockObject | null>;
    const eth_getBlockByNumber: Method<BlockObject | null>;
    const eth_getUncleByBlockHashAndIndex: Method<BlockObject | null>;
    const eth_getUncleByBlockNumberAndIndex: Method<BlockObject | null>;
    const eth_getBlockTransactionCountByHash: Method<number>;
    const eth_getBlockTransactionCountByNumber: Method<number>;
    const eth_getUncleCountByBlockHash: Method<number>;
    const eth_getUncleCountByBlockNumber: Method<number>;
    const eth_getTransactionByHash: Method<TransactionObject | null>;
    const eth_getTransactionByBlockHashAndIndex: Method<TransactionObject | null>;
    const eth_getTransactionByBlockNumberAndIndex: Method<TransactionObject | null>;
    const eth_getTransactionReceipt: Method<TransactionReceipt | null>;
    const eth_getTransactionCount: Method<number>;
    const eth_sendRawTransaction: Method<string>;
    const web3_sha3: Method<string>;
    const eth_sendTransaction: Method<string>;
    const eth_sign: Method<string>;
    const eth_call: Method<string>;
    const eth_estimateGas: Method<number>;
    const eth_submitWork: Method<boolean>;
    const eth_getWork: Method<any[]>;
    const eth_coinbase: Property<string>;
    const eth_mining: Property<boolean>;
    const eth_hashrate: Property<number>;
    const eth_syncing: Property<Syncing>;
    const eth_gasPrice: Property<BigNumber>;
    const eth_accounts: Property<any[]>;
    const eth_blockNumber: Property<number>;
    const eth_protocolVersion: Property<number>;
    const web3_clientVersion: Property<string>;
    const net_version: Property<string>;
    const shh_version: Method<number>;
    const shh_post: Method<boolean>;
    const personal_newAccount: Method<string>;
    const personal_importRawKey: Method<string>;
    const personal_sign: Method<string>;
    const personal_ecRecover: Method<string>;
    const personal_unlockAccount: Method<boolean>;
    const personal_sendTransaction: Method<string>;
    const personal_lockAccount: Method<boolean>;
    const personal_listAccounts: Property<any[]>;
    const net_listening: Property<boolean>;
    const net_peerCount: Property<number>;
    const eth_newFilter: Method<string>;
    const eth_getLogs: Method<any[]>;
    const eth_newBlockFilter: Method<string>;
    const eth_newPendingTransactionFilter: Method<string>;
    const eth_uninstallFilter: Method<boolean>;
    const eth_getFilterLogs: Method<any[]>;
    const eth_getFilterChanges: Method<any[]>;
    const eth_submitHashrate: Method<boolean>;
    const shh_newIdentity: Method<string>;
    const shh_hasIdentity: Method<boolean>;
    const shh_newGroup: Method<string>;
    const shh_addToGroup: Method<boolean>;
    const shh_newFilter: Method<string>;
    const shh_uninstallFilter: Method<boolean>;
    const shh_getLogs: Method<any[]>;
    const shh_getFilterMessages: Method<any[]>;
    const shh_getFilterChanges: Method<any[]>;
    const shh_getMessages: Method<any[]>;
}

export declare class EthBlockFilter extends EthFilter<TxHash, TxHash> {
    constructor(requestManager: RequestManager);
    getNewFilter(): Promise<string>;
}

export declare class EthFilter<TransformedLog = LogObject, ReceivedLog = LogObject> extends AbstractFilter<ReceivedLog, TransformedLog> {
    requestManager: RequestManager;
    options: FilterOptions;
    formatter: (message: ReceivedLog) => TransformedLog;
    constructor(requestManager: RequestManager, options: FilterOptions, formatter?: (message: ReceivedLog) => TransformedLog);
    getLogs(): Promise<ReceivedLog[]>;
    protected getNewFilter(): Promise<Data>;
    protected getChanges(): Promise<ReceivedLog[]>;
    protected uninstall(): Promise<boolean>;
}

export declare class EthPendingTransactionFilter extends EthFilter<TxHash, TxHash> {
    constructor(requestManager: RequestManager);
    getNewFilter(): Promise<string>;
}

/**
 * @public
 */
export declare type EventData = {
    data: string;
    topics: string[];
    address: string;
};

/**
 * @public
 */
export declare type EventFilterCreator = (indexed: {
    [key: string]: any;
}, options?: FilterOptions) => Promise<EthFilter>;

/**
 * @public
 * Should be called to get display name of contract function
 */
export declare function extractDisplayName(name: string): string;

/**
 * @public
 * Should be called to get type name of contract function
 */
export declare function extractTypeName(name: string): string;

export declare type FetchFunction = (url: string, params: {
    body?: any;
    method?: string;
    mode?: string;
    headers?: any;
}) => Promise<any>;

export declare type FilterCallback = (messages: LogObject[] | string[]) => void;

/**
 * @public
 */
export declare type FilterOptions = {
    /** (optional, default: "latest") Integer block number, or "latest" for the last mined block or "pending", "earliest" for not yet mined transactions. */
    fromBlock?: BlockIdentifier;
    /** (optional, default: "latest") Integer block number, or "latest" for the last mined block or "pending", "earliest" for not yet mined transactions. */
    toBlock?: BlockIdentifier;
    /** (optional) Contract address or a list of addresses from which logs should originate. */
    address?: Data | Address;
    /** (optional) Array of 32 Bytes DATA topics. Topics are order-dependent. Each topic can also be an array of DATA with "or" options. */
    topics?: TopicFilter;
};

/**
 * @public
 */
export declare type FinishedTransactionAndReceipt = TransactionAndReceipt & {
    status: TransactionStatus;
};

/**
 * @public
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 */
export declare function fromAscii(str: string, num?: number): string;

/**
 * @public
 * Converts value to it's hex representation
 */
export declare function fromDecimal(value: BigNumber.Value): string;

/**
 * @public
 * If the bit N is 1
 */
export declare function fromTwosComplement(num: BigNumber, bits?: number): BigNumber;

/**
 * @public
 * Takes a number of wei and converts it to any other ether unit.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 */
export declare function fromWei(num: BigNumber, unit: Unit): BigNumber;

export declare function fromWei(num: string | number, unit: Unit): string;

/**
 * @public
 */
export declare function getAddress(address: string): string;

/**
 * @public
 * Returns value of unit in Wei
 */
export declare function getValueOfUnit(_unit: Unit): BigNumber;

/**
 * @public
 */
export declare type Hex = string;

/**
 * @public
 */
export declare function hexToBytes(hex: string): Uint8Array;

/**
 * @public
 *
 * HttpProvider should be used to send rpc calls over http
 */
export declare class HTTPProvider {
    host: string;
    options: HTTPProviderOptions;
    debug: boolean;
    constructor(host: string, options?: HTTPProviderOptions);
    send(): void;
    /**
     * Should be used to make async request
     */
    sendAsync(payload: RPCMessage | RPCMessage[], callback: Callback): void;
}

export declare type HTTPProviderOptions = {
    headers?: {
        [key: string]: string;
    };
    timeout?: number;
    fetch?: FetchFunction;
};

export declare type IFuture<T> = Promise<T> & {
    resolve: (x: T) => void;
    reject: (x: Error) => void;
    finally: (fn: () => void) => void;
    isPending: boolean;
};

export declare function inputAddressFormatter(address: string): string;

export declare function inputBlockNumberFormatter(blockNumber: Quantity | Tag | null): string | null;

/**
 * Formats the input of a transaction and converts all values to HEX
 */
export declare function inputCallFormatter(options: TransactionOptions): TransactionOptions;

export declare function inputDefaultBlockNumberFormatter(blockNumber?: Quantity | Tag): string | Tag | null;

export declare function inputFilterOptions(options: FilterOptions): FilterOptions;

/**
 * Formats the input of a whisper post and converts all values to HEX
 */
export declare function inputPostFormatter(post: any): any;

/**
 * Formats the input of a transaction and converts all values to HEX
 *
 * @param transaction - options
 */
export declare function inputTransactionFormatter(options: TransactionOptions): TransactionOptions;

/**
 * Ensures a correct transactionId is provided
 */
export declare function inputTransactionId(txId: string): string;

export declare interface IPropertyOptions<V> {
    getter: string;
    outputFormatter: (_: any) => V;
}

/**
 * @public
 * Checks if the given string is an address
 */
export declare function isAddress(address: any): boolean;

/**
 * @public
 * Returns true if object is array, otherwise false
 */
export declare function isArray<T extends Array<any>>(object: any): object is T;

/**
 * @public
 * Returns true if object is BigNumber, otherwise false
 */
export declare function isBigNumber(object: any): object is BigNumber;

/**
 * @public
 * Returns true if given string is a valid Ethereum block header bloom.
 */
export declare function isBloom(bloom: string): boolean;

/**
 * @public
 * Returns true if object is boolean, otherwise false
 */
export declare function isBoolean(object: any): object is boolean;

/**
 * @public
 * Checks if the given string is a checksummed address
 */
export declare function isChecksumAddress(_address: string): boolean;

/**
 * @public
 * Returns true if object is function, otherwise false
 */
export declare function isFunction(object: any): object is CallableFunction;

/**
 * @public
 * Converts value to it's decimal representation in string
 */
export declare function isHex(value: string): boolean;

/**
 * @public
 * Returns true if given string is valid json object
 */
export declare function isJson(str: string): boolean;

/**
 * @public
 * Returns true if object is Objet, otherwise false
 */
export declare function isObject<T extends object>(object: any): object is T;

/**
 * Returns true if the provided blockNumber is 'latest', 'pending' or 'earliest
 *
 * @param blockNumber - The given blocknumber
 */
export declare function isPredefinedBlockNumber(blockNumber: Quantity | Tag): blockNumber is Tag;

/**
 * @public
 * Checks if the given string is strictly an address
 */
export declare function isStrictAddress(address: any): boolean;

/**
 * @public
 * Returns true if object is string, otherwise false
 */
export declare function isString(value: any): value is string;

/**
 * @public
 * Returns true if given string is a valid log topic.
 */
export declare function isTopic(topic: string): boolean;

/**
 * Should be called to check if jsonrpc response is valid
 */
export declare function isValidResponse(response: RPCResponse | RPCResponse[]): boolean;

export declare interface IWebSocket {
    /**
     * Closes the WebSocket connection, optionally using code as the the WebSocket connection close code and reason as the the WebSocket connection close reason.
     */
    close(code?: number, reason?: string): void;
    /**
     * Transmits data using the WebSocket connection. data can be a string, a Blob, an ArrayBuffer, or an ArrayBufferView.
     */
    send(data: string): void;
    onclose: ((this: this, ev: any) => any) | null;
    onerror: ((this: this, ev: any) => any) | null;
    onmessage: ((this: this, ev: any) => any) | null;
    onopen: ((this: this, ev: any) => any) | null;
}

/**
 * @public
 */
export declare type LogObject = {
    /** true when the log was removed, due to a chain reorganization. false if its a valid log. */
    removed: boolean;
    /** integer of the log index position in the block. null when its pending log. */
    logIndex: Quantity;
    /** integer of the transactions index position log was created from. null when its pending log. */
    transactionIndex: Quantity;
    /** hash of the transactions this log was created from. null when its pending log. */
    transactionHash: TxHash;
    /** hash of the block where this log was in. null when its pending. null when its pending log. */
    blockHash: TxHash;
    /** the block number where this log was in. null when its pending. null when its pending log. */
    blockNumber: Quantity;
    /** address from which this log originated. */
    address: Address;
    /** contains one or more 32 Bytes non-indexed arguments of the log. */
    data: Data;
    /**
     * Array of 0 to 4 32 Bytes DATA of indexed log arguments. (In solidity: The first topic is the hash of the signature
     * of the event (e.g. Deposit(address,bytes32,uint256)), except you declared the event with the anonymous specifier.)
     */
    topics: Array<Data>;
};

export declare let messageId: number;

/**
 * @public
 */
export declare class Method<Output> {
    callName: string;
    params: number;
    inputFormatter: Array<null | ((a: any) => any)>;
    outputFormatter: (something: any) => Output;
    constructor(options: {
        callName: string;
        params: number;
        inputFormatter: Array<null | ((a: any) => any)>;
        outputFormatter: (val: any) => Output;
    });
    /**
     * Should be called to check if the number of arguments is correct
     *
     * @param arguments - The list of arguments
     */
    validateArgs(args: any[]): void;
    /**
     * Should be called to format input args of method
     *
     * @param args - The array of arguments
     */
    formatInput(args: any[]): any[];
    /**
     * Should be called to format output(result) of method
     *
     * @param result - The result to be formatted
     */
    formatOutput(result: any): Output | null;
    /**
     * Should create payload from given input args
     *
     * @param args - The given input arguments
     */
    toPayload(args: any[]): {
        method: string;
        params: any[];
    };
    execute(requestManager: RequestManager, ...args: any[]): Promise<Output | null>;
}

/**
 * Should format the output to a big number
 *
 * @param output - The provided output
 */
export declare function outputBigNumberFormatter(output: BigNumber.Value): BigNumber;

/**
 * Formats the output of a block to its proper value
 */
export declare function outputBlockFormatter(block: BlockObject | null): BlockObject | null;

/**
 * Formats the output of a log
 */
export declare function outputLogFormatter(log: LogObject): LogObject;

/**
 * Formats the output of a received post message
 */
export declare function outputPostFormatter(post: SHHFilterMessage): SHHFilterMessage | null;

export declare function outputSyncingFormatter(result: Syncing): Syncing;

/**
 * Formats the output of a transaction to its proper values
 *
 * @param tx - The transaction
 */
export declare function outputTransactionFormatter(tx: TransactionObject): TransactionObject | null;

/**
 * Formats the output of a transaction receipt to its proper values
 *
 * @param receipt - The transaction receipt
 */
export declare function outputTransactionReceiptFormatter(receipt: TransactionReceipt): TransactionReceipt | null;

/**
 * @public
 * Should be called to pad string to expected length
 */
export declare function padLeft(str: string, chars: number, sign?: string): string;

/**
 * @public
 * Should be called to pad string to expected length
 */
export declare function padRight(str: string, chars: number, sign?: string): string;

/**
 * @public
 */
export declare type PendingTransaction = TransactionObject & {
    type: TransactionType.pending;
};

/**
 * @public
 */
export declare class Property<V> {
    getter: string;
    outputFormatter: (_: any) => V;
    constructor(options: IPropertyOptions<V>);
    /**
     * Should be called to format output(result) of method
     *
     * @param result - The result to be formatted
     */
    formatOutput(result: any): V;
    execute(requestManager: RequestManager, ..._unusedArgs: any[]): Promise<V>;
}

/**
 * @public
 */
export declare type Quantity = number | Hex;

/**
 * @public
 */
export declare type QueuedTransaction = {
    type: TransactionType.queued;
    hash: string;
    nonce: number;
};

/**
 * @public
 */
export declare type ReplacedTransaction = {
    type: TransactionType.replaced;
    hash: string;
    nonce: number;
};

/**
 * @public
 * It's responsible for passing messages to providers
 * It's also responsible for polling the ethereum node for incoming messages
 * Default poll timeout is 1 second
 */
declare class RequestManager {
    provider: any;
    /** Returns the current client version. */
    web3_clientVersion: () => Promise<string>;
    /** Returns Keccak-256 (not the standardized SHA3-256) of the given data. */
    web3_sha3: (data: Data) => Promise<Data>;
    /** Returns the current network id. */
    net_version: () => Promise<string>;
    /** Returns number of peers currently connected to the client. */
    net_peerCount: () => Promise<Quantity>;
    /** Returns true if client is actively listening for network connections. */
    net_listening: () => Promise<boolean>;
    /** Returns the current ethereum protocol version. */
    eth_protocolVersion: () => Promise<number>;
    /** Returns an object with data about the sync status or false. */
    eth_syncing: () => Promise<false | Syncing>;
    /** Returns the client coinbase address. */
    eth_coinbase: () => Promise<Address>;
    /** Returns true if client is actively mining new blocks. */
    eth_mining: () => Promise<boolean>;
    /** Returns the number of hashes per second that the node is mining with. */
    eth_hashrate: () => Promise<Quantity>;
    /** Returns the current price per gas in wei. */
    eth_gasPrice: () => Promise<BigNumber>;
    /** Returns a list of addresses owned by client. */
    eth_accounts: () => Promise<Address[]>;
    /** Returns the number of most recent block. */
    eth_blockNumber: () => Promise<Quantity>;
    /** Returns the balance of the account of given address. */
    eth_getBalance: (address: Address, block: BlockIdentifier) => Promise<BigNumber>;
    /** Returns the value from a storage position at a given address. */
    eth_getStorageAt: (address: Address, position: Quantity, block: BlockIdentifier) => Promise<Data>;
    /** Returns the number of transactions sent from an address. */
    eth_getTransactionCount: (address: Address, block: BlockIdentifier) => Promise<number>;
    /** Returns the number of transactions in a block from a block matching the given block hash. */
    eth_getBlockTransactionCountByHash: (blockHash: TxHash) => Promise<number>;
    /** Returns the number of transactions in a block matching the given block number. */
    eth_getBlockTransactionCountByNumber: (block: BlockIdentifier) => Promise<number>;
    /** Returns the number of uncles in a block from a block matching the given block hash. */
    eth_getUncleCountByBlockHash: (blockHash: TxHash) => Promise<number>;
    /** Returns the number of uncles in a block from a block matching the given block number. */
    eth_getUncleCountByBlockNumber: (block: BlockIdentifier) => Promise<number>;
    /** Returns code at a given address. */
    eth_getCode: (address: Address, block: BlockIdentifier) => Promise<Data>;
    /**
     * The sign method calculates an Ethereum specific signature with:
     *
     * sign(keccak256("Ethereum Signed Message:" + len(message) + message))).
     *
     * By adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature.
     * This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to
     * impersonate the victim.
     *
     * Note the address to sign with must be unlocked.
     *
     * @deprecated see https://github.com/ethereum/go-ethereum/pull/2940
     */
    eth_sign: (address: Address, message: Data) => Promise<Data>;
    /** Creates new message call transaction or a contract creation, if the data field contains code. */
    eth_sendTransaction: (options: TransactionOptions) => Promise<TxHash>;
    /** Creates new message call transaction or a contract creation for signed transactions. */
    eth_sendRawTransaction: (rawTransaction: Data) => Promise<TxHash>;
    /** Executes a new message call immediately without creating a transaction on the block chain. */
    eth_call: (options: TransactionCallOptions, block: BlockIdentifier) => Promise<Data>;
    /**
     * Generates and returns an estimate of how much gas is necessary to allow the transaction to complete.
     * The transaction will not be added to the blockchain. Note that the estimate may be significantly more
     * than the amount of gas actually used by the transaction, for a variety of reasons including EVM mechanics
     * and node performance.
     */
    eth_estimateGas: (data: Partial<TransactionCallOptions> & Partial<TransactionOptions>) => Promise<Quantity>;
    /** Returns information about a block by hash. */
    eth_getBlockByHash: (blockHash: TxHash, fullTransactionObjects: boolean) => Promise<BlockObject>;
    /** Returns information about a block by block number. */
    eth_getBlockByNumber: (block: BlockIdentifier, fullTransactionObjects: boolean) => Promise<BlockObject>;
    /** Returns the information about a transaction requested by transaction hash. */
    eth_getTransactionByHash: (hash: TxHash) => Promise<TransactionObject>;
    /** Returns information about a transaction by block hash and transaction index position. */
    eth_getTransactionByBlockHashAndIndex: (blockHash: TxHash, txIndex: Quantity) => Promise<TransactionObject>;
    /** Returns information about a transaction by block number and transaction index position. */
    eth_getTransactionByBlockNumberAndIndex: (block: BlockIdentifier, txIndex: Quantity) => Promise<TransactionObject>;
    /**
     * Returns the receipt of a transaction by transaction hash.
     * Note That the receipt is not available for pending transactions.
     */
    eth_getTransactionReceipt: (hash: TxHash) => Promise<TransactionReceipt>;
    /** Returns information about a uncle of a block by hash and uncle index position. */
    eth_getUncleByBlockHashAndIndex: (blockHash: TxHash, index: Quantity) => Promise<BlockObject>;
    /** Returns information about a uncle of a block by number and uncle index position. */
    eth_getUncleByBlockNumberAndIndex: (block: BlockIdentifier, index: Quantity) => Promise<BlockObject>;
    /**
     * Creates a filter object, based on filter options, to notify when the state changes (logs). To check if the state
     * has changed, call eth_getFilterChanges.
     *
     * A note on specifying topic filters:
     * Topics are order-dependent. A transaction with a log with topics [A, B] will be matched by the following topic
     * filters:
     *
     * [] "anything"
     * [A] "A in first position (and anything after)"
     * [null, B] "anything in first position AND B in second position (and anything after)"
     * [A, B] "A in first position AND B in second position (and anything after)"
     * [[A, B], [A, B]] "(A OR B) in first position AND (A OR B) in second position (and anything after)"
     */
    eth_newFilter: (options: FilterOptions) => Promise<Data>;
    /**
     * Creates a filter in the node, to notify when a new block arrives. To check if the state has changed, call
     * eth_getFilterChanges.
     */
    eth_newBlockFilter: () => Promise<Data>;
    /**
     * Creates a filter in the node, to notify when new pending transactions arrive. To check if the state has changed,
     * call eth_getFilterChanges.
     */
    eth_newPendingTransactionFilter: () => Promise<Data>;
    /**
     * Uninstalls a filter with given id. Should always be called when watch is no longer needed. Additonally Filters
     * timeout when they aren't requested with eth_getFilterChanges for a period of time.
     */
    eth_uninstallFilter: (filterId: Data) => Promise<boolean>;
    /**
     * Polling method for a filter, which returns an array of logs which occurred since last poll.
     */
    eth_getFilterChanges: (filterId: Data) => Promise<Array<TxHash> | Array<LogObject>>;
    /** Returns an array of all logs matching filter with given id. */
    eth_getFilterLogs: (filterId: Data) => Promise<Array<TxHash> | Array<LogObject>>;
    /** Returns an array of all logs matching a given filter object. */
    eth_getLogs: (options: FilterOptions) => Promise<Array<TxHash> | Array<LogObject>>;
    /**
     * Returns the hash of the current block, the seedHash, and the boundary condition to be met ("target").
     *
     * @returns Array with the following properties:
     * @alpha
     *
     * DATA, 32 Bytes - current block header pow-hash
     * DATA, 32 Bytes - the seed hash used for the DAG.
     * DATA, 32 Bytes - the boundary condition ("target"), 2^256 / difficulty.
     */
    eth_getWork: (blockHeaderHash: Data) => Promise<Array<TxHash>>;
    /** Used for submitting a proof-of-work solution. */
    eth_submitWork: (data: Data, powHash: TxHash, digest: TxHash) => Promise<boolean>;
    /** Used for submitting mining hashrate. */
    eth_submitHashrate: (hashRate: Data, id: Data) => Promise<boolean>;
    /** Sends a whisper message. */
    shh_post: (data: SHHPost) => Promise<boolean>;
    /** Returns the current whisper protocol version. */
    shh_version: () => Promise<string>;
    /** Creates new whisper identity in the client. */
    shh_newIdentity: () => Promise<Data>;
    /** Checks if the client hold the private keys for a given identity. */
    shh_hasIdentity: (identity: Data) => Promise<boolean>;
    shh_newGroup: () => Promise<Data>;
    shh_addToGroup: (group: Data) => Promise<boolean>;
    /** Creates filter to notify, when client receives whisper message matching the filter options. */
    shh_newFilter: (options: SHHFilterOptions) => Promise<Data>;
    /**
     * Uninstalls a filter with given id. Should always be called when watch is no longer needed.
     * Additonally Filters timeout when they aren't requested with shh_getFilterChanges for a period of time.
     */
    shh_uninstallFilter: (filterId: Data) => Promise<boolean>;
    /**
     * Polling method for whisper filters. Returns new messages since the last call of this method.
     *
     * Note calling the shh_getMessages method, will reset the buffer for this method, so that you won't receive duplicate
     * messages.
     */
    shh_getFilterChanges: (filterId: Data) => Promise<Array<SHHFilterMessage>>;
    /** Get all messages matching a filter. Unlike shh_getFilterChanges this returns all messages. */
    shh_getMessages: (filterId: Data) => Promise<Array<SHHFilterMessage>>;
    /**
     * Decrypts the key with the given address from the key store.
     *
     * Both passphrase and unlock duration are optional when using the JavaScript console. If the passphrase is not
     * supplied as an argument, the console will prompt for the passphrase interactively.
     *
     * The unencrypted key will be held in memory until the unlock duration expires. If the unlock duration defaults to
     * 300 seconds. An explicit duration of zero seconds unlocks the key until geth exits.
     *
     * The account can be used with eth_sign and eth_sendTransaction while it is unlocked.
     */
    personal_unlockAccount: (account: Address, passPhrase?: Data, seconds?: Quantity) => Promise<boolean>;
    /**
     * Generates a new private key and stores it in the key store directory. The key file is encrypted with the given
     * passphrase. Returns the address of the new account.
     *
     * At the geth console, newAccount will prompt for a passphrase when it is not supplied as the argument.
     */
    personal_newAccount: (passPhrase: Data) => Promise<Address>;
    /** Returns all the Ethereum account addresses of all keys in the key store. */
    personal_listAccounts: () => Promise<Array<Address>>;
    /** Removes the private key with given address from memory. The account can no longer be used to send transactions. */
    personal_lockAccount: (address: Address) => Promise<boolean>;
    /**
     * Imports the given unencrypted private key (hex string) into the key store, encrypting it with the passphrase.
     * Returns the address of the new account.
     */
    personal_importRawKey: (keydata: Data, passPhrase: Data) => Promise<Address>;
    /**
     * Imports the given unencrypted private key (hex string) into the key store, encrypting it with the passphrase.
     * Returns the address of the new account.
     */
    personal_sendTransaction: (txObject: TransactionOptions, passPhrase: Data) => Promise<TxHash>;
    /**
     * The sign method calculates an Ethereum specific signature with:
     *   sign(keccack256("Ethereum Signed Message:" + len(message) + message))).
     *
     * By adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature.
     * This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to
     * impersonate the victim.
     *
     * See ecRecover to verify the signature.
     */
    personal_sign: (data: Data, signerAddress: Address, passPhrase: Data) => Promise<Data>;
    /**
     * ecRecover returns the address associated with the private key that was used to calculate the signature in
     * personal_sign.
     */
    personal_ecRecover: (message: Data, signature: Data) => Promise<Address>;
    constructor(provider: any);
    /**
     * Should be used to asynchronously send request
     *
     * @param data - The RPC message to be sent
     */
    sendAsync(data: RPCSendableMessage): Promise<any>;
    /**
     * Should be used to set provider of request manager
     *
     * @param p - The provider
     */
    setProvider(p: any): void;
    /**
     * Waits until the transaction finishes. Returns if it was successfull.
     * Throws if the transaction fails or if it lacks any of the supplied events
     * @param txId - Transaction id to watch
     */
    getConfirmedTransaction(txId: string): Promise<FinishedTransactionAndReceipt>;
    /**
     * Wait until a transaction finishes by either being mined or failing
     * @param txId - Transaction id to watch
     * @param retriesOnEmpty - Number of retries when a transaction status returns empty
     */
    waitForCompletion(txId: string, retriesOnEmpty?: number): Promise<FinishedTransactionAndReceipt>;
    /**
     * Returns a transaction in any of the possible states.
     * @param txId - The transaction ID
     */
    getTransaction(txId: string): Promise<Transaction | null>;
    /**
     * Wait retryAttemps * TRANSACTION_FETCH_DELAY for a transaction status to be in the mempool
     * @param txId - Transaction id to watch
     * @param retryAttemps - Number of retries when a transaction status returns empty
     */
    isTxDropped(txId: string, _retryAttemps?: number): Promise<boolean>;
    /**
     * Get the transaction status and receipt
     * @param txId - Transaction id
     */
    getTransactionAndReceipt(txId: string): Promise<TransactionAndReceipt>;
    /**
     * Expects the result of getTransaction's geth command and returns true if the transaction is still pending.
     * It'll also check for a pending status prop against TRANSACTION_STATUS
     * @param tx - The transaction object
     */
    isPending(tx: TransactionAndReceipt): boolean;
    /**
     * Expects the result of getTransactionRecepeit's geth command and returns true if the transaction failed.
     * It'll also check for a failed status prop against TRANSACTION_STATUS
     * @param tx - The transaction object
     */
    isFailure(tx: TransactionAndReceipt): boolean;
}
export { RequestManager }
export default RequestManager;

/**
 * @public
 */
export declare type RevertedTransaction = TransactionObject & {
    type: TransactionType.reverted;
};

declare type RPCError = {
    jsonrpc: '2.0';
    id: number;
    error: string | number | boolean | symbol | object;
};

export declare type RPCMessage = {
    jsonrpc: '2.0';
    id: number;
    method: string;
    params: any[] | {
        [key: string]: any;
    };
};

declare type RPCResponse = RPCError | {
    jsonrpc: '2.0';
    id: number;
    result: any;
    error?: undefined | null;
};

export declare type RPCSendableMessage = {
    method: string;
    params: any[];
};

/**
 * @public
 */
export declare function sha3(value: string | number[] | ArrayBuffer | Uint8Array, options?: {
    encoding?: 'hex';
}): string;

export declare class SHHFilter extends AbstractFilter<SHHFilterMessage> {
    requestManager: RequestManager;
    options: SHHFilterOptions;
    constructor(requestManager: RequestManager, options: SHHFilterOptions);
    getMessages(): Promise<SHHFilterMessage[]>;
    protected getNewFilter(): Promise<string>;
    protected getChanges(): Promise<SHHFilterMessage[]>;
    protected uninstall(): Promise<boolean>;
}

/**
 * @public
 */
export declare type SHHFilterMessage = {
    /** The hash of the message. */
    hash: TxHash;
    /** The sender of the message, if a sender was specified. */
    from: Data;
    /** The receiver of the message, if a receiver was specified. */
    to: Data;
    /** Integer of the time in seconds when this message should expire (?). */
    expiry: Quantity;
    /** Integer of the time the message should float in the system in seconds (?). */
    ttl: Quantity;
    /** Integer of the unix timestamp when the message was sent. */
    sent: Quantity;
    /** Array of DATA topics the message contained. */
    topics: Array<Data>;
    /** The payload of the message. */
    payload: Data;
    /** Integer of the work this message required before it was send (?). */
    workProved: Quantity;
};

/**
 * @public
 */
export declare type SHHFilterOptions = {
    /**
     * (optional) Identity of the receiver. When present it will try to decrypt any incoming message if the client holds the private key to this identity.
     */
    to?: Data;
    /**
     * Array of DATA topics which the incoming message's topics should match. You can use the following combinations:
     * [A, B] = A && B
     * [A, [B, C]] = A && (B || C)
     * [null, A, B] = ANYTHING && A && B null works as a wildcard
     */
    topics: TopicFilter;
};

/**
 * @public
 */
export declare type SHHPost = {
    /** (optional) The identity of the sender. */
    from: Data;
    /** (optional) The identity of the receiver. When present whisper will encrypt the message so that only the receiver can decrypt it. */
    to: Data;
    /** Array of DATA topics, for the receiver to identify messages. */
    topics: Array<Data>;
    /** The payload of the message. */
    payload: Data;
    /** The integer of the priority in a rang from ... (?). */
    priority: Quantity;
    /** integer of the time to live in seconds. */
    ttl: Quantity;
};

/**
 * Check if input value is negative in twos complement
 */
export declare function signedIsNegative(value: BigNumber, bits: number): boolean;

/**
 * This prototype should be used to create event filters
 */
export declare class SolidityEvent {
    requestManager: RequestManager;
    address: string;
    _anonymous: boolean;
    _name: string;
    _params: AbiInput[];
    constructor(requestManager: RequestManager, json: AbiEvent, address: string);
    /**
     * Should be used to get filtered param types
     *
     * @param decide - True if returned typed should be indexed
     */
    types(indexed: boolean): AbiInput[];
    /**
     * Should be used to get event display name
     */
    displayName(): string;
    /**
     * Should be used to get event type name
     */
    typeName(): string;
    /**
     * Should be used to get event signature
     */
    signature(): string;
    /**
     * Should be used to encode indexed params and options to one final object
     *
     * @param {object} indexed
     * @param {object} options
     */
    encode(indexed?: Record<string, any>, options?: FilterOptions): FilterOptions;
    /**
     * Should be used to decode indexed params and options
     *
     * @param {object} data
     */
    decode(data: LogObject): LogObject & {
        event: string;
        address: string;
        args: Record<string, any>;
    };
    /**
     * Should be used to create new filter object from event
     *
     * @param {object} indexed
     * @param {object} options
     */
    execute(indexed: Record<string, any>, options?: FilterOptions): Promise<EthFilter<LogObject>>;
    /**
     * Should be used to attach event to contract object
     *
     * @param {Contract}
     */
    attachToContract(contract: Contract): void;
}

/**
 * This prototype should be used to call/sendTransaction to solidity functions
 */
export declare class SolidityFunction {
    json: AbiFunction;
    _inputTypes: AbiInput[];
    _outputTypes: AbiOutput[];
    _constant: boolean;
    _name: string;
    _payable: boolean;
    needsToBeTransaction: boolean;
    constructor(json: AbiFunction);
    extractDefaultBlock(args: any[]): string;
    /**
     * Should be called to check if the number of arguments is correct
     *
     * @param arguments - An array of arguments
     */
    validateArgs(args: any[]): void;
    /**
     * Should be used to create payload from arguments
     *
     * @param solidity - function params
     * @param optional - payload options
     */
    toPayload(args: any[]): any;
    /**
     * Should be used to get function signature
     */
    signature(): string;
    unpackOutput(output: string): any;
    /**
     * Calls a contract function or to sendTransaction to solidity function
     *
     * @param requestManager - The RequestManager instance
     */
    execute(requestManager: RequestManager, address: string, ...args: any[]): Promise<any>;
    /**
     * Should be used to estimateGas of solidity function
     */
    estimateGas(requestManager: RequestManager, address: string, ...args: any[]): Promise<Quantity>;
    /**
     * Should be used to get function display name
     */
    displayName(): string;
    /**
     * Should be used to get function type name
     */
    typeName(): string;
    /**
     * Should be called to attach function to contract
     *
     * @param contract - The contract instance
     */
    attachToContract(contract: Contract): void;
}

/**
 * @public
 */
export declare type StateMutabilityType = 'pure' | 'view' | 'nonpayable' | 'payable';

/**
 * Converts a string into a Uint8Array encoded with UTF-8
 * @public
 */
export declare function stringToUtf8Bytes(str: string): Uint8Array;

/**
 * @public
 */
export declare type Syncing = {
    startingBlock: Quantity;
    currentBlock: Quantity;
    highestBlock: Quantity;
};

/**
 * @public
 */
export declare type Tag = 'latest' | 'earliest' | 'pending';

/**
 * @public
 * Transforms given string to valid 20 bytes-length addres with 0x prefix
 */
export declare function toAddress(address: string): string;

/**
 * @public
 * Ensures the result will be an array
 */
export declare function toArray(value: any): any[];

/**
 * @public
 * Should be called to get ascii from it's hex representation
 */
export declare function toAscii(hex: string): string;

/**
 * Should be called to create batch payload object
 *
 * @param messages - An array of objects with method (required) and params (optional) fields
 */
export declare function toBatchPayload(messages: RPCSendableMessage[]): {
    jsonrpc: string;
    id: number;
    method: string;
    params: any[];
}[];

/**
 * @public
 * Takes an input and transforms it into an bignumber
 */
export declare function toBigNumber(_num: BigNumber.Value): BigNumber;

/**
 * @public
 * Converts value to it's boolean representation (x != 0)
 */
export declare function toBoolean(value: BigNumber.Value | boolean): boolean;

/**
 * @public
 * Makes a checksum address
 */
export declare function toChecksumAddress(_address: string): string;

/**
 * @public
 * Converts value to it's hex  representation in string
 */
export declare function toData(val: BigNumber.Value): string;

/**
 * @public
 * Converts value to it's decimal representation in string
 */
export declare function toDecimal(value: BigNumber.Value): number;

/**
 * @public
 * Auto converts any given value into it's hex representation.
 *
 * And even stringifys objects before.
 */
export declare function toHex(val: BigNumber.Value | boolean | Uint8Array): string;

/**
 * Should be called to valid json create payload object
 */
export declare function toJsonRpcRequest(method: string, params: any[]): {
    jsonrpc: string;
    id: number;
    method: string;
    params: any[];
};

/**
 * @public
 * Converts value to it's decimal representation in string
 */
export declare function toNullDecimal(value: BigNumber.Value): number;

export declare type TopicFilter = Array<Data | null | TopicFilter>;

/**
 * @public
 * Converts value to string
 */
declare function toString_2(value: BigNumber.Value): string;
export { toString_2 as toString }

/**
 * @public
 * Converts a UTF8 string to it's hex representation as a 0x string.
 * If the argument is already a 0xHEX prefixed string, the conversion is skipped.
 */
export declare function toStringData(val: BigNumber.Value): string;

/**
 * @public
 * Takes and input transforms it into bignumber and if it is negative value, into two's complement
 */
export declare function toTwosComplement(num: BigNumber.Value, bits?: number): BigNumber;

/**
 * @public
 * Takes a number of a unit and converts it to wei.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 */
export declare function toWei(num: number | string, unit: Unit): string | BigNumber;

/**
 * @public
 */
export declare type Transaction = DroppedTransaction | ReplacedTransaction | QueuedTransaction | PendingTransaction | ConfirmedTransaction | RevertedTransaction;

/**
 * @public
 */
export declare type TransactionAndReceipt = TransactionObject & {
    receipt: TransactionReceipt;
};

/**
 * @public
 */
export declare type TransactionCallOptions = {
    /**
     * The address the transaction is sent from.
     */
    from?: Address;
    /**
     * The address the transaction is directed to.
     */
    to: Address;
    /**
     * Integer of the gas provided for the transaction execution. eth_call consumes zero gas, but this parameter
     * may be needed by some executions.
     *
     * Default: 90000
     */
    gas?: BigNumber.Value;
    /**
     *  Integer of the gasPrice used for each paid gas
     */
    gasPrice?: BigNumber.Value;
    /**
     * Integer of the value sent with this transaction
     */
    value?: BigNumber.Value;
    /**
     * The compiled code of a contract OR the hash of the invoked method signature and encoded parameters.
     * For details see Ethereum Contract ABI
     */
    data?: string;
};

/**
 * @public
 */
export declare type TransactionObject = {
    /** hash of the transaction. */
    hash: TxHash;
    /** the number of transactions made by the sender prior to this one. */
    nonce: number;
    /** hash of the block where this transaction was in. null when its pending. */
    blockHash: TxHash;
    /** block number where this transaction was in. null when its pending. */
    blockNumber: number;
    /** integer of the transactions index position in the block. null when its pending. */
    transactionIndex: number;
    /** address of the sender. */
    from: Address;
    /** address of the receiver. null when its a contract creation transaction. */
    to: Address | null;
    /** value transferred in Wei. */
    value: BigNumber;
    /** gas price provided by the sender in Wei. */
    gasPrice: BigNumber;
    /** gas provided by the sender. */
    gas: Quantity;
    /** the data send along with the transaction. */
    input: Data;
    v?: Data;
    r?: Data;
    s?: Data;
};

/**
 * @public
 */
export declare type TransactionOptions = {
    /**
     * The address the transaction is sent from.
     */
    from: Address;
    /**
     * The address the transaction is directed to.
     */
    to: Address;
    /**
     * Integer of the gas provided for the transaction execution. eth_call consumes zero gas, but this parameter
     * may be needed by some executions.
     *
     * Default: 90000
     */
    gas?: BigNumber.Value;
    /**
     *  Integer of the gasPrice used for each paid gas
     */
    gasPrice?: BigNumber.Value;
    /**
     * Integer of the value sent with this transaction
     */
    value?: BigNumber.Value;
    /**
     * The compiled code of a contract OR the hash of the invoked method signature and encoded parameters.
     * For details see Ethereum Contract ABI
     */
    data: string;
    /** Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce. */
    nonce?: BigNumber.Value;
};

/**
 * @public
 */
export declare type TransactionReceipt = {
    /** hash of the transaction. */
    transactionHash: TxHash;
    /** integer of the transactions index position in the block. */
    transactionIndex: Quantity;
    /** hash of the block where this transaction was in. */
    blockHash: TxHash;
    /** block number where this transaction was in. */
    blockNumber: Quantity;
    /** The total amount of gas used when this transaction was executed in the block. */
    cumulativeGasUsed: Quantity;
    /** The amount of gas used by this specific transaction alone. */
    gasUsed: Quantity;
    /**  The contract address created, if the transaction was a contract creation, otherwise null. */
    contractAddress: Address;
    /** Array of log objects, which this transaction generated. */
    logs: Array<LogObject>;
    /**  256 Bytes - Bloom filter for light clients to quickly retrieve related logs. */
    logsBloom: Data;
    /**  post-transaction stateroot (pre Byzantium) */
    root?: TxHash;
    /** either 1 (success) or 0 (failure) */
    status?: Quantity;
};

/**
 * @public
 */
export declare enum TransactionStatus {
    pending = "pending",
    confirmed = "confirmed",
    failed = "failed"
}

/**
 * @public
 */
export declare enum TransactionType {
    queued = "queued",
    dropped = "dropped",
    replaced = "replaced",
    pending = "pending",
    reverted = "reverted",
    confirmed = "confirmed"
}

/**
 * @public
 * Should be used to create full function/event name from json abi
 */
export declare function transformToFullName(json: AbiItem): string;

/**
 * Hex string of 32 bytes
 * @public
 */
export declare type TxHash = string;

export declare type Unit = keyof typeof unitMap;

declare const unitMap: {
    noether: string;
    wei: string;
    kwei: string;
    Kwei: string;
    babbage: string;
    femtoether: string;
    mwei: string;
    Mwei: string;
    lovelace: string;
    picoether: string;
    gwei: string;
    Gwei: string;
    shannon: string;
    nanoether: string;
    nano: string;
    szabo: string;
    microether: string;
    micro: string;
    finney: string;
    milliether: string;
    milli: string;
    ether: string;
    kether: string;
    grand: string;
    mether: string;
    gether: string;
    tether: string;
};

/**
 * @public
 */
export declare class WebSocketProvider<T extends IWebSocket> {
    url: string;
    options: WebSocketProviderOptions;
    isDisposed: boolean;
    connection: IFuture<T>;
    debug: boolean;
    private lastChunk;
    private lastChunkTimeout;
    constructor(url: string, options?: WebSocketProviderOptions);
    dispose(): void;
    send(): void;
    sendAsync(payload: RPCMessage | RPCMessage[], callback: Callback): void;
    /**
     * Will parse the response and make an array out of it.
     */
    private parseResponse;
    private processMessage;
    /**
     * Timeout all requests when the end/error event is fired
     */
    private timeout;
    private connect;
}

export declare type WebSocketProviderOptions = {
    /**
     * WebSocketConstructor, used in Node.js where WebSocket is not globally available
     */
    WebSocketConstructor?: any;
    timeout?: number;
    protocol?: string;
};

export { }
