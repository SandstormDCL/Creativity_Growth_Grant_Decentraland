"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PBMeshCollider_SphereMesh = exports.PBMeshCollider_PlaneMesh = exports.PBMeshCollider_CylinderMesh = exports.PBMeshCollider_BoxMesh = exports.PBMeshCollider = exports.ColliderLayer = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const protobufPackageSarasa = "decentraland.sdk.components";
/** ColliderLayer determines the kind of collision to detect, in OR-able bit flag form. */
/**
 * @public
 */
var ColliderLayer;
(function (ColliderLayer) {
    /** CL_NONE - no collisions */
    ColliderLayer[ColliderLayer["CL_NONE"] = 0] = "CL_NONE";
    /** CL_POINTER - collisions with the player's pointer ray (e.g. mouse cursor hovering) */
    ColliderLayer[ColliderLayer["CL_POINTER"] = 1] = "CL_POINTER";
    /** CL_PHYSICS - collision affecting your player's physics i.e. walls, floor, moving platfroms */
    ColliderLayer[ColliderLayer["CL_PHYSICS"] = 2] = "CL_PHYSICS";
    ColliderLayer[ColliderLayer["CL_RESERVED1"] = 4] = "CL_RESERVED1";
    ColliderLayer[ColliderLayer["CL_RESERVED2"] = 8] = "CL_RESERVED2";
    ColliderLayer[ColliderLayer["CL_RESERVED3"] = 16] = "CL_RESERVED3";
    ColliderLayer[ColliderLayer["CL_RESERVED4"] = 32] = "CL_RESERVED4";
    ColliderLayer[ColliderLayer["CL_RESERVED5"] = 64] = "CL_RESERVED5";
    ColliderLayer[ColliderLayer["CL_RESERVED6"] = 128] = "CL_RESERVED6";
    ColliderLayer[ColliderLayer["CL_CUSTOM1"] = 256] = "CL_CUSTOM1";
    ColliderLayer[ColliderLayer["CL_CUSTOM2"] = 512] = "CL_CUSTOM2";
    ColliderLayer[ColliderLayer["CL_CUSTOM3"] = 1024] = "CL_CUSTOM3";
    ColliderLayer[ColliderLayer["CL_CUSTOM4"] = 2048] = "CL_CUSTOM4";
    ColliderLayer[ColliderLayer["CL_CUSTOM5"] = 4096] = "CL_CUSTOM5";
    ColliderLayer[ColliderLayer["CL_CUSTOM6"] = 8192] = "CL_CUSTOM6";
    ColliderLayer[ColliderLayer["CL_CUSTOM7"] = 16384] = "CL_CUSTOM7";
    ColliderLayer[ColliderLayer["CL_CUSTOM8"] = 32768] = "CL_CUSTOM8";
})(ColliderLayer = exports.ColliderLayer || (exports.ColliderLayer = {}));
function createBasePBMeshCollider() {
    return { collisionMask: undefined, mesh: undefined };
}
/**
 * @public
 */
var PBMeshCollider;
(function (PBMeshCollider) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.collisionMask !== undefined) {
            writer.uint32(8).uint32(message.collisionMask);
        }
        switch (message.mesh?.$case) {
            case "box":
                PBMeshCollider_BoxMesh.encode(message.mesh.box, writer.uint32(18).fork()).ldelim();
                break;
            case "sphere":
                PBMeshCollider_SphereMesh.encode(message.mesh.sphere, writer.uint32(26).fork()).ldelim();
                break;
            case "cylinder":
                PBMeshCollider_CylinderMesh.encode(message.mesh.cylinder, writer.uint32(34).fork()).ldelim();
                break;
            case "plane":
                PBMeshCollider_PlaneMesh.encode(message.mesh.plane, writer.uint32(42).fork()).ldelim();
                break;
        }
        return writer;
    }
    PBMeshCollider.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePBMeshCollider();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.collisionMask = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.mesh = { $case: "box", box: PBMeshCollider_BoxMesh.decode(reader, reader.uint32()) };
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.mesh = { $case: "sphere", sphere: PBMeshCollider_SphereMesh.decode(reader, reader.uint32()) };
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.mesh = { $case: "cylinder", cylinder: PBMeshCollider_CylinderMesh.decode(reader, reader.uint32()) };
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.mesh = { $case: "plane", plane: PBMeshCollider_PlaneMesh.decode(reader, reader.uint32()) };
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PBMeshCollider.decode = decode;
})(PBMeshCollider = exports.PBMeshCollider || (exports.PBMeshCollider = {}));
function createBasePBMeshCollider_BoxMesh() {
    return {};
}
/**
 * @public
 */
var PBMeshCollider_BoxMesh;
(function (PBMeshCollider_BoxMesh) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    PBMeshCollider_BoxMesh.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePBMeshCollider_BoxMesh();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PBMeshCollider_BoxMesh.decode = decode;
})(PBMeshCollider_BoxMesh = exports.PBMeshCollider_BoxMesh || (exports.PBMeshCollider_BoxMesh = {}));
function createBasePBMeshCollider_CylinderMesh() {
    return { radiusTop: undefined, radiusBottom: undefined };
}
/**
 * @public
 */
var PBMeshCollider_CylinderMesh;
(function (PBMeshCollider_CylinderMesh) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.radiusTop !== undefined) {
            writer.uint32(13).float(message.radiusTop);
        }
        if (message.radiusBottom !== undefined) {
            writer.uint32(21).float(message.radiusBottom);
        }
        return writer;
    }
    PBMeshCollider_CylinderMesh.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePBMeshCollider_CylinderMesh();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 13) {
                        break;
                    }
                    message.radiusTop = reader.float();
                    continue;
                case 2:
                    if (tag !== 21) {
                        break;
                    }
                    message.radiusBottom = reader.float();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PBMeshCollider_CylinderMesh.decode = decode;
})(PBMeshCollider_CylinderMesh = exports.PBMeshCollider_CylinderMesh || (exports.PBMeshCollider_CylinderMesh = {}));
function createBasePBMeshCollider_PlaneMesh() {
    return {};
}
/**
 * @public
 */
var PBMeshCollider_PlaneMesh;
(function (PBMeshCollider_PlaneMesh) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    PBMeshCollider_PlaneMesh.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePBMeshCollider_PlaneMesh();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PBMeshCollider_PlaneMesh.decode = decode;
})(PBMeshCollider_PlaneMesh = exports.PBMeshCollider_PlaneMesh || (exports.PBMeshCollider_PlaneMesh = {}));
function createBasePBMeshCollider_SphereMesh() {
    return {};
}
/**
 * @public
 */
var PBMeshCollider_SphereMesh;
(function (PBMeshCollider_SphereMesh) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    PBMeshCollider_SphereMesh.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePBMeshCollider_SphereMesh();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PBMeshCollider_SphereMesh.decode = decode;
})(PBMeshCollider_SphereMesh = exports.PBMeshCollider_SphereMesh || (exports.PBMeshCollider_SphereMesh = {}));
