import _m0 from "protobufjs/minimal";
/** ColliderLayer determines the kind of collision to detect, in OR-able bit flag form. */
/**
 * @public
 */
export declare const enum ColliderLayer {
    /** CL_NONE - no collisions */
    CL_NONE = 0,
    /** CL_POINTER - collisions with the player's pointer ray (e.g. mouse cursor hovering) */
    CL_POINTER = 1,
    /** CL_PHYSICS - collision affecting your player's physics i.e. walls, floor, moving platfroms */
    CL_PHYSICS = 2,
    CL_RESERVED1 = 4,
    CL_RESERVED2 = 8,
    CL_RESERVED3 = 16,
    CL_RESERVED4 = 32,
    CL_RESERVED5 = 64,
    CL_RESERVED6 = 128,
    CL_CUSTOM1 = 256,
    CL_CUSTOM2 = 512,
    CL_CUSTOM3 = 1024,
    CL_CUSTOM4 = 2048,
    CL_CUSTOM5 = 4096,
    CL_CUSTOM6 = 8192,
    CL_CUSTOM7 = 16384,
    CL_CUSTOM8 = 32768
}
/**
 * The MeshCollider component provides basic collision detection between Entities and Avatars. It
 * can behave like a cube, a plane, a sphere or a cylinder.
 *
 * The Entity's Transform affects the MeshCollider, scaling it and rotating it appropriately. If
 * the Transform for the collision mesh must be different than the Transform for rendering the Entity,
 * two different Entities must be used.
 *
 * More complex shapes require the use of a `GltfContainer` component.
 */
/**
 * @public
 */
export interface PBMeshCollider {
    /** enabled ColliderLayers (default CL_POINTER | CL_PHYSICS) */
    collisionMask?: number | undefined;
    mesh?: {
        $case: "box";
        box: PBMeshCollider_BoxMesh;
    } | {
        $case: "sphere";
        sphere: PBMeshCollider_SphereMesh;
    } | {
        $case: "cylinder";
        cylinder: PBMeshCollider_CylinderMesh;
    } | {
        $case: "plane";
        plane: PBMeshCollider_PlaneMesh;
    } | undefined;
}
/** BoxMesh is a prism shape that contains the Entity. */
/**
 * @public
 */
export interface PBMeshCollider_BoxMesh {
}
/** CylinderMesh is a truncated cone shape that contains the Entity. */
/**
 * @public
 */
export interface PBMeshCollider_CylinderMesh {
    /** (default 0.5) */
    radiusTop?: number | undefined;
    /** (default 0.5) */
    radiusBottom?: number | undefined;
}
/** PlaneMesh is a 2D rectangle described by the Entity's Transform. */
/**
 * @public
 */
export interface PBMeshCollider_PlaneMesh {
}
/** SphereMesh is a sphere shape that contains the Entity. */
/**
 * @public
 */
export interface PBMeshCollider_SphereMesh {
}
/**
 * @public
 */
export declare namespace PBMeshCollider {
    function encode(message: PBMeshCollider, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider;
}
/**
 * @public
 */
export declare namespace PBMeshCollider_BoxMesh {
    function encode(_: PBMeshCollider_BoxMesh, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_BoxMesh;
}
/**
 * @public
 */
export declare namespace PBMeshCollider_CylinderMesh {
    function encode(message: PBMeshCollider_CylinderMesh, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_CylinderMesh;
}
/**
 * @public
 */
export declare namespace PBMeshCollider_PlaneMesh {
    function encode(_: PBMeshCollider_PlaneMesh, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_PlaneMesh;
}
/**
 * @public
 */
export declare namespace PBMeshCollider_SphereMesh {
    function encode(_: PBMeshCollider_SphereMesh, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_SphereMesh;
}
