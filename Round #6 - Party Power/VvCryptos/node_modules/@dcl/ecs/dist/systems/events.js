import * as components from '../components';
import { EntityState } from '../engine/entity';
import { checkNotThenable } from '../runtime/invariant';
export const getDefaultOpts = (opts = {}) => ({
    button: 3 /* InputAction.IA_ANY */,
    ...opts
});
/**
 * @public
 * ___DO NOT USE___ use pointerEventsSystem instead
 */
export function createPointerEventsSystem(engine, inputSystem) {
    const PointerEvents = components.PointerEvents(engine);
    let EventType;
    (function (EventType) {
        EventType[EventType["Click"] = 0] = "Click";
        EventType[EventType["Down"] = 1] = "Down";
        EventType[EventType["Up"] = 2] = "Up";
    })(EventType || (EventType = {}));
    const eventsMap = new Map();
    function getEvent(entity) {
        return eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity);
    }
    function setPointerEvent(entity, type, opts) {
        const pointerEvent = PointerEvents.getMutableOrNull(entity) || PointerEvents.create(entity);
        pointerEvent.pointerEvents.push({
            eventType: type,
            eventInfo: {
                button: opts.button,
                showFeedback: opts.showFeedback,
                showHighlight: opts.showHighlight,
                hoverText: opts.hoverText,
                maxDistance: opts.maxDistance
            }
        });
    }
    function removePointerEvent(entity, type, button) {
        const pointerEvent = PointerEvents.getMutableOrNull(entity);
        if (!pointerEvent)
            return;
        pointerEvent.pointerEvents = pointerEvent.pointerEvents.filter((pointer) => !(pointer.eventInfo?.button === button && pointer.eventType === type));
    }
    function getPointerEvent(eventType) {
        if (eventType === EventType.Up) {
            return 0 /* PointerEventType.PET_UP */;
        }
        return 1 /* PointerEventType.PET_DOWN */;
    }
    function removeEvent(entity, type) {
        const event = getEvent(entity);
        const pointerEvent = event.get(type);
        if (pointerEvent?.opts.hoverText) {
            removePointerEvent(entity, getPointerEvent(type), pointerEvent.opts.button);
        }
        event.delete(type);
    }
    engine.addSystem(function EventSystem() {
        for (const [entity, event] of eventsMap) {
            if (engine.getEntityState(entity) === EntityState.Removed) {
                eventsMap.delete(entity);
                continue;
            }
            for (const [eventType, { cb, opts }] of event) {
                if (eventType === EventType.Click) {
                    const command = inputSystem.getClick(opts.button, entity);
                    if (command)
                        checkNotThenable(cb(command.up), 'Click event returned a thenable. Only synchronous functions are allowed');
                }
                if (eventType === EventType.Down || eventType === EventType.Up) {
                    const command = inputSystem.getInputCommand(opts.button, getPointerEvent(eventType), entity);
                    if (command) {
                        checkNotThenable(cb(command), 'Event handler returned a thenable. Only synchronous functions are allowed');
                    }
                }
            }
        }
    });
    const onPointerDown = (...args) => {
        const [data, cb, maybeOpts] = args;
        if (typeof data === 'number') {
            return onPointerDown({ entity: data, opts: maybeOpts ?? {} }, cb);
        }
        const { entity, opts } = data;
        const options = getDefaultOpts(opts);
        removeEvent(entity, EventType.Down);
        getEvent(entity).set(EventType.Down, { cb, opts: options });
        setPointerEvent(entity, 1 /* PointerEventType.PET_DOWN */, options);
    };
    const onPointerUp = (...args) => {
        const [data, cb, maybeOpts] = args;
        if (typeof data === 'number') {
            return onPointerUp({ entity: data, opts: maybeOpts ?? {} }, cb);
        }
        const { entity, opts } = data;
        const options = getDefaultOpts(opts);
        removeEvent(entity, EventType.Up);
        getEvent(entity).set(EventType.Up, { cb, opts: options });
        setPointerEvent(entity, 0 /* PointerEventType.PET_UP */, options);
    };
    return {
        removeOnClick(entity) {
            removeEvent(entity, EventType.Click);
        },
        removeOnPointerDown(entity) {
            removeEvent(entity, EventType.Down);
        },
        removeOnPointerUp(entity) {
            removeEvent(entity, EventType.Up);
        },
        onClick(value, cb) {
            const { entity } = value;
            const options = getDefaultOpts(value.opts);
            // Clear previous event with over feedback included
            removeEvent(entity, EventType.Click);
            // Set new event
            getEvent(entity).set(EventType.Click, { cb, opts: options });
            setPointerEvent(entity, 1 /* PointerEventType.PET_DOWN */, options);
        },
        onPointerDown,
        onPointerUp
    };
}
