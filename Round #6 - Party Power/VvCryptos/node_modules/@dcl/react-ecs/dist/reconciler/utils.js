import { isListener } from '../components';
export function propsChanged(component, prevProps, nextProps) {
    if (prevProps && !nextProps) {
        return { type: 'delete', component };
    }
    if (!nextProps) {
        return;
    }
    if (!prevProps && nextProps) {
        return { type: 'add', props: nextProps, component };
    }
    if (isListener(component)) {
        if (!isEqual(prevProps, nextProps)) {
            return { type: 'put', component, props: nextProps };
        }
    }
    const changes = {};
    for (const k in prevProps) {
        const propKey = k;
        if (!isEqual(prevProps[propKey], nextProps[propKey])) {
            changes[propKey] = nextProps[propKey];
        }
    }
    if (!Object.keys(changes).length) {
        return;
    }
    return { type: 'put', props: changes, component };
}
// as any HACK so every time we add a new component, we must add also the component here.
const entityComponent = {
    uiText: undefined,
    uiBackground: undefined,
    uiTransform: undefined,
    onMouseDown: undefined,
    onMouseUp: undefined,
    uiInput: undefined,
    uiDropdown: undefined
};
export const componentKeys = Object.keys(entityComponent);
export function isEqual(val1, val2) {
    if (!val1 && !val2) {
        return true;
    }
    if (!val1 || !val2) {
        return val1 === val2;
    }
    if (val1 === val2) {
        return true;
    }
    if (typeof val1 !== typeof val2) {
        return false;
    }
    if (typeof val1 !== 'object') {
        return val1 === val2;
    }
    if (Array.isArray(val1) && Array.isArray(val2)) {
        if (val1.length !== val2.length) {
            return false;
        }
    }
    if (Object.keys(val1).length !== Object.keys(val2).length) {
        return false;
    }
    if (JSON.stringify(val1) === JSON.stringify(val2)) {
        return true;
    }
    for (const key in val1) {
        if (!isEqual(val1[key], val2[key])) {
            return false;
        }
    }
    /* istanbul ignore next */
    return true;
}
export const isNotUndefined = (val) => {
    return !!val;
};
export const noopConfig = {
    supportsMutation: true,
    supportsPersistence: false,
    noTimeout: -1,
    isPrimaryRenderer: true,
    supportsHydration: false,
    /* istanbul ignore next */
    insertInContainerBefore(_container, _child, _beforeChild) { },
    detachDeletedInstance(_node) { },
    /* istanbul ignore next */
    hideInstance(_instance) { },
    /* istanbul ignore next */
    hideTextInstance(_textInstance) { },
    /* istanbul ignore next */
    unhideInstance(_instance, _props) { },
    /* istanbul ignore next */
    unhideTextInstance(_textInstance, _text) { },
    /* istanbul ignore next */
    clearContainer(_container) { },
    /* istanbul ignore next */
    getCurrentEventPriority() {
        /* istanbul ignore next */
        return 0;
    },
    /* istanbul ignore next */
    getInstanceFromNode(_node) {
        /* istanbul ignore next */
        return null;
    },
    /* istanbul ignore next */
    beforeActiveInstanceBlur() { },
    /* istanbul ignore next */
    afterActiveInstanceBlur() { },
    /* istanbul ignore next */
    prepareScopeUpdate() { },
    /* istanbul ignore next */
    getInstanceFromScope() {
        /* istanbul ignore next */
        return null;
    },
    /* istanbul ignore next */
    commitMount(_instance, _type, _props, _internalInstanceHandle) { },
    /* istanbul ignore next */
    resetTextContent(_instance) { },
    /* istanbul ignore next */
    commitTextUpdate(_textInstance, _oldText, _newText) { },
    prepareForCommit(_containerInfo) {
        return null;
    },
    resetAfterCommit(_containerInfo) { },
    /* istanbul ignore next */
    preparePortalMount(_containerInfo) { },
    /* istanbul ignore next */
    createTextInstance(_text, _rootContainer, _hostContext, _internalHandle) {
        /* istanbul ignore next */
        return {};
    },
    /* istanbul ignore next */
    scheduleTimeout(_fn, _delay) { },
    /* istanbul ignore next */
    cancelTimeout(_id) { },
    shouldSetTextContent(_type, _props) {
        return false;
    },
    getRootHostContext(_rootContainer) {
        return null;
    },
    getChildHostContext(_parentHostContext, _type, _rootContainer) {
        /* istanbul ignore next */
        return null;
    },
    /* istanbul ignore next */
    getPublicInstance(instance) {
        /* istanbul ignore next */
        return instance;
    },
    finalizeInitialChildren(_instance, _type, _props, _rootContainer, _hostContext) {
        return false;
    }
};
