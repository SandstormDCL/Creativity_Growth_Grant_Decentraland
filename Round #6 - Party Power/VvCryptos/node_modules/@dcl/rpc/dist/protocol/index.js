"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamMessage = exports.Response = exports.RemoteError = exports.Request = exports.ModuleProcedure = exports.DestroyPort = exports.RequestModuleResponse = exports.RequestModule = exports.CreatePortResponse = exports.CreatePort = exports.RpcMessageHeader = exports.rpcMessageTypesToJSON = exports.rpcMessageTypesFromJSON = exports.RpcMessageTypes = exports.protobufPackage = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "";
/** THIS FILE IS AUTOGENERATED */
var RpcMessageTypes;
(function (RpcMessageTypes) {
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_EMPTY"] = 0] = "RpcMessageTypes_EMPTY";
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_REQUEST"] = 1] = "RpcMessageTypes_REQUEST";
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_RESPONSE"] = 2] = "RpcMessageTypes_RESPONSE";
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_STREAM_MESSAGE"] = 3] = "RpcMessageTypes_STREAM_MESSAGE";
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_STREAM_ACK"] = 4] = "RpcMessageTypes_STREAM_ACK";
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_CREATE_PORT"] = 5] = "RpcMessageTypes_CREATE_PORT";
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_CREATE_PORT_RESPONSE"] = 6] = "RpcMessageTypes_CREATE_PORT_RESPONSE";
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_REQUEST_MODULE"] = 7] = "RpcMessageTypes_REQUEST_MODULE";
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_REQUEST_MODULE_RESPONSE"] = 8] = "RpcMessageTypes_REQUEST_MODULE_RESPONSE";
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_REMOTE_ERROR_RESPONSE"] = 9] = "RpcMessageTypes_REMOTE_ERROR_RESPONSE";
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_DESTROY_PORT"] = 10] = "RpcMessageTypes_DESTROY_PORT";
    RpcMessageTypes[RpcMessageTypes["RpcMessageTypes_SERVER_READY"] = 11] = "RpcMessageTypes_SERVER_READY";
    RpcMessageTypes[RpcMessageTypes["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RpcMessageTypes = exports.RpcMessageTypes || (exports.RpcMessageTypes = {}));
function rpcMessageTypesFromJSON(object) {
    switch (object) {
        case 0:
        case "RpcMessageTypes_EMPTY":
            return RpcMessageTypes.RpcMessageTypes_EMPTY;
        case 1:
        case "RpcMessageTypes_REQUEST":
            return RpcMessageTypes.RpcMessageTypes_REQUEST;
        case 2:
        case "RpcMessageTypes_RESPONSE":
            return RpcMessageTypes.RpcMessageTypes_RESPONSE;
        case 3:
        case "RpcMessageTypes_STREAM_MESSAGE":
            return RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE;
        case 4:
        case "RpcMessageTypes_STREAM_ACK":
            return RpcMessageTypes.RpcMessageTypes_STREAM_ACK;
        case 5:
        case "RpcMessageTypes_CREATE_PORT":
            return RpcMessageTypes.RpcMessageTypes_CREATE_PORT;
        case 6:
        case "RpcMessageTypes_CREATE_PORT_RESPONSE":
            return RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE;
        case 7:
        case "RpcMessageTypes_REQUEST_MODULE":
            return RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE;
        case 8:
        case "RpcMessageTypes_REQUEST_MODULE_RESPONSE":
            return RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE;
        case 9:
        case "RpcMessageTypes_REMOTE_ERROR_RESPONSE":
            return RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE;
        case 10:
        case "RpcMessageTypes_DESTROY_PORT":
            return RpcMessageTypes.RpcMessageTypes_DESTROY_PORT;
        case 11:
        case "RpcMessageTypes_SERVER_READY":
            return RpcMessageTypes.RpcMessageTypes_SERVER_READY;
        case -1:
        case "UNRECOGNIZED":
        default:
            return RpcMessageTypes.UNRECOGNIZED;
    }
}
exports.rpcMessageTypesFromJSON = rpcMessageTypesFromJSON;
function rpcMessageTypesToJSON(object) {
    switch (object) {
        case RpcMessageTypes.RpcMessageTypes_EMPTY:
            return "RpcMessageTypes_EMPTY";
        case RpcMessageTypes.RpcMessageTypes_REQUEST:
            return "RpcMessageTypes_REQUEST";
        case RpcMessageTypes.RpcMessageTypes_RESPONSE:
            return "RpcMessageTypes_RESPONSE";
        case RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE:
            return "RpcMessageTypes_STREAM_MESSAGE";
        case RpcMessageTypes.RpcMessageTypes_STREAM_ACK:
            return "RpcMessageTypes_STREAM_ACK";
        case RpcMessageTypes.RpcMessageTypes_CREATE_PORT:
            return "RpcMessageTypes_CREATE_PORT";
        case RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE:
            return "RpcMessageTypes_CREATE_PORT_RESPONSE";
        case RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE:
            return "RpcMessageTypes_REQUEST_MODULE";
        case RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE:
            return "RpcMessageTypes_REQUEST_MODULE_RESPONSE";
        case RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE:
            return "RpcMessageTypes_REMOTE_ERROR_RESPONSE";
        case RpcMessageTypes.RpcMessageTypes_DESTROY_PORT:
            return "RpcMessageTypes_DESTROY_PORT";
        case RpcMessageTypes.RpcMessageTypes_SERVER_READY:
            return "RpcMessageTypes_SERVER_READY";
        case RpcMessageTypes.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.rpcMessageTypesToJSON = rpcMessageTypesToJSON;
function createBaseRpcMessageHeader() {
    return { messageIdentifier: 0 };
}
exports.RpcMessageHeader = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.messageIdentifier !== 0) {
            writer.uint32(13).fixed32(message.messageIdentifier);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRpcMessageHeader();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag != 13) {
                        break;
                    }
                    message.messageIdentifier = reader.fixed32();
                    continue;
            }
            if ((tag & 7) == 4 || tag == 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0 };
    },
    toJSON(message) {
        const obj = {};
        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));
        return obj;
    },
    create(base) {
        return exports.RpcMessageHeader.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseRpcMessageHeader();
        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBaseCreatePort() {
    return { messageIdentifier: 0, portName: "" };
}
exports.CreatePort = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.messageIdentifier !== 0) {
            writer.uint32(13).fixed32(message.messageIdentifier);
        }
        if (message.portName !== "") {
            writer.uint32(34).string(message.portName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreatePort();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag != 13) {
                        break;
                    }
                    message.messageIdentifier = reader.fixed32();
                    continue;
                case 4:
                    if (tag != 34) {
                        break;
                    }
                    message.portName = reader.string();
                    continue;
            }
            if ((tag & 7) == 4 || tag == 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
            portName: isSet(object.portName) ? String(object.portName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));
        message.portName !== undefined && (obj.portName = message.portName);
        return obj;
    },
    create(base) {
        return exports.CreatePort.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseCreatePort();
        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;
        message.portName = (_b = object.portName) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseCreatePortResponse() {
    return { messageIdentifier: 0, portId: 0 };
}
exports.CreatePortResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.messageIdentifier !== 0) {
            writer.uint32(13).fixed32(message.messageIdentifier);
        }
        if (message.portId !== 0) {
            writer.uint32(21).fixed32(message.portId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreatePortResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag != 13) {
                        break;
                    }
                    message.messageIdentifier = reader.fixed32();
                    continue;
                case 2:
                    if (tag != 21) {
                        break;
                    }
                    message.portId = reader.fixed32();
                    continue;
            }
            if ((tag & 7) == 4 || tag == 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
            portId: isSet(object.portId) ? Number(object.portId) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));
        message.portId !== undefined && (obj.portId = Math.round(message.portId));
        return obj;
    },
    create(base) {
        return exports.CreatePortResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseCreatePortResponse();
        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;
        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseRequestModule() {
    return { messageIdentifier: 0, portId: 0, moduleName: "" };
}
exports.RequestModule = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.messageIdentifier !== 0) {
            writer.uint32(13).fixed32(message.messageIdentifier);
        }
        if (message.portId !== 0) {
            writer.uint32(21).fixed32(message.portId);
        }
        if (message.moduleName !== "") {
            writer.uint32(34).string(message.moduleName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestModule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag != 13) {
                        break;
                    }
                    message.messageIdentifier = reader.fixed32();
                    continue;
                case 2:
                    if (tag != 21) {
                        break;
                    }
                    message.portId = reader.fixed32();
                    continue;
                case 4:
                    if (tag != 34) {
                        break;
                    }
                    message.moduleName = reader.string();
                    continue;
            }
            if ((tag & 7) == 4 || tag == 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
            portId: isSet(object.portId) ? Number(object.portId) : 0,
            moduleName: isSet(object.moduleName) ? String(object.moduleName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));
        message.portId !== undefined && (obj.portId = Math.round(message.portId));
        message.moduleName !== undefined && (obj.moduleName = message.moduleName);
        return obj;
    },
    create(base) {
        return exports.RequestModule.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseRequestModule();
        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;
        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;
        message.moduleName = (_c = object.moduleName) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseRequestModuleResponse() {
    return { messageIdentifier: 0, portId: 0, procedures: [] };
}
exports.RequestModuleResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.messageIdentifier !== 0) {
            writer.uint32(13).fixed32(message.messageIdentifier);
        }
        if (message.portId !== 0) {
            writer.uint32(21).fixed32(message.portId);
        }
        for (const v of message.procedures) {
            exports.ModuleProcedure.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestModuleResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag != 13) {
                        break;
                    }
                    message.messageIdentifier = reader.fixed32();
                    continue;
                case 2:
                    if (tag != 21) {
                        break;
                    }
                    message.portId = reader.fixed32();
                    continue;
                case 5:
                    if (tag != 42) {
                        break;
                    }
                    message.procedures.push(exports.ModuleProcedure.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) == 4 || tag == 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
            portId: isSet(object.portId) ? Number(object.portId) : 0,
            procedures: Array.isArray(object === null || object === void 0 ? void 0 : object.procedures)
                ? object.procedures.map((e) => exports.ModuleProcedure.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));
        message.portId !== undefined && (obj.portId = Math.round(message.portId));
        if (message.procedures) {
            obj.procedures = message.procedures.map((e) => e ? exports.ModuleProcedure.toJSON(e) : undefined);
        }
        else {
            obj.procedures = [];
        }
        return obj;
    },
    create(base) {
        return exports.RequestModuleResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseRequestModuleResponse();
        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;
        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;
        message.procedures = ((_c = object.procedures) === null || _c === void 0 ? void 0 : _c.map((e) => exports.ModuleProcedure.fromPartial(e))) || [];
        return message;
    },
};
function createBaseDestroyPort() {
    return { messageIdentifier: 0, portId: 0 };
}
exports.DestroyPort = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.messageIdentifier !== 0) {
            writer.uint32(13).fixed32(message.messageIdentifier);
        }
        if (message.portId !== 0) {
            writer.uint32(21).fixed32(message.portId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDestroyPort();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag != 13) {
                        break;
                    }
                    message.messageIdentifier = reader.fixed32();
                    continue;
                case 2:
                    if (tag != 21) {
                        break;
                    }
                    message.portId = reader.fixed32();
                    continue;
            }
            if ((tag & 7) == 4 || tag == 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
            portId: isSet(object.portId) ? Number(object.portId) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));
        message.portId !== undefined && (obj.portId = Math.round(message.portId));
        return obj;
    },
    create(base) {
        return exports.DestroyPort.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseDestroyPort();
        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;
        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseModuleProcedure() {
    return { procedureId: 0, procedureName: "" };
}
exports.ModuleProcedure = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.procedureId !== 0) {
            writer.uint32(13).fixed32(message.procedureId);
        }
        if (message.procedureName !== "") {
            writer.uint32(18).string(message.procedureName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModuleProcedure();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag != 13) {
                        break;
                    }
                    message.procedureId = reader.fixed32();
                    continue;
                case 2:
                    if (tag != 18) {
                        break;
                    }
                    message.procedureName = reader.string();
                    continue;
            }
            if ((tag & 7) == 4 || tag == 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            procedureId: isSet(object.procedureId) ? Number(object.procedureId) : 0,
            procedureName: isSet(object.procedureName) ? String(object.procedureName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.procedureId !== undefined && (obj.procedureId = Math.round(message.procedureId));
        message.procedureName !== undefined && (obj.procedureName = message.procedureName);
        return obj;
    },
    create(base) {
        return exports.ModuleProcedure.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseModuleProcedure();
        message.procedureId = (_a = object.procedureId) !== null && _a !== void 0 ? _a : 0;
        message.procedureName = (_b = object.procedureName) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseRequest() {
    return { messageIdentifier: 0, portId: 0, procedureId: 0, clientStream: 0, payload: new Uint8Array() };
}
exports.Request = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.messageIdentifier !== 0) {
            writer.uint32(13).fixed32(message.messageIdentifier);
        }
        if (message.portId !== 0) {
            writer.uint32(21).fixed32(message.portId);
        }
        if (message.procedureId !== 0) {
            writer.uint32(37).fixed32(message.procedureId);
        }
        if (message.clientStream !== 0) {
            writer.uint32(45).fixed32(message.clientStream);
        }
        if (message.payload.length !== 0) {
            writer.uint32(50).bytes(message.payload);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag != 13) {
                        break;
                    }
                    message.messageIdentifier = reader.fixed32();
                    continue;
                case 2:
                    if (tag != 21) {
                        break;
                    }
                    message.portId = reader.fixed32();
                    continue;
                case 4:
                    if (tag != 37) {
                        break;
                    }
                    message.procedureId = reader.fixed32();
                    continue;
                case 5:
                    if (tag != 45) {
                        break;
                    }
                    message.clientStream = reader.fixed32();
                    continue;
                case 6:
                    if (tag != 50) {
                        break;
                    }
                    message.payload = reader.bytes();
                    continue;
            }
            if ((tag & 7) == 4 || tag == 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
            portId: isSet(object.portId) ? Number(object.portId) : 0,
            procedureId: isSet(object.procedureId) ? Number(object.procedureId) : 0,
            clientStream: isSet(object.clientStream) ? Number(object.clientStream) : 0,
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));
        message.portId !== undefined && (obj.portId = Math.round(message.portId));
        message.procedureId !== undefined && (obj.procedureId = Math.round(message.procedureId));
        message.clientStream !== undefined && (obj.clientStream = Math.round(message.clientStream));
        message.payload !== undefined &&
            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        return obj;
    },
    create(base) {
        return exports.Request.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseRequest();
        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;
        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;
        message.procedureId = (_c = object.procedureId) !== null && _c !== void 0 ? _c : 0;
        message.clientStream = (_d = object.clientStream) !== null && _d !== void 0 ? _d : 0;
        message.payload = (_e = object.payload) !== null && _e !== void 0 ? _e : new Uint8Array();
        return message;
    },
};
function createBaseRemoteError() {
    return { messageIdentifier: 0, errorCode: 0, errorMessage: "" };
}
exports.RemoteError = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.messageIdentifier !== 0) {
            writer.uint32(13).fixed32(message.messageIdentifier);
        }
        if (message.errorCode !== 0) {
            writer.uint32(21).fixed32(message.errorCode);
        }
        if (message.errorMessage !== "") {
            writer.uint32(26).string(message.errorMessage);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoteError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag != 13) {
                        break;
                    }
                    message.messageIdentifier = reader.fixed32();
                    continue;
                case 2:
                    if (tag != 21) {
                        break;
                    }
                    message.errorCode = reader.fixed32();
                    continue;
                case 3:
                    if (tag != 26) {
                        break;
                    }
                    message.errorMessage = reader.string();
                    continue;
            }
            if ((tag & 7) == 4 || tag == 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
            errorCode: isSet(object.errorCode) ? Number(object.errorCode) : 0,
            errorMessage: isSet(object.errorMessage) ? String(object.errorMessage) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));
        message.errorCode !== undefined && (obj.errorCode = Math.round(message.errorCode));
        message.errorMessage !== undefined && (obj.errorMessage = message.errorMessage);
        return obj;
    },
    create(base) {
        return exports.RemoteError.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseRemoteError();
        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;
        message.errorCode = (_b = object.errorCode) !== null && _b !== void 0 ? _b : 0;
        message.errorMessage = (_c = object.errorMessage) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseResponse() {
    return { messageIdentifier: 0, payload: new Uint8Array() };
}
exports.Response = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.messageIdentifier !== 0) {
            writer.uint32(13).fixed32(message.messageIdentifier);
        }
        if (message.payload.length !== 0) {
            writer.uint32(50).bytes(message.payload);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag != 13) {
                        break;
                    }
                    message.messageIdentifier = reader.fixed32();
                    continue;
                case 6:
                    if (tag != 50) {
                        break;
                    }
                    message.payload = reader.bytes();
                    continue;
            }
            if ((tag & 7) == 4 || tag == 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));
        message.payload !== undefined &&
            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        return obj;
    },
    create(base) {
        return exports.Response.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseResponse();
        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;
        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    },
};
function createBaseStreamMessage() {
    return { messageIdentifier: 0, portId: 0, sequenceId: 0, payload: new Uint8Array(), closed: false, ack: false };
}
exports.StreamMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.messageIdentifier !== 0) {
            writer.uint32(13).fixed32(message.messageIdentifier);
        }
        if (message.portId !== 0) {
            writer.uint32(21).fixed32(message.portId);
        }
        if (message.sequenceId !== 0) {
            writer.uint32(37).fixed32(message.sequenceId);
        }
        if (message.payload.length !== 0) {
            writer.uint32(50).bytes(message.payload);
        }
        if (message.closed === true) {
            writer.uint32(56).bool(message.closed);
        }
        if (message.ack === true) {
            writer.uint32(64).bool(message.ack);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag != 13) {
                        break;
                    }
                    message.messageIdentifier = reader.fixed32();
                    continue;
                case 2:
                    if (tag != 21) {
                        break;
                    }
                    message.portId = reader.fixed32();
                    continue;
                case 4:
                    if (tag != 37) {
                        break;
                    }
                    message.sequenceId = reader.fixed32();
                    continue;
                case 6:
                    if (tag != 50) {
                        break;
                    }
                    message.payload = reader.bytes();
                    continue;
                case 7:
                    if (tag != 56) {
                        break;
                    }
                    message.closed = reader.bool();
                    continue;
                case 8:
                    if (tag != 64) {
                        break;
                    }
                    message.ack = reader.bool();
                    continue;
            }
            if ((tag & 7) == 4 || tag == 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
            portId: isSet(object.portId) ? Number(object.portId) : 0,
            sequenceId: isSet(object.sequenceId) ? Number(object.sequenceId) : 0,
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
            closed: isSet(object.closed) ? Boolean(object.closed) : false,
            ack: isSet(object.ack) ? Boolean(object.ack) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));
        message.portId !== undefined && (obj.portId = Math.round(message.portId));
        message.sequenceId !== undefined && (obj.sequenceId = Math.round(message.sequenceId));
        message.payload !== undefined &&
            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        message.closed !== undefined && (obj.closed = message.closed);
        message.ack !== undefined && (obj.ack = message.ack);
        return obj;
    },
    create(base) {
        return exports.StreamMessage.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseStreamMessage();
        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;
        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;
        message.sequenceId = (_c = object.sequenceId) !== null && _c !== void 0 ? _c : 0;
        message.payload = (_d = object.payload) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.closed = (_e = object.closed) !== null && _e !== void 0 ? _e : false;
        message.ack = (_f = object.ack) !== null && _f !== void 0 ? _f : false;
        return message;
    },
};
var tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (tsProtoGlobalThis.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (tsProtoGlobalThis.Buffer) {
        return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=index.js.map