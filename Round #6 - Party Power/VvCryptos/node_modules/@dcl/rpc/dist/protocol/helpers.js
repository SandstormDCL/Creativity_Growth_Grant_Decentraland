"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseProtocolMessage = exports.calculateMessageIdentifier = exports.parseMessageIdentifier = exports.streamAckMessage = exports.streamMessage = exports.closeStreamMessage = void 0;
const minimal_1 = require("protobufjs/minimal");
const index_1 = require("./index");
const bb = new minimal_1.Writer();
const EMPTY_U8A = Uint8Array.of();
function closeStreamMessage(messageNumber, sequenceId, portId) {
    bb.reset();
    index_1.StreamMessage.encode({
        messageIdentifier: calculateMessageIdentifier(index_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE, messageNumber),
        sequenceId,
        portId,
        ack: false,
        closed: true,
        payload: EMPTY_U8A,
    }, bb);
    return bb.finish();
}
exports.closeStreamMessage = closeStreamMessage;
function streamMessage(messageNumber, sequenceId, portId, payload) {
    bb.reset();
    index_1.StreamMessage.encode({
        messageIdentifier: calculateMessageIdentifier(index_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE, messageNumber),
        sequenceId,
        portId,
        ack: false,
        closed: false,
        payload
    }, bb);
    return bb.finish();
}
exports.streamMessage = streamMessage;
function streamAckMessage(messageNumber, sequenceId, portId) {
    bb.reset();
    index_1.StreamMessage.encode({
        messageIdentifier: calculateMessageIdentifier(index_1.RpcMessageTypes.RpcMessageTypes_STREAM_ACK, messageNumber),
        sequenceId,
        portId,
        ack: true,
        closed: false,
        payload: EMPTY_U8A
    }, bb);
    return bb.finish();
}
exports.streamAckMessage = streamAckMessage;
// @internal
function parseMessageIdentifier(value) {
    return [(value >> 27) & 0xf, value & 0x07ffffff];
}
exports.parseMessageIdentifier = parseMessageIdentifier;
// @internal
function calculateMessageIdentifier(messageType, messageNumber) {
    return ((messageType & 0xf) << 27) | (messageNumber & 0x07ffffff);
}
exports.calculateMessageIdentifier = calculateMessageIdentifier;
function parseProtocolMessage(reader) {
    const originalPos = reader.pos;
    const [messageType, messageNumber] = parseMessageIdentifier(index_1.RpcMessageHeader.decode(reader).messageIdentifier);
    reader.pos = originalPos;
    switch (messageType) {
        case index_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE:
            return [messageType, index_1.CreatePortResponse.decode(reader), messageNumber];
        case index_1.RpcMessageTypes.RpcMessageTypes_RESPONSE:
            return [messageType, index_1.Response.decode(reader), messageNumber];
        case index_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE:
            return [messageType, index_1.RequestModuleResponse.decode(reader), messageNumber];
        case index_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE:
            return [messageType, index_1.StreamMessage.decode(reader), messageNumber];
        case index_1.RpcMessageTypes.RpcMessageTypes_SERVER_READY:
            return [messageType, null, messageNumber];
        case index_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE:
            return [messageType, index_1.RemoteError.decode(reader), messageNumber];
        case index_1.RpcMessageTypes.RpcMessageTypes_REQUEST:
            return [messageType, index_1.Request.decode(reader), messageNumber];
        case index_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT:
            return [messageType, index_1.CreatePort.decode(reader), messageNumber];
        case index_1.RpcMessageTypes.RpcMessageTypes_STREAM_ACK:
            return [messageType, index_1.StreamMessage.decode(reader), messageNumber];
        case index_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE:
            return [messageType, index_1.RequestModule.decode(reader), messageNumber];
        case index_1.RpcMessageTypes.RpcMessageTypes_DESTROY_PORT:
            return [messageType, index_1.DestroyPort.decode(reader), messageNumber];
    }
    return null;
}
exports.parseProtocolMessage = parseProtocolMessage;
//# sourceMappingURL=helpers.js.map