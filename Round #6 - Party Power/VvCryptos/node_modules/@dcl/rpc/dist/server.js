"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRpcServer = exports.handleRequest = exports.sendServerStream = exports.handleDestroyPort = exports.handleRequestModule = exports.handleCreatePort = exports.createServerPort = void 0;
const mitt_1 = __importDefault(require("mitt"));
const minimal_1 = require("protobufjs/minimal");
const helpers_1 = require("./protocol/helpers");
const protocol_1 = require("./protocol");
const message_dispatcher_1 = require("./message-dispatcher");
const stream_protocol_1 = require("./stream-protocol");
let lastPortId = 0;
const EMPTY_U8A = Uint8Array.from([]);
// only use this writer in synchronous operations. It exists to prevent allocations
const unsafeSyncWriter = new minimal_1.Writer();
function getServerReadyMessage() {
    unsafeSyncWriter.reset();
    protocol_1.RpcMessageHeader.encode({
        messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_SERVER_READY, 0),
    }, unsafeSyncWriter);
    return unsafeSyncWriter.finish();
}
const transportStartMessageSerialized = getServerReadyMessage();
function moduleProcedures(module) {
    return Array.from(Object.entries(module)).filter(([name, value]) => typeof value == "function");
}
/**
 * @internal
 */
function createServerPort(portId, portName, context) {
    const events = (0, mitt_1.default)();
    const loadedModules = new Map();
    const procedures = new Map();
    const registeredModules = new Map();
    const port = {
        get portId() {
            return portId;
        },
        get portName() {
            return portName;
        },
        ...events,
        registerModule,
        loadModule,
        close,
        callProcedure,
    };
    async function close() {
        loadedModules.clear();
        procedures.clear();
        registeredModules.clear();
        events.emit("close", {});
    }
    async function registerModule(moduleName, generator) {
        if (registeredModules.has(moduleName)) {
            throw new Error(`module ${moduleName} is already registered for port ${portName} (${portId}))`);
        }
        registeredModules.set(moduleName, generator);
    }
    async function loadModuleFromGenerator(moduleFuture) {
        const module = await moduleFuture;
        const ret = {
            procedures: [],
        };
        for (const [procedureName, callable] of moduleProcedures(module)) {
            const procedureId = procedures.size + 1;
            procedures.set(procedureId, callable);
            ret.procedures.push({
                procedureName,
                callable,
                procedureId,
            });
        }
        return ret;
    }
    function loadModule(moduleName) {
        if (loadedModules.has(moduleName)) {
            return loadedModules.get(moduleName);
        }
        const moduleGenerator = registeredModules.get(moduleName);
        if (!moduleGenerator) {
            throw new Error(`Module ${moduleName} is not available for port ${portName} (${portId}))`);
        }
        const moduleFuture = loadModuleFromGenerator(moduleGenerator(port, context));
        loadedModules.set(moduleName, moduleFuture);
        return moduleFuture;
    }
    function callProcedure(procedureId, payload, context) {
        const procedure = procedures.get(procedureId);
        if (!procedure) {
            throw new Error(`procedureId ${procedureId} is missing in ${portName} (${portId}))`);
        }
        return procedure(payload, context);
    }
    return port;
}
exports.createServerPort = createServerPort;
function getPortFromState(portId, transport, state) {
    var _a;
    return (_a = state.portsByTransport.get(transport)) === null || _a === void 0 ? void 0 : _a.get(portId);
}
// @internal
async function handleCreatePort(transport, createPortMessage, messageNumber, options, handler, state, context) {
    lastPortId++;
    const port = createServerPort(lastPortId, createPortMessage.portName, context);
    const byTransport = state.portsByTransport.get(transport) || new Map();
    byTransport.set(port.portId, port);
    state.ports.set(port.portId, port);
    state.portsByTransport.set(transport, byTransport);
    await handler(port, transport, context);
    unsafeSyncWriter.reset();
    protocol_1.CreatePortResponse.encode({
        messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE, messageNumber),
        portId: port.portId,
    }, unsafeSyncWriter);
    transport.sendMessage(unsafeSyncWriter.finish());
    return port;
}
exports.handleCreatePort = handleCreatePort;
// @internal
async function handleRequestModule(transport, requestModule, messageNumber, state) {
    const port = getPortFromState(requestModule.portId, transport, state);
    if (!port) {
        throw new Error(`Cannot find port ${requestModule.portId}`);
    }
    const loadedModule = await port.loadModule(requestModule.moduleName);
    unsafeSyncWriter.reset();
    protocol_1.RequestModuleResponse.encode({
        procedures: loadedModule.procedures,
        messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE, messageNumber),
        portId: port.portId,
    }, unsafeSyncWriter);
    transport.sendMessage(unsafeSyncWriter.finish());
}
exports.handleRequestModule = handleRequestModule;
// @internal
async function handleDestroyPort(transport, request, _messageNumber, state) {
    const port = getPortFromState(request.portId, transport, state);
    if (port) {
        port.emit("close", {});
    }
}
exports.handleDestroyPort = handleDestroyPort;
// @internal
async function sendServerStream(dispatcher, transport, stream, portId, messageNumber) {
    const reusedStreamMessage = protocol_1.StreamMessage.fromJSON({
        closed: false,
        ack: false,
        sequenceId: 0,
        messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE, messageNumber),
        payload: EMPTY_U8A,
        portId: portId,
    });
    // First, tell the client that we are opening a stream. Once the client sends
    // an ACK, we will know if they are ready to consume the first element.
    // If the response is instead close=true, then this function returns and
    // no stream.next() is called
    // The following lines are called "stream offer" in the tests.
    const ret = await dispatcher.sendStreamMessage(reusedStreamMessage);
    if (ret.closed)
        return;
    if (!ret.ack)
        throw new Error("Error in logic, ACK must be true");
    await (0, stream_protocol_1.sendStreamThroughTransport)(dispatcher, transport, stream, portId, messageNumber);
}
exports.sendServerStream = sendServerStream;
// @internal
async function handleRequest(request, messageNumber, state, transport, context, dispatcher) {
    const port = getPortFromState(request.portId, transport, state);
    if (!port) {
        unsafeSyncWriter.reset();
        protocol_1.RemoteError.encode({
            messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE, messageNumber),
            errorCode: 0,
            errorMessage: "invalid portId",
        }, unsafeSyncWriter);
        transport.sendMessage(unsafeSyncWriter.finish());
        return;
    }
    const { clientStream } = request;
    const stream = clientStream ? (0, stream_protocol_1.streamFromDispatcher)(dispatcher, request.portId, request.clientStream) : null;
    const result = request.clientStream
        ? await port.callProcedure(request.procedureId, stream.generator, context)
        : await port.callProcedure(request.procedureId, request.payload, context);
    const response = protocol_1.Response.fromJSON({
        messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_RESPONSE, messageNumber),
        payload: EMPTY_U8A,
    });
    if (result instanceof Uint8Array) {
        response.payload = result;
        unsafeSyncWriter.reset();
        protocol_1.Response.encode(response, unsafeSyncWriter);
        transport.sendMessage(unsafeSyncWriter.finish());
    }
    else if (result && Symbol.asyncIterator in result) {
        await sendServerStream(dispatcher, transport, result, port.portId, messageNumber);
    }
    else {
        unsafeSyncWriter.reset();
        protocol_1.Response.encode(response, unsafeSyncWriter);
        transport.sendMessage(unsafeSyncWriter.finish());
    }
    // if the clientStream was not opened by the server at the moment of returning
    // then the client stream should be closed. This condition is necessary to prevent
    // memory leaks client-side.
    // on the contrary, server side memory leaks are not possible because the method
    // itself returns the iterator or an unary result.
    stream === null || stream === void 0 ? void 0 : stream.closeIfNotOpened();
}
exports.handleRequest = handleRequest;
/**
 * @public
 */
function createRpcServer(options) {
    const events = (0, mitt_1.default)();
    const state = {
        ports: new Map(),
        portsByTransport: new Map(),
        transports: new Set(),
    };
    function removeTransport(transport) {
        const transportPorts = state.portsByTransport.get(transport);
        state.portsByTransport.delete(transport);
        if (transportPorts && transportPorts.size) {
            transportPorts.forEach(($) => $.close());
        }
        if (state.transports.delete(transport)) {
            events.emit("transportClosed", { transport });
        }
    }
    events.on("portClosed", (evt) => {
        const { port, transport } = evt;
        state.ports.delete(port.portId);
        // TODO: we need to add a test for this
        const portsByTransport = state.portsByTransport.get(transport);
        if (portsByTransport) {
            // TODO: test this line
            portsByTransport.delete(port.portId);
        }
    });
    function handleTransportError(transport, error) {
        events.emit("transportError", { transport, error });
        transport.close();
        removeTransport(transport);
    }
    let handler;
    async function handleMessage(messageType, parsedMessage, messageNumber, transport, context, dispatcher) {
        if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST) {
            await handleRequest(parsedMessage, messageNumber, state, transport, context, dispatcher);
        }
        else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE) {
            await handleRequestModule(transport, parsedMessage, messageNumber, state);
        }
        else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT) {
            const port = await handleCreatePort(transport, parsedMessage, messageNumber, options, handler, state, context);
            port.on("close", () => events.emit("portClosed", { port, transport }));
        }
        else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_DESTROY_PORT) {
            await handleDestroyPort(transport, parsedMessage, messageNumber, state);
        }
        else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_ACK ||
            messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE) {
            // noops
        }
        else {
            transport.emit("error", new Error(`Unknown message from client ${JSON.stringify([messageType, parsedMessage, messageNumber])}`));
        }
    }
    return {
        ...events,
        setHandler(_handler) {
            handler = _handler;
        },
        attachTransport(newTransport, context) {
            if (!handler) {
                throw new Error("A handler was not set for this RpcServer");
            }
            state.transports.add(newTransport);
            const dispatcher = (0, message_dispatcher_1.messageDispatcher)(newTransport);
            dispatcher.setGlobalHandler((messageType, message, messageNumber) => {
                handleMessage(messageType, message, messageNumber, newTransport, context, dispatcher).catch((err) => {
                    var _a;
                    (_a = options.logger) === null || _a === void 0 ? void 0 : _a.error("Error handling remote request", {
                        message: err.message,
                        name: err.name,
                        stack: err.stack,
                    });
                    unsafeSyncWriter.reset();
                    protocol_1.RemoteError.encode({
                        messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE, messageNumber),
                        errorMessage: err.message || "Error processing the request",
                        errorCode: 0,
                    }, unsafeSyncWriter);
                    newTransport.sendMessage(unsafeSyncWriter.finish());
                });
            });
            newTransport.on("close", () => {
                removeTransport(newTransport);
            });
            newTransport.on("error", (error) => {
                var _a;
                (_a = options.logger) === null || _a === void 0 ? void 0 : _a.error("Error in transport", {
                    message: error.message,
                    name: error.name,
                    stack: error.stack,
                });
                handleTransportError(newTransport, error);
            });
            // send the signal to the transport
            newTransport.sendMessage(transportStartMessageSerialized);
        },
    };
}
exports.createRpcServer = createRpcServer;
//# sourceMappingURL=server.js.map