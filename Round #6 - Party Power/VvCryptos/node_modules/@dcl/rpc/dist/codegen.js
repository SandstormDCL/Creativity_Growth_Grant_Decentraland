"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerService = exports.loadService = exports.serverProcedureBidirectionalStream = exports.serverProcedureServerStream = exports.serverProcedureClientStream = exports.serverProcedureUnary = exports.clientProcedureBidirectionalStream = exports.clientProcedureServerStream = exports.clientProcedureClientStream = exports.clientProcedureUnary = void 0;
const EMPTY_U8ARRAY = new Uint8Array();
function clientProcedureUnary(port, method) {
    const fn = async (arg) => {
        const remoteModule = (await port);
        if (!(method.name in remoteModule))
            throw new Error("Method " + method.name + " not implemented in server port");
        const result = await remoteModule[method.name](method.requestType.encode(arg).finish());
        return method.responseType.decode(result !== null && result !== void 0 ? result : EMPTY_U8ARRAY);
    };
    return fn;
}
exports.clientProcedureUnary = clientProcedureUnary;
async function* requestToBinaryGenerator(requests, method) {
    for await (const request of requests) {
        const arg = method.requestType.encode(request);
        yield arg.finish();
    }
}
function clientProcedureClientStream(port, method) {
    const fn = async (arg) => {
        const remoteModule = (await port);
        if (!(method.name in remoteModule))
            throw new Error("Method " + method.name + " not implemented in server port");
        const result = await remoteModule[method.name](requestToBinaryGenerator(arg, method));
        return method.responseType.decode(result !== null && result !== void 0 ? result : EMPTY_U8ARRAY);
    };
    return fn;
}
exports.clientProcedureClientStream = clientProcedureClientStream;
function clientProcedureServerStream(port, method) {
    const fn = function (arg) {
        let _generator = undefined;
        async function lazyGenerator() {
            const remoteModule = (await port);
            if (!(method.name in remoteModule))
                throw new Error("Method " + method.name + " not implemented in server port");
            return (await remoteModule[method.name](method.requestType.encode(arg).finish()))[Symbol.asyncIterator]();
        }
        function getGenerator() {
            if (!_generator) {
                _generator = lazyGenerator();
            }
            return _generator;
        }
        const ret = {
            [Symbol.asyncIterator]: () => ret,
            async next() {
                var _a;
                const iter = await (await getGenerator()).next();
                return { value: method.responseType.decode((_a = iter.value) !== null && _a !== void 0 ? _a : EMPTY_U8ARRAY), done: iter.done };
            },
            async return(value) {
                const iter = await (await getGenerator()).return(value);
                return { value: iter.value ? method.responseType.decode(iter.value) : iter.value, done: iter.done };
            },
            async throw(value) {
                const iter = await (await getGenerator()).throw(value);
                return { value: iter.value ? method.responseType.decode(iter.value) : iter.value, done: iter.done };
            }
        };
        return ret;
    };
    return fn;
}
exports.clientProcedureServerStream = clientProcedureServerStream;
function clientProcedureBidirectionalStream(port, method) {
    const fn = function (arg) {
        let _generator = undefined;
        async function lazyGenerator() {
            const remoteModule = (await port);
            if (!(method.name in remoteModule))
                throw new Error("Method " + method.name + " not implemented in server port");
            return (await remoteModule[method.name](requestToBinaryGenerator(arg, method)))[Symbol.asyncIterator]();
        }
        function getGenerator() {
            if (!_generator) {
                _generator = lazyGenerator();
            }
            return _generator;
        }
        const ret = {
            [Symbol.asyncIterator]: () => ret,
            async next() {
                var _a;
                const iter = await (await getGenerator()).next();
                return { value: method.responseType.decode((_a = iter.value) !== null && _a !== void 0 ? _a : EMPTY_U8ARRAY), done: iter.done };
            },
            async return(value) {
                const iter = await (await getGenerator()).return(value);
                return { value: iter.value ? method.responseType.decode(iter.value) : iter.value, done: iter.done };
            },
            async throw(value) {
                const iter = await (await getGenerator()).throw(value);
                return { value: iter.value ? method.responseType.decode(iter.value) : iter.value, done: iter.done };
            }
        };
        return ret;
    };
    return fn;
}
exports.clientProcedureBidirectionalStream = clientProcedureBidirectionalStream;
function serverProcedureUnary(fn, method) {
    return async function (argBinary, context) {
        const arg = method.requestType.decode(argBinary);
        const result = await fn(arg, context);
        if (!result)
            throw new Error("Empty or null responses are not allowed. Procedure: " + method.name);
        return method.responseType.encode(result).finish();
    };
}
exports.serverProcedureUnary = serverProcedureUnary;
async function* binaryToRequestGenerator(argBinaryGenerator, method) {
    for await (const argBinary of argBinaryGenerator) {
        const arg = method.requestType.decode(argBinary);
        yield arg;
    }
}
function serverProcedureClientStream(fn, method) {
    return async function (argBinaryGenerator, context) {
        const result = await fn(binaryToRequestGenerator(argBinaryGenerator, method), context);
        if (!result)
            throw new Error("Empty or null responses are not allowed. Procedure: " + method.name);
        return method.responseType.encode(result).finish();
    };
}
exports.serverProcedureClientStream = serverProcedureClientStream;
function serverProcedureServerStream(fn, method) {
    return function (argBinary, context) {
        let _generator = undefined;
        const arg = method.requestType.decode(argBinary);
        async function lazyGenerator() {
            const result = (await fn(arg, context));
            if (!result)
                throw new Error("Empty or null responses are not allowed. Procedure: " + method.name);
            return result[Symbol.asyncIterator]();
        }
        function getGenerator() {
            if (!_generator) {
                _generator = lazyGenerator();
            }
            return _generator;
        }
        const ret = {
            [Symbol.asyncIterator]: () => ret,
            async next() {
                const iter = await (await getGenerator()).next();
                return { value: iter.value ? method.responseType.encode(iter.value).finish() : iter.value, done: iter.done };
            },
            async return(value) {
                const iter = await (await getGenerator()).return(value);
                return { value: iter.value ? method.responseType.encode(iter.value).finish() : iter.value, done: iter.done };
            },
            async throw(value) {
                const iter = await (await getGenerator()).throw(value);
                return { value: iter.value ? method.responseType.encode(iter.value).finish() : iter.value, done: iter.done };
            }
        };
        return ret;
    };
}
exports.serverProcedureServerStream = serverProcedureServerStream;
function serverProcedureBidirectionalStream(fn, method) {
    return function (argBinaryGenerator, context) {
        let _generator = undefined;
        async function lazyGenerator() {
            const result = (await fn(binaryToRequestGenerator(argBinaryGenerator, method), context));
            if (!result)
                throw new Error("Empty or null responses are not allowed. Procedure: " + method.name);
            return result[Symbol.asyncIterator]();
        }
        function getGenerator() {
            if (!_generator) {
                _generator = lazyGenerator();
            }
            return _generator;
        }
        const ret = {
            [Symbol.asyncIterator]: () => ret,
            async next() {
                const iter = await (await getGenerator()).next();
                return { value: iter.value ? method.responseType.encode(iter.value).finish() : iter.value, done: iter.done };
            },
            async return(value) {
                const iter = await (await getGenerator()).return(value);
                return { value: iter.value ? method.responseType.encode(iter.value).finish() : iter.value, done: iter.done };
            },
            async throw(value) {
                const iter = await (await getGenerator()).throw(value);
                return { value: iter.value ? method.responseType.encode(iter.value).finish() : iter.value, done: iter.done };
            }
        };
        return ret;
    };
}
exports.serverProcedureBidirectionalStream = serverProcedureBidirectionalStream;
function loadService(port, service) {
    const portFuture = port.loadModule(service.name);
    const ret = {};
    for (const [key, def] of Object.entries(service.methods)) {
        if (def.responseStream && def.requestStream) {
            ret[key] = clientProcedureBidirectionalStream(portFuture, def);
        }
        else if (def.responseStream) {
            ret[key] = clientProcedureServerStream(portFuture, def);
        }
        else if (def.requestStream) {
            ret[key] = clientProcedureClientStream(portFuture, def);
        }
        else {
            ret[key] = clientProcedureUnary(portFuture, def);
        }
    }
    return ret;
}
exports.loadService = loadService;
function registerService(port, service, moduleInitializator) {
    port.registerModule(service.name, async (port, context) => {
        const mod = await moduleInitializator(port, context);
        const ret = {};
        for (const [key, def] of Object.entries(service.methods)) {
            if (def.responseStream && def.requestStream) {
                ret[def.name] = serverProcedureBidirectionalStream(mod[key].bind(mod), def);
            }
            else if (def.responseStream) {
                ret[def.name] = serverProcedureServerStream(mod[key].bind(mod), def);
            }
            else if (def.requestStream) {
                ret[def.name] = serverProcedureClientStream(mod[key].bind(mod), def);
            }
            else {
                ret[def.name] = serverProcedureUnary(mod[key].bind(mod), def);
            }
        }
        return ret;
    });
}
exports.registerService = registerService;
//# sourceMappingURL=codegen.js.map