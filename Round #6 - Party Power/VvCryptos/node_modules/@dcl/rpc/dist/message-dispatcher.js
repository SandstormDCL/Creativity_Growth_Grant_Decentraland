"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.messageDispatcher = void 0;
const minimal_1 = require("protobufjs/minimal");
const helpers_1 = require("./protocol/helpers");
const protocol_1 = require("./protocol");
function messageDispatcher(transport) {
    // message_number -> future
    const oneTimeCallbacks = new Map();
    const listeners = new Map();
    let globalHandlerFunction;
    transport.on("message", (message) => {
        try {
            const reader = minimal_1.Reader.create(message);
            const parsedMessage = (0, helpers_1.parseProtocolMessage)(reader);
            if (parsedMessage) {
                const [messageType, message, messageNumber] = parsedMessage;
                if (globalHandlerFunction)
                    globalHandlerFunction(messageType, message, messageNumber);
                if (messageNumber > 0) {
                    const fut = oneTimeCallbacks.get(messageNumber);
                    try {
                        if (fut) {
                            const [resolve] = fut;
                            reader.pos = 0;
                            resolve({ reader, messageType, messageNumber, message });
                            oneTimeCallbacks.delete(messageNumber);
                        }
                        const handler = listeners.get(messageNumber);
                        if (handler) {
                            reader.pos = 0;
                            handler(reader, messageType, messageNumber, message);
                        }
                        if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_ACK ||
                            messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE) {
                            receiveAck(message, messageNumber);
                        }
                    }
                    catch (err) {
                        transport.emit("error", err);
                    }
                }
            }
            else {
                transport.emit("error", new Error(`Transport received unknown message: ${message}`));
            }
        }
        catch (err) {
            transport.emit("error", err);
        }
    });
    const ackCallbacks = new Map();
    const bb = new minimal_1.Writer();
    function closeAll() {
        ackCallbacks.forEach(([resolve]) => resolve({ closed: true, ack: false }));
        oneTimeCallbacks.forEach(([, reject]) => reject(new Error('RPC Transport closed')));
        ackCallbacks.clear();
    }
    transport.on("close", closeAll);
    transport.on("error", (err) => {
        ackCallbacks.forEach(([, reject]) => reject(err));
        oneTimeCallbacks.forEach(([, reject]) => reject(err));
        ackCallbacks.clear();
    });
    function receiveAck(data, messageNumber) {
        const key = `${messageNumber},${data.sequenceId}`;
        const fut = ackCallbacks.get(key);
        if (fut) {
            ackCallbacks.delete(key);
            fut[0](data);
            // TODO: https://github.com/decentraland/rpc/issues/116
            //} else {
            //  throw new Error("Received an ACK message for an inexistent handler " + key)
        }
    }
    return {
        transport,
        setGlobalHandler(handler) {
            globalHandlerFunction = handler;
        },
        addOneTimeListener(messageId) {
            return new Promise((res, rej) => {
                oneTimeCallbacks.set(messageId, [res, rej]);
            });
        },
        addListener(messageId, handler) {
            if (listeners.has(messageId))
                throw new Error("There is already a handler for messageId " + messageId);
            listeners.set(messageId, handler);
        },
        removeListener(messageId) {
            if (!listeners.has(messageId))
                throw new Error("A handler is missing for messageId " + messageId);
            listeners.delete(messageId);
        },
        async sendStreamMessage(data) {
            const [_, messageNumber] = (0, helpers_1.parseMessageIdentifier)(data.messageIdentifier);
            const key = `${messageNumber},${data.sequenceId}`;
            const ret = new Promise(function ackPromise(ret, rej) {
                ackCallbacks.set(key, [ret, rej]);
            });
            bb.reset();
            protocol_1.StreamMessage.encode(data, bb);
            transport.sendMessage(bb.finish());
            return ret;
        },
    };
}
exports.messageDispatcher = messageDispatcher;
//# sourceMappingURL=message-dispatcher.js.map