"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRpcClient = exports.createPort = void 0;
const mitt_1 = __importDefault(require("mitt"));
const minimal_1 = require("protobufjs/minimal");
const protocol_1 = require("./protocol");
const message_dispatcher_1 = require("./message-dispatcher");
const helpers_1 = require("./protocol/helpers");
const client_request_dispatcher_1 = require("./client-request-dispatcher");
const stream_protocol_1 = require("./stream-protocol");
const EMPTY_U8 = new Uint8Array(0);
// @internal
function createPort(portId, portName, requestDispatcher) {
    const events = (0, mitt_1.default)();
    let state = "open";
    events.on("close", () => {
        state = "closed";
    });
    return {
        ...events,
        portName,
        portId,
        get state() {
            return state;
        },
        close() {
            const bb = new minimal_1.Writer();
            protocol_1.DestroyPort.encode({
                messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_DESTROY_PORT, 0),
                portId,
            }, bb);
            requestDispatcher.dispatcher.transport.sendMessage(bb.finish());
            events.emit("close", {});
        },
        async loadModule(moduleName) {
            const ret = await requestDispatcher.request((bb, messageNumber) => {
                protocol_1.RequestModule.encode({
                    messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE, messageNumber),
                    moduleName,
                    portId,
                }, bb);
            });
            const parsedMessage = (0, helpers_1.parseProtocolMessage)(ret);
            if (parsedMessage) {
                const [messageType, message] = parsedMessage;
                if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE) {
                    const ret = {};
                    for (let procedure of message.procedures) {
                        ret[procedure.procedureName] = createProcedure(portId, procedure.procedureId, requestDispatcher);
                    }
                    return ret;
                }
                else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE) {
                    throwIfRemoteError(message);
                }
            }
            throw new Error("Unknown response received from server.");
        },
    };
}
exports.createPort = createPort;
function throwIfRemoteError(parsedMessage) {
    throw new Error("RemoteError: " + parsedMessage.errorMessage);
}
/**
 * This function is called client side, to generate an adapter for the protocol.
 * The client must accept an U8 or AsyncIterable<U8> as parameter.
 * And must return whatever the server decides, either it be an U8 or AsyncIterable<U8>
 * @internal
 */
function createProcedure(portId, procedureId, requestDispatcher) {
    const callProcedurePacket = {
        portId,
        messageIdentifier: 0,
        payload: EMPTY_U8,
        procedureId,
        clientStream: 0,
    };
    return async function (data) {
        // TODO: Move to a function helper
        if (data) {
            if (Symbol.asyncIterator in data) {
                // if we are going to generate a client stream, it will be handled with a new
                // message ID
                const messageNumber = requestDispatcher.nextMessageNumber();
                callProcedurePacket.clientStream = messageNumber;
                callProcedurePacket.payload = EMPTY_U8;
                requestDispatcher.dispatcher
                    .addOneTimeListener(messageNumber)
                    .then(($) => {
                    const message = $.message;
                    if (message.closed)
                        return;
                    if (!message.ack)
                        throw new Error("Error in logic, ACK must be true");
                    (0, stream_protocol_1.sendStreamThroughTransport)(requestDispatcher.dispatcher, requestDispatcher.dispatcher.transport, data, portId, messageNumber);
                })
                    .catch((error) => {
                    requestDispatcher.dispatcher.transport.emit("error", error);
                });
            }
            else {
                callProcedurePacket.payload = data;
            }
        }
        else {
            callProcedurePacket.payload = EMPTY_U8;
        }
        const ret = (0, helpers_1.parseProtocolMessage)(await requestDispatcher.request((bb, messageNumber) => {
            callProcedurePacket.messageIdentifier = (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST, messageNumber);
            protocol_1.Request.encode(callProcedurePacket, bb);
        }));
        if (ret) {
            const [messageType, message, messageNumber] = ret;
            if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_RESPONSE) {
                const u8 = message.payload;
                if (u8.length) {
                    return u8;
                }
                else {
                    return undefined;
                }
            }
            else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE) {
                // If a OpenStream is received with an serverStream, then it means we have the POSSIBILITY
                // to consume a remote generator. Look into the streamFromDispatcher functions
                // for more information.
                const openStreamMessage = message;
                const { generator } = (0, stream_protocol_1.streamFromDispatcher)(requestDispatcher.dispatcher, openStreamMessage.portId, messageNumber);
                return generator;
            }
            else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE) {
                throwIfRemoteError(message);
            }
        }
    };
}
/**
 * @public
 */
async function createRpcClient(transport) {
    const clientPortByName = new Map();
    const dispatcher = (0, message_dispatcher_1.messageDispatcher)(transport);
    const requestDispatcher = (0, client_request_dispatcher_1.createClientRequestDispatcher)(dispatcher);
    async function internalCreatePort(portName) {
        const ret = await requestDispatcher.request((bb, messageNumber) => {
            protocol_1.CreatePort.encode({
                messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT, messageNumber),
                portName,
            }, bb);
        });
        const parsedMessage = (0, helpers_1.parseProtocolMessage)(ret);
        if (parsedMessage) {
            const [messageType, message] = parsedMessage;
            if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE) {
                const portId = message.portId;
                return createPort(portId, portName, requestDispatcher);
            }
            else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE) {
                throwIfRemoteError(message);
            }
        }
        throw new Error("Unknown response received from server.");
    }
    // wait for transport to be connected
    if (!transport.isConnected) {
        await new Promise((resolve, reject) => {
            transport.on("connect", resolve);
            transport.on("error", reject);
        });
    }
    return {
        // the only objective of this function is to deduplicate asynchronous calls
        // and produce an idempotent module load
        async createPort(portName) {
            if (clientPortByName.has(portName)) {
                return clientPortByName.get(portName);
            }
            const portFuture = internalCreatePort(portName);
            clientPortByName.set(portName, portFuture);
            const port = await portFuture;
            transport.on("close", () => {
                port.close();
            });
            port.on("close", () => {
                if (clientPortByName.get(portName) === portFuture) {
                    clientPortByName.delete(portName);
                }
            });
            return port;
        },
    };
}
exports.createRpcClient = createRpcClient;
//# sourceMappingURL=client.js.map