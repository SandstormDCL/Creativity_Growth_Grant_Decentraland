"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncQueue = exports.pushableChannel = exports.linkedList = void 0;
class Node {
    constructor(value, prev) {
        this.value = value;
        this.prev = prev;
        this.next = undefined;
    }
}
function linkedList() {
    let head = undefined;
    let tail = undefined;
    function enqueue(value) {
        const node = new Node(value, tail);
        if (tail) {
            tail.next = node;
        }
        if (!head) {
            head = node;
        }
        tail = node;
    }
    function remove(node) {
        if (!node.next) {
            tail = node.prev;
        }
        else {
            const nextNode = node.next;
            nextNode.prev = node.prev;
        }
        if (!node.prev) {
            head = node.next;
        }
        else {
            const prevNode = node.prev;
            prevNode.next = node.next;
        }
    }
    // removes the head node and updates the head
    function dequeue() {
        const ret = head;
        if (ret) {
            remove(ret);
            // this is important to prevent leaks
            delete ret.next;
            delete ret.prev;
            const value = ret.value;
            // help the GC
            delete ret.value;
            return value;
        }
        return undefined;
    }
    // signals if the list is empty
    function isEmpty() {
        return !head;
    }
    return { enqueue, dequeue, isEmpty };
}
exports.linkedList = linkedList;
function pushableChannel(onIteratorClose) {
    let returnLock = null;
    const queue = linkedList();
    let closed = false;
    let error = null;
    function closeAllPending() {
        if (!queue.isEmpty()) {
            const err = error || new Error("Channel was closed before deliverying the message");
            while (!queue.isEmpty()) {
                const { resolve } = queue.dequeue();
                if (resolve)
                    resolve(err);
            }
        }
    }
    function releaseLockIfNeeded() {
        // signal that we have a value
        if (returnLock) {
            const originalReturnLock = returnLock;
            returnLock = null;
            originalReturnLock();
        }
    }
    function push(value, resolve) {
        if (closed) {
            resolve(new Error("Channel is closed"));
            return;
        }
        if (error) {
            resolve(error);
            return;
        }
        // push the value to the queue
        queue.enqueue({ value, resolve });
        releaseLockIfNeeded();
    }
    function failAndClose(errorToThrow) {
        error = errorToThrow;
        close();
        closeAllPending();
    }
    function yieldNextResult() {
        if (error && queue.isEmpty()) {
            throw error;
        }
        if (closed && queue.isEmpty()) {
            return { done: true, value: undefined };
        }
        if (!queue.isEmpty()) {
            const node = queue.dequeue();
            if (node.resolve)
                node.resolve(error || undefined);
            return {
                done: false,
                value: node.value,
            };
        }
    }
    function close() {
        if (!closed) {
            closed = true;
            releaseLockIfNeeded();
            onIteratorClose();
        }
    }
    const iterable = {
        async next() {
            while (true) {
                try {
                    const result = yieldNextResult();
                    if (result) {
                        return result;
                    }
                    else {
                        await new Promise((res) => (returnLock = res));
                    }
                }
                catch (err) {
                    failAndClose(err);
                    throw err;
                }
            }
        },
        async return(value) {
            close();
            closeAllPending();
            return { done: true, value };
        },
        async throw(e) {
            if (error) {
                throw error;
            }
            failAndClose(e);
            return { done: true, value: undefined };
        },
        [Symbol.asyncIterator]() {
            return iterable;
        },
    };
    function isClosed() {
        return closed;
    }
    return { iterable, push, close, failAndClose, isClosed, [Symbol.asyncIterator]: () => iterable };
}
exports.pushableChannel = pushableChannel;
class AsyncQueue {
    constructor(requestingNext) {
        this.requestingNext = requestingNext;
        // enqueues > dequeues
        this.values = linkedList();
        // dequeues > enqueues
        this.settlers = linkedList();
        this.closed = false;
        this.error = undefined;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    enqueue(value) {
        if (this.closed) {
            throw new Error("Channel is closed");
        }
        if (!this.settlers.isEmpty()) {
            if (!this.values.isEmpty()) {
                throw new Error("Illegal internal state");
            }
            const settler = this.settlers.dequeue();
            if (value instanceof Error) {
                settler.reject(value);
            }
            else {
                settler.resolve({ value });
            }
        }
        else {
            this.values.enqueue({ value });
        }
    }
    /**
     * @returns a Promise for an IteratorResult
     */
    async next() {
        if (!this.values.isEmpty()) {
            const value = this.values.dequeue();
            return value;
        }
        if (this.error) {
            throw this.error;
        }
        if (this.closed) {
            if (!this.settlers.isEmpty()) {
                throw new Error("Illegal internal state");
            }
            return { done: true, value: undefined };
        }
        // Wait for new values to be enqueued
        return new Promise((resolve, reject) => {
            this.requestingNext(this, "next");
            this.settlers.enqueue({ resolve, reject });
        });
    }
    async return(value) {
        this.close(value);
        return { done: true, value };
    }
    async throw(error) {
        this.close(error);
        return { done: true, value: undefined };
    }
    close(error) {
        if (error)
            while (!this.settlers.isEmpty()) {
                this.settlers.dequeue().reject(error);
            }
        else
            while (!this.settlers.isEmpty()) {
                this.settlers.dequeue().resolve({ done: true, value: undefined });
            }
        if (error)
            this.error = error;
        if (!this.closed) {
            this.closed = true;
            this.requestingNext(this, "close");
        }
    }
}
exports.AsyncQueue = AsyncQueue;
//# sourceMappingURL=push-channel.js.map