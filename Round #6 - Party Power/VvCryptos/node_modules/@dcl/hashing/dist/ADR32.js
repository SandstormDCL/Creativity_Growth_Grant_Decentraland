"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateMultipleHashesADR32LegacyQmHash = exports.calculateMultipleHashesADR32 = exports.prepareADR32Data = exports.compareStrings = exports.sortKeys = void 0;
const node_1 = require("./node");
// Compare both by key and hash
// @internal
function sortKeys(a, b) {
    return compareStrings(a.hash, b.hash) || compareStrings(a.file, b.file) || 0;
}
exports.sortKeys = sortKeys;
// Compare strings
// @internal
function compareStrings(a, b) {
    if (a == b)
        return 0;
    for (let i = 0; i < Math.max(a.length, b.length); i++) {
        if (a.charAt(i) > b.charAt(i))
            return 1;
        if (a.charAt(i) < b.charAt(i))
            return -1;
    }
    if (a.length > b.length)
        return 1;
    return -1;
}
exports.compareStrings = compareStrings;
// @internal
function prepareADR32Data(contents, metadata) {
    return new TextEncoder().encode(JSON.stringify({
        content: contents.sort(sortKeys).map((entry) => ({ key: entry.file, hash: entry.hash })),
        metadata,
    }));
}
exports.prepareADR32Data = prepareADR32Data;
/**
 * Calculates the content hash of multiple files to be used consistently by the builder
 * and other content-based applications when hashes need to be stored on-chain.
 *
 * Returns the CIDv1 of the data prepared to sign
 * @public
 */
async function calculateMultipleHashesADR32(contents, metadata) {
    const data = prepareADR32Data(contents, metadata);
    return {
        data,
        hash: await (0, node_1.hashV1)(data),
    };
}
exports.calculateMultipleHashesADR32 = calculateMultipleHashesADR32;
/**
 * Calculates the content hash of multiple files to be used consistently by the builder
 * and other content-based applications when hashes need to be stored on-chain.
 *
 * @deprecated this is maintained only for compatibility reasons with calculateBufferHash (Qm prefix)
 * @public
 */
async function calculateMultipleHashesADR32LegacyQmHash(contents, metadata) {
    const data = prepareADR32Data(contents, metadata);
    return {
        data,
        hash: await (0, node_1.hashV0)(data),
    };
}
exports.calculateMultipleHashesADR32LegacyQmHash = calculateMultipleHashesADR32LegacyQmHash;
//# sourceMappingURL=ADR32.js.map