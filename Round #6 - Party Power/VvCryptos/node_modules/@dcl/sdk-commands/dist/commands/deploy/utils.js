"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSceneInfo = exports.sceneHasWorldCfg = exports.getAddressAndSignature = exports.getCatalyst = void 0;
const schemas_1 = require("@dcl/schemas");
const dcl_catalyst_client_1 = require("dcl-catalyst-client");
const contracts_snapshots_1 = require("dcl-catalyst-client/dist/contracts-snapshots");
const fetch_component_1 = require("@well-known-components/fetch-component");
const eth_connect_1 = require("eth-connect");
const crypto_1 = require("@dcl/crypto/dist/crypto");
const crypto_2 = require("@dcl/crypto");
const routes_1 = require("../../linker-dapp/routes");
const account_1 = require("../../logic/account");
const config_1 = require("../../logic/config");
const coordinates_1 = require("../../logic/coordinates");
const catalyst_requests_1 = require("../../logic/catalyst-requests");
const run_dapp_1 = require("../../run-dapp");
async function getCatalyst(chainId = schemas_1.ChainId.ETHEREUM_MAINNET, target, targetContent) {
    if (target) {
        const catalyst = (0, dcl_catalyst_client_1.createCatalystClient)({
            url: target.endsWith('/') ? target.slice(0, -1) : target,
            fetcher: (0, fetch_component_1.createFetchComponent)()
        });
        const content = await catalyst.getContentClient();
        const { lambdas: { publicUrl } } = await catalyst.fetchAbout();
        return { client: content, url: publicUrl };
    }
    if (targetContent) {
        return { client: (0, dcl_catalyst_client_1.createContentClient)({ url: targetContent, fetcher: (0, fetch_component_1.createFetchComponent)() }), url: targetContent };
    }
    let catalystClient;
    if (chainId === schemas_1.ChainId.ETHEREUM_SEPOLIA) {
        catalystClient = (0, dcl_catalyst_client_1.createCatalystClient)({ url: 'peer.decentraland.zone', fetcher: (0, fetch_component_1.createFetchComponent)() });
    }
    else {
        const catalysts = (0, contracts_snapshots_1.getCatalystServersFromCache)('mainnet');
        for (const catalyst of catalysts) {
            const client = (0, dcl_catalyst_client_1.createCatalystClient)({ url: catalyst.address, fetcher: (0, fetch_component_1.createFetchComponent)() });
            const isHealthy = (await client.fetchAbout()).healthy;
            if (isHealthy) {
                catalystClient = client;
                break;
            }
        }
    }
    return {
        client: await catalystClient.getContentClient(),
        url: (await catalystClient.fetchAbout()).lambdas.publicUrl
    };
}
exports.getCatalyst = getCatalyst;
async function getAddressAndSignature(components, awaitResponse, messageToSign, scene, files, skipValidations, linkOptions, deployCallback) {
    if (process.env.DCL_PRIVATE_KEY) {
        const wallet = (0, account_1.createWallet)(process.env.DCL_PRIVATE_KEY);
        const authChain = crypto_2.Authenticator.createSimpleAuthChain(messageToSign, wallet.address, (0, crypto_1.ethSign)((0, eth_connect_1.hexToBytes)(wallet.privateKey), messageToSign));
        const linkerResponse = { authChain, address: wallet.address };
        await deployCallback(linkerResponse);
        awaitResponse.resolve();
        return {};
    }
    const sceneInfo = await getSceneInfo(components, scene, messageToSign, skipValidations);
    const { router: commonRouter } = (0, routes_1.setRoutes)(components, sceneInfo);
    const router = setDeployRoutes(commonRouter, components, awaitResponse, sceneInfo, files, deployCallback);
    components.logger.info('You need to sign the content before the deployment:');
    const { program } = await (0, run_dapp_1.runDapp)(components, router, { ...linkOptions, uri: `/` });
    return { program };
}
exports.getAddressAndSignature = getAddressAndSignature;
function setDeployRoutes(router, components, awaitResponse, sceneInfo, files, deployCallback) {
    const { logger } = components;
    // We need to wait so the linker-dapp can receive the response and show a nice message.
    const resolveLinkerPromise = () => setTimeout(() => awaitResponse.resolve(), 100);
    let linkerResponse;
    router.get('/api/files', async () => ({
        body: files.map((file) => ({
            name: file.path,
            size: file.size
        }))
    }));
    router.get('/api/catalyst-pointers', async () => {
        const { x, y } = (0, coordinates_1.getObject)(sceneInfo.baseParcel);
        const pointer = `${x},${y}`;
        const chainId = linkerResponse?.chainId || 1;
        const network = chainId === schemas_1.ChainId.ETHEREUM_MAINNET ? 'mainnet' : 'sepolia';
        const value = await (0, catalyst_requests_1.getPointers)(components, pointer, network);
        const deployedToAll = new Set(value.map((c) => c.entityId)).size === 1;
        // Deployed to every catalyst, close the linker dapp and
        // exit the command automatically so the user dont have to.
        if (deployedToAll)
            resolveLinkerPromise();
        return {
            body: { catalysts: value }
        };
    });
    router.post('/api/deploy', async (ctx) => {
        const value = (await ctx.request.json());
        if (!value.address || !value.authChain || !value.chainId) {
            const errorMessage = `Invalid payload: ${Object.keys(value).join(' - ')}`;
            logger.error(errorMessage);
            resolveLinkerPromise();
            return { status: 400, body: { message: errorMessage } };
        }
        // Store the chainId so we can use it on the catalyst pointers.
        linkerResponse = value;
        try {
            await deployCallback(value);
            // If its a world we dont wait for the catalyst pointers.
            // Close the program.
            if (sceneInfo.isWorld) {
                resolveLinkerPromise();
            }
            return {};
        }
        catch (e) {
            resolveLinkerPromise();
            return { status: 400, body: { message: e.message } };
        }
    });
    return router;
}
function sceneHasWorldCfg(scene) {
    return !!Object.keys(scene.worldConfiguration || {}).length;
}
exports.sceneHasWorldCfg = sceneHasWorldCfg;
async function getSceneInfo(components, scene, rootCID, skipValidations) {
    const { scene: { parcels, base }, display, isPortableExperience } = scene;
    return {
        baseParcel: base,
        parcels,
        rootCID,
        landRegistry: await (0, config_1.getLandRegistry)(components),
        estateRegistry: await (0, config_1.getEstateRegistry)(components),
        debug: !!process.env.DEBUG,
        title: display?.title,
        description: display?.description,
        skipValidations,
        isPortableExperience: !!isPortableExperience,
        isWorld: sceneHasWorldCfg(scene)
    };
}
exports.getSceneInfo = getSceneInfo;
//# sourceMappingURL=utils.js.map