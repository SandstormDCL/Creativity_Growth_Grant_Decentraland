"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setUpManager = exports.createQuestByPrompting = exports.urlRegex = exports.executeSubcommand = void 0;
const fp_future_1 = __importDefault(require("fp-future"));
const crypto_1 = require("@dcl/crypto/dist/crypto");
const eth_connect_1 = require("eth-connect");
const crypto_2 = require("@dcl/crypto");
const path_1 = require("path");
const http_server_1 = require("@well-known-components/http-server");
const utils_1 = require("@dcl/quests-client/dist-cjs/utils");
const prompts_1 = __importDefault(require("prompts"));
const account_1 = require("../../logic/account");
const run_dapp_1 = require("../../run-dapp");
const routes_1 = require("../../linker-dapp/routes");
async function getAddressAndSignature(components, linkerOpts, awaitResponse, info, callback) {
    if (process.env.DCL_PRIVATE_KEY) {
        const wallet = (0, account_1.createWallet)(process.env.DCL_PRIVATE_KEY);
        const authChain = crypto_2.Authenticator.createSimpleAuthChain(info.messageToSign, wallet.address, (0, crypto_1.ethSign)((0, eth_connect_1.hexToBytes)(wallet.privateKey), info.messageToSign));
        const linkerResponse = { authChain, address: wallet.address };
        await callback(linkerResponse);
        awaitResponse.resolve();
        return {};
    }
    const { router } = (0, routes_1.setRoutes)(components, info, '/quests');
    const { logger } = components;
    // We need to wait so the linker-dapp can receive the response and show a nice message.
    const resolveLinkerPromise = () => setTimeout(() => awaitResponse.resolve(), 100);
    router.post('/api/quests', async (ctx) => {
        const value = (await ctx.request.json());
        if (!value.address || !value.authChain) {
            const errorMessage = `Invalid payload: ${Object.keys(value).join(' - ')}`;
            logger.error(errorMessage);
            resolveLinkerPromise();
            return { status: 400, body: { message: errorMessage } };
        }
        try {
            await callback(value);
            resolveLinkerPromise();
            return {};
        }
        catch (e) {
            resolveLinkerPromise();
            return { status: 400, body: { message: e.message } };
        }
    });
    logger.info('You need to sign the request to continue:');
    const { program } = await (0, run_dapp_1.runDapp)(components, router, { ...linkerOpts, uri: `/quests` });
    return { program };
}
async function executeSubcommand(components, linkerOps, commandData, commandCallback) {
    const awaitResponse = (0, fp_future_1.default)();
    const timestamp = String(Date.now());
    const pathname = new URL(commandData.url).pathname;
    const payload = [commandData.method, pathname, timestamp, JSON.stringify(commandData.metadata)]
        .join(':')
        .toLowerCase();
    const { program } = await getAddressAndSignature(components, linkerOps, awaitResponse, { messageToSign: payload, extraData: commandData.extraData, actionType: commandData.actionType }, async (linkerResponse) => {
        await commandCallback(createAuthchainHeaders(linkerResponse.address, linkerResponse.authChain, payload, timestamp, JSON.stringify(commandData.metadata)));
    });
    try {
        await awaitResponse;
    }
    finally {
        void program?.stop();
    }
}
exports.executeSubcommand = executeSubcommand;
exports.urlRegex = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()!@:%_\+.~#?&\/\/=]*)/gm;
const createQuestByPrompting = async (_components) => {
    let cancelled = false;
    const onCancel = {
        onCancel: () => {
            cancelled = true;
        }
    };
    const { questName } = await (0, prompts_1.default)({
        type: 'text',
        name: 'questName',
        message: 'How do you want to name your Quest?',
        validate: (questName) => questName.length >= 5
    }, onCancel);
    if (cancelled)
        return null;
    const { description } = await (0, prompts_1.default)({
        type: 'text',
        name: 'description',
        message: 'Give a description to your Quest',
        validate: (description) => description.length >= 5
    }, onCancel);
    if (cancelled)
        return null;
    const { imageUrl } = await (0, prompts_1.default)({
        type: 'text',
        name: 'imageUrl',
        message: 'Image URL to display your Quest',
        validate: (imageUrl) => new RegExp(exports.urlRegex).test(imageUrl)
    }, onCancel);
    let { definition } = await (0, prompts_1.default)({
        type: 'text',
        name: 'definition',
        message: 'Paste the Defintion (Steps & Connections) of your Quest',
        validate: (def) => {
            try {
                const input = JSON.parse(def);
                (0, utils_1.validateStepsAndConnections)({ definition: input });
                return true;
            }
            catch (error) {
                return false;
            }
        }
    }, onCancel);
    definition = JSON.parse(definition);
    if (cancelled)
        return null;
    const { withReward } = await (0, prompts_1.default)({
        type: 'confirm',
        name: 'withReward',
        message: 'Do you want to give rewards to the players?'
    }, onCancel);
    if (cancelled)
        return null;
    if (!withReward) {
        return { name: questName, description, imageUrl, definition };
    }
    const { webhookUrl } = await (0, prompts_1.default)({
        type: 'text',
        name: 'webhookUrl',
        message: 'Insert the Webhook URL of your Rewards Server',
        validate: (webhookUrl) => new RegExp(exports.urlRegex).test(webhookUrl)
    }, onCancel);
    if (cancelled)
        return null;
    const { withRequestBody } = await (0, prompts_1.default)({
        type: 'confirm',
        name: 'withRequestBody',
        message: 'Do you want to send a request body to your webhook?'
    }, onCancel);
    if (cancelled)
        return null;
    let reqBody = {};
    if (withRequestBody) {
        const { requestBody } = await (0, prompts_1.default)({
            type: 'text',
            name: 'requestBody',
            message: 'Insert the request body to send within POST request to your webhook',
            validate: (body) => {
                try {
                    JSON.parse(body);
                    return true;
                }
                catch (error) {
                    return false;
                }
            }
        }, onCancel);
        if (cancelled)
            return null;
        reqBody = JSON.parse(requestBody);
    }
    const { rewardItemsNumber } = await (0, prompts_1.default)({
        type: 'number',
        name: 'rewardItemsNumber',
        message: 'How many items the user will receive?',
        validate: (num) => num > 0
    }, onCancel);
    if (cancelled)
        return null;
    const items = [];
    for (let i = 1; i < rewardItemsNumber + 1; i++) {
        const { itemName } = await (0, prompts_1.default)({
            type: 'text',
            name: 'itemName',
            message: `What is the name of your ${i} reward?`,
            validate: (name) => name.length >= 3
        }, onCancel);
        if (cancelled)
            return null;
        const { itemImage } = await (0, prompts_1.default)({
            type: 'text',
            name: 'itemImage',
            message: `Provide an image link for your ${i} reward`,
            validate: (image) => new RegExp(exports.urlRegex).test(image)
        }, onCancel);
        if (cancelled)
            return null;
        items.push({ name: itemName, imageLink: itemImage });
    }
    return {
        name: questName,
        description,
        imageUrl,
        definition,
        reward: {
            hook: {
                webhookUrl: webhookUrl,
                requestBody: Object.keys(reqBody).length >= 1 ? reqBody : undefined
            },
            items
        }
    };
};
exports.createQuestByPrompting = createQuestByPrompting;
const AUTH_CHAIN_HEADER_PREFIX = 'x-identity-auth-chain-';
const AUTH_TIMESTAMP_HEADER = 'x-identity-timestamp';
const AUTH_METADATA_HEADER = 'x-identity-metadata';
function createAuthchainHeaders(address, authchain, payload, timestamp, metadata) {
    const headers = {};
    authchain.forEach((link, i) => {
        headers[AUTH_CHAIN_HEADER_PREFIX + i] = JSON.stringify(link);
    });
    headers[AUTH_TIMESTAMP_HEADER] = timestamp;
    headers[AUTH_METADATA_HEADER] = metadata;
    return headers;
}
const setUpManager = (components) => {
    const { fs } = components;
    const router = new http_server_1.Router();
    const questsManager = (0, path_1.dirname)(require.resolve('@dcl/quests-manager/package.json'));
    router.get('/', async () => {
        return {
            headers: { 'Content-Type': 'text/html' },
            body: fs.createReadStream((0, path_1.resolve)(questsManager, 'index.html'))
        };
    });
    router.get('/design/create', async () => ({
        headers: { 'Content-Type': 'text/html' },
        body: fs.createReadStream((0, path_1.resolve)(questsManager, 'index.html'))
    }));
    router.get('/quests/:id', async () => ({
        headers: { 'Content-Type': 'text/html' },
        body: fs.createReadStream((0, path_1.resolve)(questsManager, 'index.html'))
    }));
    router.get('/quests/drafts/:id', async () => ({
        headers: { 'Content-Type': 'text/html' },
        body: fs.createReadStream((0, path_1.resolve)(questsManager, 'index.html'))
    }));
    router.get('/quests/old/:id', async () => ({
        headers: { 'Content-Type': 'text/html' },
        body: fs.createReadStream((0, path_1.resolve)(questsManager, 'index.html'))
    }));
    router.get('/:path*', async (ctx) => {
        return {
            body: fs.createReadStream((0, path_1.resolve)(questsManager, ctx.params.path))
        };
    });
    return { router };
};
exports.setUpManager = setUpManager;
//# sourceMappingURL=utils.js.map