"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wireRouter = exports.sceneUpdateClients = void 0;
const http_server_1 = require("@well-known-components/http-server");
const ws_1 = require("@well-known-components/http-server/dist/ws");
const ws_2 = require("../data-layer/ws");
const endpoints_1 = require("./endpoints");
const realm_1 = require("./realm");
exports.sceneUpdateClients = new Set();
async function wireRouter(components, workspace, dataLayer) {
    const router = new http_server_1.Router();
    if (dataLayer) {
        router.get('/data-layer', async (ctx, next) => {
            if (ctx.request.headers.get('upgrade') === 'websocket') {
                return (0, ws_1.upgradeWebSocketResponse)((ws) => (0, ws_2.handleDataLayerWs)(components, ws, dataLayer));
            }
            return next();
        });
    }
    router.get('/', async (ctx, next) => {
        if (ctx.request.headers.get('upgrade') === 'websocket') {
            return (0, ws_1.upgradeWebSocketResponse)((ws) => initWsConnection(ws, exports.sceneUpdateClients));
        }
        return next();
    });
    const localSceneParcels = [];
    for (const project of workspace.projects) {
        for (const parcel of project.scene.scene.parcels) {
            localSceneParcels.push(parcel);
        }
    }
    (0, realm_1.setupRealmAndComms)(components, router, localSceneParcels);
    await (0, endpoints_1.setupEcs6Endpoints)(components, router, workspace);
    components.server.setContext(components);
    components.server.use(router.allowedMethods());
    components.server.use(router.middleware());
}
exports.wireRouter = wireRouter;
const initWsConnection = (ws, clients) => {
    if (ws.readyState === ws.OPEN) {
        clients.add(ws);
    }
    else {
        ws.on('open', () => clients.add(ws));
    }
    ws.on('close', () => clients.delete(ws));
};
//# sourceMappingURL=routes.js.map