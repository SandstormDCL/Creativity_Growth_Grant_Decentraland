"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.__LEGACY__updateScene = exports.wireFileWatcherToWebSockets = void 0;
const schemas_1 = require("@dcl/schemas");
const path_1 = __importDefault(require("path"));
const ws_1 = require("ws");
const chokidar_1 = __importDefault(require("chokidar"));
const dcl_ignore_1 = require("../../../logic/dcl-ignore");
const routes_1 = require("./routes");
const project_files_1 = require("../../../logic/project-files");
const local_development_gen_1 = require("@dcl/protocol/out-js/decentraland/sdk/development/local_development.gen");
function debounce(callback, delay) {
    let debounceTimer;
    return (...args) => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => callback(...args), delay);
    };
}
/**
 * This function gets file modification events and sends them to all the connected
 * websockets, it is used to hot-reload assets of the scene.
 *
 * IMPORTANT: this is a legacy protocol and needs to be revisited for SDK7
 */
async function wireFileWatcherToWebSockets(components, projectRoot, projectKind, desktopClient) {
    const ignored = await (0, dcl_ignore_1.getDCLIgnorePatterns)(components, projectRoot);
    const sceneId = (0, project_files_1.b64HashingFunction)(projectRoot);
    chokidar_1.default
        .watch(path_1.default.resolve(projectRoot), {
        atomic: false,
        ignored,
        ignoreInitial: false,
        cwd: projectRoot
    })
        .on('unlink', (_, file) => {
        if (desktopClient) {
            return removeModel(sceneId, file);
        }
    })
        .on('all', debounce(async (a, file) => {
        if (desktopClient) {
            updateScene(sceneId, file);
        }
        return __LEGACY__updateScene(projectRoot, routes_1.sceneUpdateClients, projectKind);
    }, 500));
}
exports.wireFileWatcherToWebSockets = wireFileWatcherToWebSockets;
function isGLTFModel(file) {
    if (!file)
        return false;
    return file.toLowerCase().endsWith('.glb') || file.toLowerCase().endsWith('.gltf');
}
function updateScene(sceneId, file) {
    let message;
    if (isGLTFModel(file)) {
        message = {
            $case: 'updateModel',
            updateModel: { hash: (0, project_files_1.b64HashingFunction)(file), sceneId, src: file, type: local_development_gen_1.UpdateModelType.UMT_CHANGE }
        };
    }
    else {
        message = {
            $case: 'updateScene',
            updateScene: { sceneId }
        };
    }
    sendSceneMessage({ message });
}
function removeModel(sceneId, file) {
    if (isGLTFModel(file)) {
        const sceneMessage = {
            message: {
                $case: 'updateModel',
                updateModel: { sceneId, src: file, hash: (0, project_files_1.b64HashingFunction)(file), type: local_development_gen_1.UpdateModelType.UMT_REMOVE }
            }
        };
        sendSceneMessage(sceneMessage);
    }
}
function sendSceneMessage(sceneMessage) {
    const message = local_development_gen_1.WsSceneMessage.encode(sceneMessage).finish();
    for (const client of routes_1.sceneUpdateClients) {
        if (client.readyState === ws_1.WebSocket.OPEN) {
            client.send(message, { binary: true });
        }
    }
}
/**
 * @deprecated old explorer (kernel)
 */
function __LEGACY__updateScene(dir, clients, projectKind) {
    for (const client of clients) {
        if (client.readyState === ws_1.WebSocket.OPEN) {
            const message = {
                type: schemas_1.sdk.SCENE_UPDATE,
                payload: { sceneId: (0, project_files_1.b64HashingFunction)(dir), sceneType: projectKind }
            };
            // Old explorer
            client.send(schemas_1.sdk.UPDATE, { binary: false });
            client.send(JSON.stringify(message), { binary: false });
        }
    }
}
exports.__LEGACY__updateScene = __LEGACY__updateScene;
//# sourceMappingURL=file-watch-notifier.js.map