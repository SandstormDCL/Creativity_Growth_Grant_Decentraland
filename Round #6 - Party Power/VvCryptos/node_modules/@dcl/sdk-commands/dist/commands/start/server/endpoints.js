"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupEcs6Endpoints = void 0;
const path = __importStar(require("path"));
const sdk_1 = require("@dcl/schemas/dist/sdk");
const schemas_1 = require("@dcl/schemas");
const node_fetch_1 = __importStar(require("node-fetch"));
const uuid_1 = require("uuid");
const catalyst_requests_1 = require("../../../logic/catalyst-requests");
const project_files_1 = require("../../../logic/project-files");
const config_1 = require("../../../logic/config");
async function setupEcs6Endpoints(components, router, workspace) {
    const catalystUrl = new URL(await (0, config_1.getCatalystBaseUrl)(components));
    // handle old preview scene.json DEPRECATED
    router.get('/scene.json', async () => {
        return {
            headers: { 'content-type': 'application/json' },
            body: components.fs.createReadStream(path.join(workspace.projects[0].workingDirectory, 'scene.json'))
        };
    });
    router.get('/lambdas/explore/realms', async (ctx) => {
        return {
            body: [
                {
                    serverName: 'localhost',
                    url: `http://${ctx.url.host}`,
                    layer: 'stub',
                    usersCount: 0,
                    maxUsers: 100,
                    userParcels: []
                }
            ]
        };
    });
    router.get('/lambdas/contracts/servers', async (ctx) => {
        return {
            body: [
                {
                    address: `http://${ctx.url.host}`,
                    owner: '0x0000000000000000000000000000000000000000',
                    id: '0x0000000000000000000000000000000000000000000000000000000000000000'
                }
            ]
        };
    });
    router.get('/lambdas/profiles', async (ctx, next) => {
        const baseUrl = `${ctx.url.protocol}//${ctx.url.host}/content/contents`;
        try {
            const previewWearables = await getAllPreviewWearables(components, workspace, {
                baseUrl
            });
            if (previewWearables.length === 1) {
                const u = new URL(ctx.url.toString());
                u.host = catalystUrl.host;
                u.protocol = catalystUrl.protocol;
                u.port = catalystUrl.port;
                const req = await (0, node_fetch_1.default)(u.toString(), {
                    headers: {
                        connection: 'close'
                    },
                    method: ctx.request.method,
                    body: ctx.request.method === 'get' ? undefined : ctx.request.body
                });
                const deployedProfile = (await req.json());
                if (deployedProfile?.length === 1) {
                    deployedProfile[0].avatars[0].avatar.wearables.push(...previewWearables.map(($) => $.id));
                    return {
                        headers: {
                            'content-type': req.headers.get('content-type') || 'application/binary'
                        },
                        body: deployedProfile
                    };
                }
            }
        }
        catch (err) {
            components.logger.warn(`Failed to catch profile and fill with preview wearables.`);
            components.logger.error(err);
        }
        return next();
    });
    router.all('/lambdas/:path+', async (ctx) => {
        const u = new URL(ctx.url.toString());
        u.host = catalystUrl.host;
        u.protocol = catalystUrl.protocol;
        u.port = catalystUrl.port;
        const req = await (0, node_fetch_1.default)(u.toString(), {
            headers: {
                connection: 'close'
            },
            method: ctx.request.method,
            body: ctx.request.method === 'get' ? undefined : ctx.request.body
        });
        return {
            headers: {
                'content-type': req.headers.get('content-type') || 'application/binary'
            },
            body: req.body
        };
    });
    router.post('/content/entities', async (ctx) => {
        const headers = new node_fetch_1.Headers();
        const res = await (0, node_fetch_1.default)(`${catalystUrl.toString()}/content/entities`, {
            method: 'post',
            headers,
            body: ctx.request.body
        });
        return res;
    });
    serveStatic(components, workspace, router);
    // TODO: get workspace scenes & wearables...
    await serveFolders(components, router, workspace);
}
exports.setupEcs6Endpoints = setupEcs6Endpoints;
async function serveFolders(components, router, workspace) {
    const catalystUrl = await (0, config_1.getCatalystBaseUrl)(components);
    router.get('/content/contents/:hash', async (ctx, next) => {
        if (ctx.params.hash && ctx.params.hash.startsWith('b64-')) {
            const fullPath = path.resolve(Buffer.from(ctx.params.hash.replace(/^b64-/, ''), 'base64').toString('utf8'));
            // find a project that we are talking about. NOTE: this filter is not exhaustive
            //   relative paths should be used instead
            const baseProject = workspace.projects.find((project) => fullPath.startsWith(project.workingDirectory));
            // only return files IF the file is within a baseFolder
            if (!baseProject) {
                return next();
            }
            if (path.resolve(fullPath) === path.resolve(baseProject.workingDirectory)) {
                // if we are talking about the root directory, then we must return the json of the entity
                const entity = await fakeEntityV3FromProject(components, baseProject, async ($) => (0, project_files_1.b64HashingFunction)($));
                if (!entity)
                    return { status: 404 };
                return {
                    headers: {
                        'x-timestamp': Date.now().toString(),
                        'x-sent': 'true',
                        'cache-control': 'no-cache,private,max-age=1'
                    },
                    body: entity
                };
            }
            if (!(await components.fs.fileExists(fullPath)))
                return { status: 404 };
            if (await components.fs.directoryExists(fullPath))
                return { status: 404 };
            return {
                headers: {
                    'x-timestamp': Date.now().toString(),
                    'x-sent': 'true',
                    'cache-control': 'no-cache,private,max-age=1'
                },
                body: components.fs.createReadStream(fullPath)
            };
        }
        return next();
    });
    async function pointerRequestHandler(pointers) {
        if (!pointers || pointers.length === 0) {
            return [];
        }
        const requestedPointers = new Set(pointers && typeof pointers === 'string' ? [pointers] : pointers);
        const resultEntities = await getSceneJson(components, workspace, Array.from(requestedPointers));
        const remote = await (0, catalyst_requests_1.fetchEntityByPointer)(components, catalystUrl.toString(), pointers.filter(($) => !$.match(/-?\d+,-?\d+/)));
        const serverEntities = Array.isArray(remote.deployments) ? remote.deployments : [];
        return [...resultEntities, ...serverEntities];
    }
    // REVIEW RESPONSE FORMAT
    router.get('/content/entities/scene', async (ctx) => {
        return {
            body: await pointerRequestHandler(ctx.url.searchParams.getAll('pointer'))
        };
    });
    // REVIEW RESPONSE FORMAT
    router.post('/content/entities/active', async (ctx) => {
        const body = await ctx.request.json();
        return {
            body: await pointerRequestHandler(body.pointers)
        };
    });
    router.get('/preview-wearables/:id', async (ctx) => {
        const baseUrl = `${ctx.url.protocol}//${ctx.url.host}/content/contents`;
        const wearables = await getAllPreviewWearables(components, workspace, {
            baseUrl
        });
        const wearableId = ctx.params.id;
        return {
            body: {
                ok: true,
                data: wearables.filter((wearable) => wearable.id === wearableCache.get(wearableId))
            }
        };
    });
    router.get('/preview-wearables', async (ctx) => {
        const baseUrl = `${ctx.url.protocol}//${ctx.url.host}/content/contents`;
        return {
            body: {
                ok: true,
                data: await getAllPreviewWearables(components, workspace, { baseUrl })
            }
        };
    });
}
async function getAllPreviewWearables(components, workspace, { baseUrl }) {
    // NOTE: the explorers should use the /entities/active endpoint to retrieve the wearables. This endpoint should be removed
    const wearablePathArray = [];
    for (const project of workspace.projects) {
        if (project.kind === 'smart-wearable') {
            const wearableJsonPath = path.resolve(project.workingDirectory, 'wearable.json');
            if (await components.fs.fileExists(wearableJsonPath)) {
                wearablePathArray.push(wearableJsonPath);
            }
        }
    }
    const ret = [];
    for (const project of workspace.projects) {
        try {
            if (project.kind === 'smart-wearable')
                ret.push(await serveWearable(components, project, baseUrl));
        }
        catch (err) {
            components.logger.error(`Couldn't mock the wearable ${project.workingDirectory}. Please verify the correct format and scheme.` + err);
        }
    }
    return ret;
}
const wearableCache = new Map();
async function serveWearable(components, project, baseUrl) {
    const wearableJsonPath = path.join(project.workingDirectory, 'wearable.json');
    const wearableJson = JSON.parse((await components.fs.readFile(wearableJsonPath)).toString());
    if (!sdk_1.WearableJson.validate(wearableJson)) {
        const errors = (sdk_1.WearableJson.validate.errors || []).map((a) => `${a.data} ${a.message}`).join('');
        components.logger.error(`Unable to validate wearable.json properly, please check it.` + errors);
        throw new Error(`Invalid wearable.json (${wearableJsonPath})`);
    }
    const projectFiles = await (0, project_files_1.getProjectPublishableFilesWithHashes)(components, project.workingDirectory, async ($) => (0, project_files_1.b64HashingFunction)($));
    const contentFiles = (0, project_files_1.projectFilesToContentMappings)(project.workingDirectory, projectFiles);
    const thumbnailFiltered = contentFiles.filter(($) => $.file === 'thumbnail.png');
    const thumbnail = thumbnailFiltered.length > 0 && thumbnailFiltered[0].hash && `${baseUrl}/${thumbnailFiltered[0].hash}`;
    // Set wearable ID.
    const sceneHash = (0, project_files_1.b64HashingFunction)(project.workingDirectory);
    const wearableId = wearableCache.get(sceneHash) ?? `urn:${(0, uuid_1.v4)()}`;
    wearableCache.set(sceneHash, wearableId);
    const representations = wearableJson.data.representations.map((representation) => ({
        ...representation,
        mainFile: `male/${representation.mainFile}`,
        contents: contentFiles.map(($) => ({
            key: `male/${$?.file}`,
            url: `${baseUrl}/${$?.hash}`,
            hash: $?.hash
        }))
    }));
    return {
        id: wearableId,
        rarity: wearableJson.rarity,
        i18n: [{ code: 'en', text: wearableJson.name }],
        description: wearableJson.description,
        thumbnail: thumbnail || '',
        image: thumbnail || '',
        collectionAddress: '0x0',
        baseUrl: `${baseUrl}/`,
        name: wearableJson.name || '',
        data: {
            category: wearableJson.data.category,
            replaces: [],
            hides: [],
            tags: [],
            representations: representations
            // scene: hashedFiles as any,
        }
    };
}
async function getSceneJson(components, workspace, pointers) {
    const requestedPointers = new Set(pointers);
    const resultEntities = [];
    const allDeployments = await Promise.all(workspace.projects.map((project) => fakeEntityV3FromProject(components, project, async ($) => (0, project_files_1.b64HashingFunction)($))));
    for (const pointer of Array.from(requestedPointers)) {
        // get deployment by pointer
        const theDeployment = allDeployments.find(($) => $ && $.pointers.includes(pointer));
        if (theDeployment) {
            // remove all the required pointers from the requestedPointers set
            // to prevent sending duplicated entities
            theDeployment.pointers.forEach(($) => requestedPointers.delete($));
            // add the deployment to the results
            resultEntities.push(theDeployment);
        }
    }
    return resultEntities;
}
function serveStatic(components, workspace, router) {
    const sdkPath = path.dirname(require.resolve('@dcl/sdk/package.json', {
        paths: [workspace.rootWorkingDirectory, ...workspace.projects.map(($) => $.workingDirectory)]
    }));
    const dclExplorerJsonPath = path.dirname(require.resolve('@dcl/explorer/package.json', {
        paths: [workspace.rootWorkingDirectory, ...workspace.projects.map(($) => $.workingDirectory), sdkPath]
    }));
    const dclKernelDefaultProfilePath = path.resolve(dclExplorerJsonPath, 'default-profile');
    const dclKernelImagesDecentralandConnect = path.resolve(dclExplorerJsonPath, 'images', 'decentraland-connect');
    const routes = [
        {
            route: '/',
            path: path.resolve(dclExplorerJsonPath, 'preview.html'),
            type: 'text/html'
        },
        {
            route: '/favicon.ico',
            path: path.resolve(dclExplorerJsonPath, 'favicon.ico'),
            type: 'text/html'
        },
        {
            route: '/@/explorer/index.js',
            path: path.resolve(dclExplorerJsonPath, 'index.js'),
            type: 'text/javascript'
        }
    ];
    for (const route of routes) {
        router.get(route.route, async (_ctx) => {
            return {
                headers: { 'Content-Type': route.type },
                body: components.fs.createReadStream(route.path)
            };
        });
    }
    function createStaticRoutes(components, route, folder, transform = (str) => str) {
        router.get(route, async (ctx, next) => {
            const file = ctx.params.path;
            const fullPath = path.resolve(folder, transform(file));
            // only return files IF the file is within a baseFolder
            if (!(await components.fs.fileExists(fullPath))) {
                return next();
            }
            if (await components.fs.directoryExists(fullPath)) {
                return { status: 404 };
            }
            const headers = {
                'x-timestamp': Date.now(),
                'x-sent': true,
                'cache-control': 'no-cache,private,max-age=1'
            };
            if (fullPath.endsWith('.wasm')) {
                headers['content-type'] = 'application/wasm';
            }
            return {
                headers,
                body: components.fs.createReadStream(fullPath)
            };
        });
    }
    createStaticRoutes(components, '/images/decentraland-connect/:path+', dclKernelImagesDecentralandConnect);
    createStaticRoutes(components, '/default-profile/:path+', dclKernelDefaultProfilePath);
    createStaticRoutes(components, '/@/explorer/:path+', dclExplorerJsonPath, (filePath) => filePath.replace(/.br+$/, ''));
    router.get('/feature-flags/:file', async (ctx) => {
        const res = await (0, node_fetch_1.default)(`https://feature-flags.decentraland.zone/${ctx.params.file}`, {
            headers: {
                connection: 'close'
            }
        });
        return {
            body: await res.arrayBuffer()
        };
    });
}
async function fakeEntityV3FromProject(components, project, hashingFunction) {
    const projectFiles = await (0, project_files_1.getProjectPublishableFilesWithHashes)(components, project.workingDirectory, hashingFunction);
    const contentFiles = (0, project_files_1.projectFilesToContentMappings)(project.workingDirectory, projectFiles);
    if (project.kind === 'scene') {
        const sceneJsonPath = path.resolve(project.workingDirectory, 'scene.json');
        const sceneJson = JSON.parse(await components.fs.readFile(sceneJsonPath, 'utf-8'));
        const { base, parcels } = sceneJson.scene;
        const pointers = new Set();
        pointers.add(base);
        parcels.forEach(($) => pointers.add($));
        return {
            version: 'v3',
            type: schemas_1.EntityType.SCENE,
            id: await hashingFunction(project.workingDirectory),
            pointers: Array.from(pointers),
            timestamp: Date.now(),
            metadata: sceneJson,
            content: contentFiles
        };
    }
    else if (project.kind === 'smart-wearable') {
        const wearableJsonPath = path.resolve(project.workingDirectory, 'wearable.json');
        try {
            const wearableJson = JSON.parse(await components.fs.readFile(wearableJsonPath, 'utf-8'));
            if (!sdk_1.WearableJson.validate(wearableJson)) {
                const errors = (sdk_1.WearableJson.validate.errors || []).map((a) => `${a.data} ${a.message}`).join('');
                components.logger.error(`Unable to validate wearable.json properly, please check its schema.` + errors);
                components.logger.error(`Invalid wearable.json (${wearableJsonPath})`);
            }
            return {
                version: 'v3',
                type: schemas_1.EntityType.WEARABLE,
                id: await hashingFunction(project.workingDirectory),
                pointers: Array.from([await hashingFunction(project.workingDirectory)]),
                timestamp: Date.now(),
                metadata: wearableJson,
                content: contentFiles
            };
        }
        catch (err) {
            components.logger.error(`Unable to load wearable.json`);
            components.logger.error(err);
        }
    }
    return null;
}
//# sourceMappingURL=endpoints.js.map