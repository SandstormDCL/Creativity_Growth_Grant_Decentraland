"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareSceneFiles = exports.main = exports.help = exports.args = void 0;
const path_1 = __importDefault(require("path"));
const args_1 = require("../../logic/args");
const hashing_1 = require("@dcl/hashing");
const project_files_1 = require("../../logic/project-files");
const error_1 = require("../../logic/error");
const schemas_1 = require("@dcl/schemas");
const log_1 = require("../../components/log");
const beautiful_logs_1 = require("../../logic/beautiful-logs");
const realm_1 = require("../../logic/realm");
const scene_validations_1 = require("../../logic/scene-validations");
const workspace_validations_1 = require("../../logic/workspace-validations");
exports.args = (0, args_1.declareArgs)({
    '--dir': String,
    '--destination': String,
    '--timestamp': String,
    '--realmName': String,
    '--commsAdapter': String,
    '--baseUrl': String
});
async function help(options) {
    options.components.logger.log(`
  Usage:
    sdk-commands export-static --dir <directory> --destination <directory>

  Description:

    Exports all the contents of the scene as if they were uploaded to a content server

  Options:

    --dir <directory>         The project's root folder to export
    --destination <directory> A path in which all the assets will be stored
    --timestamp <timestamp>   A date to use in the deployable entity. Defaults to now()
    --realmName <name>        Creates a /<name>/about endpoint to expose the current deployment as a realm. Requires --baseUrl
    --commsAdapter <url>      URL of the communications adapter (https://adr.decentraland.org/adr/ADR-180)
    --baseUrl <baseUrl>       It is the public URL in which the --destination directory will be avaiable
`);
}
exports.help = help;
async function main(options) {
    const { fs, logger } = options.components;
    const workingDirectory = path_1.default.resolve(process.cwd(), options.args['--dir'] || '.');
    const outputDirectory = path_1.default.resolve(process.cwd(), options.args['--destination'] || '.');
    const willCreateRealm = !!options.args['--realmName'];
    const commsAdapter = options.args['--commsAdapter'] ?? 'offline:offline';
    let currentStep = 1;
    const maxSteps = 1 + (willCreateRealm ? 1 : 0);
    /* istanbul ignore if */
    if (willCreateRealm && !options.args['--baseUrl']) {
        throw new error_1.CliError(`--baseUrl is mandatory when --realmName is provided`);
    }
    /* istanbul ignore if */
    if (willCreateRealm && !/^[a-z][a-z0-9-/]*$/i.test(options.args['--realmName'])) {
        throw new error_1.CliError(`--realmName has invalid characters`);
    }
    await fs.mkdir(outputDirectory, { recursive: true });
    /* istanbul ignore if */
    if (!(await fs.directoryExists(outputDirectory))) {
        throw new error_1.CliError(`The destination path ${outputDirectory} is not a directory`);
    }
    const scenesUrn = [];
    const entities = [];
    const workspace = await (0, workspace_validations_1.getValidWorkspace)(options.components, workingDirectory);
    (0, beautiful_logs_1.printProgressStep)(logger, `Exporting ${workspace.projects.length} project(s)`, currentStep++, maxSteps);
    for (const project of workspace.projects) {
        (0, beautiful_logs_1.printCurrentProjectStarting)(options.components.logger, project, workspace);
        if (project.kind === 'scene') {
            const result = await prepareSceneFiles(options, project, outputDirectory);
            scenesUrn.push(result.urn);
            entities.push(result.entityId);
        }
    }
    if (willCreateRealm) {
        // prepare the realm object
        (0, beautiful_logs_1.printProgressStep)(logger, 'Creating realm file...', currentStep++, maxSteps);
        const realm = await (0, realm_1.createStaticRealm)(options.components);
        const realmName = options.args['--realmName'];
        realm.configurations.scenesUrn = scenesUrn;
        realm.configurations.realmName = realmName;
        if (realm.comms) {
            realm.comms.fixedAdapter = commsAdapter;
        }
        // write the realm file
        const realmDirectory = path_1.default.join(outputDirectory, realmName);
        await fs.mkdir(realmDirectory, { recursive: true });
        /* istanbul ignore if */
        if (!(await fs.directoryExists(realmDirectory))) {
            throw new error_1.CliError(`The destination path ${realmDirectory} is not a directory`);
        }
        const dst = path_1.default.join(realmDirectory, 'about');
        await fs.writeFile(dst, JSON.stringify(realm, null, 2));
        (0, beautiful_logs_1.printProgressInfo)(logger, `> ${realmName}/about ← [REALM FILE]`);
    }
    (0, beautiful_logs_1.printSuccess)(logger, `Export finished!`, `=> The entity URN are:${log_1.colors.bold(scenesUrn.map(($) => '\n - ' + $).join(''))}`);
    return { scenesUrn, destination: outputDirectory, entities };
}
exports.main = main;
async function prepareSceneFiles(options, project, outputDirectory) {
    const { fs, logger } = options.components;
    const filesToExport = await (0, project_files_1.getProjectPublishableFilesWithHashes)(options.components, project.workingDirectory, async (file) => {
        return await (0, hashing_1.hashV1)(fs.createReadStream(path_1.default.resolve(project.workingDirectory, file)));
    });
    (0, beautiful_logs_1.printStep)(logger, 'Exporting static project');
    for (const { absolutePath, hash } of filesToExport) {
        const dst = path_1.default.resolve(outputDirectory, hash);
        /* istanbul ignore if */
        if (absolutePath.startsWith(outputDirectory)) {
            (0, beautiful_logs_1.printWarning)(options.components.logger, `The file ${absolutePath} was omitted because it overwrites an input directory`);
            continue;
        }
        (0, beautiful_logs_1.printProgressInfo)(logger, `> ${hash} ← ${log_1.colors.reset(absolutePath)}`);
        if (!(await fs.fileExists(dst))) {
            const content = await fs.readFile(absolutePath);
            await fs.writeFile(dst, content);
        }
    }
    // entity with ID are the deployed ones, when we generate the entity the ID is not
    // available because it is the result of hashing the following structure
    const entity = {
        content: (0, project_files_1.projectFilesToContentMappings)(project.workingDirectory, filesToExport),
        pointers: [],
        timestamp: options.args['--timestamp'] ? new Date(options.args['--timestamp']).getTime() : Date.now(),
        type: schemas_1.EntityType.SCENE,
        // for now, the only valid export is for scenes
        metadata: project.scene,
        version: 'v3'
    };
    // create the entity file and get the entityId
    const entityRaw = Buffer.from(JSON.stringify(entity), 'utf8');
    const entityId = await (0, hashing_1.hashV1)(entityRaw);
    const dst = path_1.default.resolve(outputDirectory, entityId);
    await fs.writeFile(dst, entityRaw);
    (0, beautiful_logs_1.printStep)(logger, `> ${entityId} ← ${log_1.colors.reset('[ENTITY FILE]')}`);
    let urn = `urn:decentraland:entity:${entityId}`;
    if (options.args['--baseUrl']) {
        urn += '?=&baseUrl=' + options.args['--baseUrl'];
        // baseUrl must end with /
        if (!urn.endsWith('/'))
            urn += '/';
    }
    options.components.analytics.track('Export static', {
        projectHash: await (0, project_files_1.b64HashingFunction)(project.workingDirectory),
        coords: (0, scene_validations_1.getBaseCoords)(project.scene)
    });
    return { urn, entityId, destination: outputDirectory };
}
exports.prepareSceneFiles = prepareSceneFiles;
//# sourceMappingURL=index.js.map