"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.packSmartWearable = exports.main = exports.help = exports.args = void 0;
const path_1 = __importDefault(require("path"));
const archiver_1 = __importDefault(require("archiver"));
const args_1 = require("../../logic/args");
const project_validations_1 = require("../../logic/project-validations");
const project_files_1 = require("../../logic/project-files");
const beautiful_logs_1 = require("../../logic/beautiful-logs");
const workspace_validations_1 = require("../../logic/workspace-validations");
const build_1 = require("../build");
exports.args = (0, args_1.declareArgs)({
    '--skip-build': Boolean,
    '--skip-install': Boolean,
    '--dir': String
});
function help(options) {
    options.components.logger.log(`
  Usage: 'sdk-commands pack-smart-wearable [options]'
    Options:'
      -h, --help                Displays complete help
      --skip-build              Skip build and use the file defined in scene.json
      --skip-install            Skip installing dependencies
      --dir                     Path to directory to build

    Example:
    - Pack your smart-wearable scene:
      '$ sdk-commands pack-smart-wearable'
  `);
}
exports.help = help;
async function main(options) {
    const workingDirectory = path_1.default.resolve(process.cwd(), options.args['--dir'] || '.');
    const workspace = await (0, workspace_validations_1.getValidWorkspace)(options.components, workingDirectory);
    for (const project of workspace.projects) {
        (0, beautiful_logs_1.printCurrentProjectStarting)(options.components.logger, project, workspace);
        if (project.kind === 'smart-wearable') {
            await packSmartWearable(options, project);
        }
    }
}
exports.main = main;
async function packSmartWearable(options, project) {
    const shouldInstallDeps = !options.args['--skip-install'] && (await (0, project_validations_1.needsDependencies)(options.components, project.workingDirectory));
    const shouldBuild = !options.args['--skip-build'];
    if (shouldInstallDeps && !options.args['--skip-install']) {
        await (0, project_validations_1.installDependencies)(options.components, project.workingDirectory);
    }
    if (shouldBuild) {
        await (0, build_1.buildScene)({ ...options, args: { '--dir': project.workingDirectory, _: [], '--production': true } }, project);
    }
    const files = await (0, project_files_1.getProjectPublishableFilesWithHashes)(options.components, project.workingDirectory, async ($) => $);
    let totalSize = 0;
    for (const filePath of files) {
        const stat = await options.components.fs.stat(filePath.absolutePath);
        if (stat.isFile()) {
            totalSize += stat.size;
        }
    }
    const MAX_WEARABLE_SIZE = 2097152;
    if (totalSize > MAX_WEARABLE_SIZE) {
        options.components.logger.info(`Smart Wearable max size (${MAX_WEARABLE_SIZE} bytes) reached: ${totalSize} bytes.
Please try to remove unneccessary files and/or reduce the files size, you can ignore file adding in .dclignore.`);
    }
    const ZIP_FILE_NAME = 'smart-wearable.zip';
    const packDir = path_1.default.resolve(project.workingDirectory, ZIP_FILE_NAME);
    if (await options.components.fs.fileExists(packDir)) {
        await options.components.fs.rm(packDir);
    }
    options.components.logger.info(packDir);
    try {
        await zipProject(options.components.fs, files.map(($) => $.absolutePath.replace(project.workingDirectory + path_1.default.sep, '')), packDir);
    }
    catch (e) {
        options.components.logger.error('Error creating zip file', e.message);
    }
    options.components.analytics.track('Pack smart wearable', {
        projectHash: await (0, project_files_1.b64HashingFunction)(project.workingDirectory)
    });
    options.components.logger.log('Smart wearable packed successfully.');
}
exports.packSmartWearable = packSmartWearable;
function zipProject(fs, files, target) {
    const output = fs.createWriteStream(target);
    const archive = (0, archiver_1.default)('zip');
    return new Promise((resolve, reject) => {
        output.on('close', () => {
            resolve();
        });
        archive.on('warning', (err) => {
            reject(err);
        });
        archive.on('error', (err) => {
            reject(err);
        });
        archive.pipe(output);
        for (const file of files) {
            if (file === '')
                continue;
            archive.file(file, { name: file });
        }
        return archive.finalize();
    });
}
//# sourceMappingURL=index.js.map