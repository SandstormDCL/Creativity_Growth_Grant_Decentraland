"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadAndUnzipUrlContainFolder = exports.main = exports.help = exports.args = void 0;
const path_1 = __importDefault(require("path"));
const args_1 = require("../../logic/args");
const error_1 = require("../../logic/error");
const fs_1 = require("../../logic/fs");
const project_validations_1 = require("../../logic/project-validations");
const repos_1 = require("./repos");
const project_1 = require("./project");
const download_github_folder_1 = require("./download-github-folder");
exports.args = (0, args_1.declareArgs)({
    '--yes': Boolean,
    '-y': '--yes',
    '--dir': String,
    '--skip-install': Boolean,
    '--template': String,
    '--project': String,
    '--github-repo': String
});
function help(options) {
    options.components.logger.log(`
  Usage: 'sdk-commands init [options]'
    Options:'
      -h, --help                Displays complete help
      -y, --yes                 Override empty directory check
      --dir                     Path to directory to init
      --skip-install            Skip installing dependencies
      --template                URL to template to init
      --github-repo             URL to github repository
      --project                 Project to init (opts: ${(0, repos_1.scaffoldedProjectOptions)().join(', ')})

    Example:
    - Init your scene:
      '$ sdk-commands init'
  `);
}
exports.help = help;
async function main(options) {
    const dir = path_1.default.resolve(process.cwd(), options.args['--dir'] || '.');
    const isEmpty = await (0, fs_1.isDirectoryEmpty)(options.components, dir);
    const yes = options.args['--yes'];
    const requestedTemplateZipUrl = options.args['--template'];
    const requestedProjectTemplate = options.args['--project'];
    const githubRepo = options.args['--github-repo'];
    if (!isEmpty && !yes) {
        throw new error_1.CliError('The target directory specified is not empty. Run this command with --yes to override.');
    }
    if (requestedTemplateZipUrl && requestedProjectTemplate) {
        throw new error_1.CliError(`Specifying --template and --project at the same time is not allowed. Please specify only one of them.`);
    }
    if (requestedProjectTemplate && !(0, repos_1.existScaffoldedProject)(requestedProjectTemplate)) {
        throw new error_1.CliError(`The requested scene doesn't exist empty. Valid options are: ${(0, repos_1.scaffoldedProjectOptions)().join(', ')}`);
    }
    // download and extract template project
    const projectTemplate = requestedProjectTemplate || 'scene-template';
    const url = githubRepo || requestedTemplateZipUrl || (0, repos_1.getScaffoldedProjectUrl)(projectTemplate);
    if (githubRepo) {
        await (0, download_github_folder_1.downloadGithubFolder)(options.components, githubRepo, dir);
    }
    else {
        await downloadAndUnzipUrlContainFolder(url, dir, options);
        // replace scene.json for portable experience template...
        if (projectTemplate === 'px-template')
            await (0, project_1.createPxSceneJson)(dir, options.components.fs);
    }
    // npm install
    const shouldInstallDeps = await (0, project_validations_1.needsDependencies)(options.components, dir);
    if (shouldInstallDeps && !options.args['--skip-install']) {
        await (0, project_validations_1.installDependencies)(options.components, dir);
    }
    options.components.analytics.track('Scene created', {
        projectType: githubRepo ? 'github-repo' : requestedTemplateZipUrl ? 'custom-template-url' : projectTemplate,
        url
    });
}
exports.main = main;
async function downloadAndUnzipUrlContainFolder(url, dest, options) {
    const zipFilePath = path_1.default.resolve(dest, 'temp-zip-project.zip');
    const zip = await (0, fs_1.download)(options.components, url, zipFilePath);
    const zipExtracted = await (0, fs_1.extract)(zip, dest);
    if (zipExtracted.topLevelFolders.length !== 1) {
        throw new Error('The zip downloaded has many folder on the root, make sure it has only one folder on the root.');
    }
    const extractedPath = path_1.default.resolve(dest, zipExtracted.topLevelFolders[0]);
    const filesToMove = await options.components.fs.readdir(extractedPath);
    for (const filePath of filesToMove) {
        await options.components.fs.rename(path_1.default.resolve(extractedPath, filePath), path_1.default.resolve(dest, filePath));
    }
    await options.components.fs.rmdir(extractedPath);
    await options.components.fs.unlink(zipFilePath);
}
exports.downloadAndUnzipUrlContainFolder = downloadAndUnzipUrlContainFolder;
//# sourceMappingURL=index.js.map