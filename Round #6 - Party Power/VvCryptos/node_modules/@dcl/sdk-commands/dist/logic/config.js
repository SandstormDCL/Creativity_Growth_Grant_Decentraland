"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEstateRegistry = exports.getLandRegistry = exports.getSegmentKey = exports.getCatalystBaseUrl = exports.isCI = exports.isEditor = exports.getInstalledPackageVersion = exports.getInstalledPackageVersionInsidePackage = exports.getSdkCommandsVersion = void 0;
const path_1 = __importDefault(require("path"));
const config_1 = require("../components/config");
const fs_1 = require("./fs");
const project_files_1 = require("./project-files");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { version: sdkCommandsVersion } = require('../../package.json');
/**
 * Returns the version of the sdk-commands that is running
 */
async function getSdkCommandsVersion() {
    return sdkCommandsVersion;
}
exports.getSdkCommandsVersion = getSdkCommandsVersion;
/**
 * Returns the installed version of a certain package that lives inside another package in the current working directory.
 * Returns undefined if the package is not installed.
 */
async function getInstalledPackageVersionInsidePackage(components, packageName, packageRootName, workingDirectory) {
    try {
        const packagePath = path_1.default.dirname(require.resolve(`${packageRootName}/package.json`, {
            paths: [workingDirectory]
        }));
        const packageJson = await (0, project_files_1.getPackageJson)(components, packagePath);
        const version = (packageJson.dependencies && packageJson.dependencies[packageName]) ||
            (packageJson.devDependencies && packageJson.devDependencies[packageName]);
        return version ?? undefined;
    }
    catch (e) {
        return 'unknown';
    }
}
exports.getInstalledPackageVersionInsidePackage = getInstalledPackageVersionInsidePackage;
/**
 * Returns the installed version of a certain package in the current working directory.
 * Returns "unknown" if the package is not installed.
 */
async function getInstalledPackageVersion(components, packageName, workingDirectory) {
    try {
        const packagePath = path_1.default.dirname(require.resolve(`${packageName}/package.json`, {
            paths: [workingDirectory]
        }));
        const packageJson = await (0, fs_1.readJson)(components, path_1.default.resolve(packagePath, 'package.json'));
        return packageJson.version ?? /* istanbul ignore next */ 'unknown';
    }
    catch (e) {
        return 'unknown';
    }
}
exports.getInstalledPackageVersion = getInstalledPackageVersion;
/**
 * Returns true if the Decentraland Editor is running.
 */
function isEditor() {
    return process.env.EDITOR_SDK7 === 'true';
}
exports.isEditor = isEditor;
function isCI() {
    return process.env.CI === 'true' || process.argv.includes('--ci') || process.argv.includes('--c');
}
exports.isCI = isCI;
async function getCatalystBaseUrl(components) {
    const url = (await (0, config_1.readStringConfig)(components, 'DCL_CATALYST')) ?? 'https://peer.decentraland.org';
    return url.replace(/\/$/, '');
}
exports.getCatalystBaseUrl = getCatalystBaseUrl;
function getSegmentKey() {
    const isProduction = !process.env.DEVELOPER_MODE;
    return isProduction
        ? /* istanbul ignore next */ 'sFdziRVDJo0taOnGzTZwafEL9nLIANZ3'
        : 'mjCV5Dc4VAKXLJAH5g7LyHyW1jrIR3to';
}
exports.getSegmentKey = getSegmentKey;
/* istanbul ignore next */
async function getLandRegistry(components) {
    return (0, config_1.readStringConfig)(components, 'DCL_LAND_REGISTRY_ADDRESS');
}
exports.getLandRegistry = getLandRegistry;
/* istanbul ignore next */
async function getEstateRegistry(components) {
    return (0, config_1.readStringConfig)(components, 'DCL_ESTATE_REGISTRY_ADDRESS');
}
exports.getEstateRegistry = getEstateRegistry;
//# sourceMappingURL=config.js.map