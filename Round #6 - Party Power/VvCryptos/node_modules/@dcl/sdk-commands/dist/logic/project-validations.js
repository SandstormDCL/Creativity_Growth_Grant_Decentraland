"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEditorScene = exports.startValidations = exports.npmCommand = exports.npmRun = exports.installDependencies = exports.needsDependencies = exports.assertValidProjectFolder = void 0;
const path_1 = __importDefault(require("path"));
const log_1 = require("../components/log");
const beautiful_logs_1 = require("./beautiful-logs");
const error_1 = require("./error");
const scene_validations_1 = require("./scene-validations");
const config_1 = require("./config");
const portable_experience_sw_validations_1 = require("./portable-experience-sw-validations");
const project_files_1 = require("./project-files");
/**
 * Asserts that the workingDirectory is a valid project
 */
async function assertValidProjectFolder(components, workingDirectory) {
    // no validations for now, only check that it exists
    if (!(await components.fs.fileExists(path_1.default.resolve(workingDirectory, 'package.json'))))
        throw new error_1.CliError(`The project root doesn't have a package.json file`);
    // now we will iterate over different file to evaluate the project kind
    switch (true) {
        case await components.fs.fileExists((0, portable_experience_sw_validations_1.getSmartWearableFile)(workingDirectory)): {
            await (0, portable_experience_sw_validations_1.getValidWearableJson)(components, workingDirectory);
            return { kind: 'smart-wearable', scene: await (0, scene_validations_1.getValidSceneJson)(components, workingDirectory), workingDirectory };
        }
        case await components.fs.fileExists((0, scene_validations_1.getSceneFilePath)(workingDirectory)): {
            return { kind: 'scene', scene: await (0, scene_validations_1.getValidSceneJson)(components, workingDirectory), workingDirectory };
        }
        default: {
            throw new error_1.CliError(`UnknownProjectKind: the kind of project of the folder ${workingDirectory} cannot be identified`);
        }
    }
}
exports.assertValidProjectFolder = assertValidProjectFolder;
/*
 * Returns true if the project contains an empty node_modules folder
 */
async function needsDependencies(components, workingDirectory) {
    const nodeModulesPath = path_1.default.join(workingDirectory, 'node_modules');
    const hasNodeModulesFolder = await components.fs.directoryExists(nodeModulesPath);
    const isNodeModulesEmpty = hasNodeModulesFolder && (await components.fs.readdir(nodeModulesPath)).length === 0;
    return !hasNodeModulesFolder || isNodeModulesEmpty;
}
exports.needsDependencies = needsDependencies;
/* istanbul ignore next */
const npmBin = /^win/.test(process.platform) ? 'npm.cmd' : 'npm';
/*
 * Runs "npm install" for desired project
 */
async function installDependencies(components, workingDirectory) {
    (0, beautiful_logs_1.printProgressInfo)(components.logger, 'Installing dependencies...');
    // TODO: test in windows
    await components.spawner.exec(workingDirectory, npmBin, ['install']);
    (0, beautiful_logs_1.printProgressInfo)(components.logger, log_1.colors.white('âœ… Installing dependencies...'));
}
exports.installDependencies = installDependencies;
/**
 * Run NPM commands
 */
async function npmRun(components, cwd, command, ...args) {
    // TODO: test in windows
    await components.spawner.exec(cwd, npmBin, ['run', command, '--silent', '--', ...args], { env: process.env });
}
exports.npmRun = npmRun;
/**
 * NPM commands
 */
async function npmCommand(components, cwd, command, ...args) {
    await components.spawner.exec(cwd, npmBin, [command, ...args, '--silent'], { env: process.env });
}
exports.npmCommand = npmCommand;
/**
 * Start validations to make the scene work.
 * Addd js-runtime package, so you can auto-import all the ~system modules.
 */
async function startValidations(components, cwd) {
    try {
        const sdkVersion = await (0, config_1.getInstalledPackageVersion)(components, '@dcl/sdk', cwd);
        const packageJsonPath = path_1.default.resolve(cwd, 'package.json');
        if (!(await components.fs.fileExists(packageJsonPath))) {
            return;
        }
        const packageJson = await (0, project_files_1.getPackageJson)(components, cwd);
        // Ignore relative or s3 versions
        const sdkPackageVersion = (packageJson.dependencies && packageJson.dependencies['@dcl/sdk']) ||
            (packageJson.devDependencies && packageJson.devDependencies['@dcl/sdk']);
        if (sdkPackageVersion?.startsWith('https://') ||
            sdkPackageVersion?.startsWith('file://') ||
            sdkPackageVersion === '7.0.0') {
            return;
        }
        if (packageJson.dependencies &&
            (packageJson.dependencies['@dcl/js-runtime'] || packageJson.dependencies['@dcl/sdk'])) {
            packageJson.dependencies['@dcl/js-runtime'] = sdkVersion;
            if (packageJson.devDependencies && packageJson.devDependencies['@dcl/js-runtime']) {
                delete packageJson.devDependencies['@dcl/js-runtime'];
            }
        }
        else {
            packageJson.devDependencies = packageJson.devDependencies || {};
            packageJson.devDependencies['@dcl/js-runtime'] = sdkVersion;
        }
        await components.fs.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2), 'utf-8');
    }
    catch (e) {
        components.logger.error('Failed to run scene validations', e.message);
    }
}
exports.startValidations = startValidations;
// If there is a main.crdt file, its an editor scene. We need asset-packs package.
function isEditorScene(components, workingDirectory) {
    return components.fs.fileExists(path_1.default.resolve(workingDirectory, 'main.crdt'));
}
exports.isEditorScene = isEditorScene;
//# sourceMappingURL=project-validations.js.map