"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValidWearableJson = exports.assertValidSmartWearable = exports.getSmartWearableFile = exports.SMART_WEARABLE_FILE = void 0;
const path_1 = require("path");
const schemas_1 = require("@dcl/schemas");
const error_1 = require("./error");
exports.SMART_WEARABLE_FILE = 'wearable.json';
/**
 * Composes the path to the `scene.json` file based on the provided path.
 * @param projectRoot The path to the directory containing the scene file.
 */
function getSmartWearableFile(projectRoot) {
    return (0, path_1.resolve)(projectRoot, exports.SMART_WEARABLE_FILE);
}
exports.getSmartWearableFile = getSmartWearableFile;
function assertValidSmartWearable(scene) {
    if (!schemas_1.Scene.validate(scene)) {
        const errors = [];
        if (schemas_1.Scene.validate.errors) {
            for (const error of schemas_1.Scene.validate.errors) {
                errors.push(`Error validating scene.json: ${error.message}`);
            }
        }
        throw new error_1.CliError('Invalid scene.json file:\n' + errors.join('\n'));
    }
    // TODO
    return true;
}
exports.assertValidSmartWearable = assertValidSmartWearable;
/**
 * Get valid Scene JSON
 */
async function getValidWearableJson(components, projectRoot) {
    try {
        const wearableJsonRaw = await components.fs.readFile(getSmartWearableFile(projectRoot), 'utf8');
        const wearableJson = JSON.parse(wearableJsonRaw);
        return wearableJson;
    }
    catch (err) {
        throw new error_1.CliError(`Error reading the wearable.json file: ${err.message}`);
    }
}
exports.getValidWearableJson = getValidWearableJson;
//# sourceMappingURL=portable-experience-sw-validations.js.map