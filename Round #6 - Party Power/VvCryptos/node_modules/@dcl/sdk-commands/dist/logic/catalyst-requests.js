"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPointers = exports.fetchEntityByPointer = exports.daoCatalysts = void 0;
const config_1 = require("./config");
async function daoCatalysts(components, network) {
    const tld = network === 'mainnet' ? 'org' : 'zone';
    const catalystUrl = network === 'mainnet' ? await (0, config_1.getCatalystBaseUrl)(components) : `https://peer.decentraland.${tld}`;
    const resp = await (await components.fetch.fetch(`${catalystUrl}/lambdas/contracts/servers`)).json();
    return resp;
}
exports.daoCatalysts = daoCatalysts;
async function fetchEntityByPointer({ fetch }, baseUrl, pointers) {
    if (pointers.length === 0)
        return {
            baseUrl,
            deployments: []
        };
    const activeEntities = baseUrl + '/content/entities/active';
    const response = await fetch.fetch(activeEntities, {
        method: 'post',
        headers: { 'content-type': 'application/json', connection: 'close' },
        body: JSON.stringify({ pointers })
    });
    const deployments = response.ok ? (await response.json()) : [];
    return {
        baseUrl,
        deployments
    };
}
exports.fetchEntityByPointer = fetchEntityByPointer;
async function getPointers(components, pointer, network) {
    const catalysts = await daoCatalysts(components, network);
    const catalystInfo = [];
    for (const { baseUrl } of catalysts) {
        try {
            const result = await fetchEntityByPointer(components, baseUrl, [pointer]);
            const timestamp = result.deployments[0]?.timestamp;
            const entityId = result.deployments[0]?.id || '';
            catalystInfo.push({ timestamp, entityId, url: baseUrl });
        }
        catch (err) {
            components.logger.log('Error fetching catalyst pointers', err);
        }
    }
    return catalystInfo;
}
exports.getPointers = getPointers;
//# sourceMappingURL=catalyst-requests.js.map