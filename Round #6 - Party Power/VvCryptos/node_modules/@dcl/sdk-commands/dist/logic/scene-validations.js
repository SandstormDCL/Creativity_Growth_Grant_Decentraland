"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFilesSizes = exports.getFiles = exports.getBaseCoords = exports.getValidSceneJson = exports.assertValidScene = exports.getSceneFilePath = exports.MAX_FILE_SIZE_BYTES = exports.SCENE_FILE = void 0;
const path_1 = require("path");
const schemas_1 = require("@dcl/schemas");
const dist_cjs_1 = require("@dcl/ecs/dist-cjs");
const project_1 = require("../commands/init/project");
const error_1 = require("./error");
const coordinates_1 = require("./coordinates");
const project_files_1 = require("./project-files");
const beautiful_logs_1 = require("./beautiful-logs");
exports.SCENE_FILE = 'scene.json';
exports.MAX_FILE_SIZE_BYTES = 50 * 1e6; // 50mb
/**
 * Composes the path to the `scene.json` file based on the provided path.
 * @param projectRoot The path to the directory containing the scene file.
 */
function getSceneFilePath(projectRoot) {
    return (0, path_1.resolve)(projectRoot, exports.SCENE_FILE);
}
exports.getSceneFilePath = getSceneFilePath;
function getWorldRangesConstraintsMessage() {
    const ranges = (0, schemas_1.getWorld)().validWorldRanges;
    let str = '';
    for (const range of ranges) {
        str += `"x" from ${range.xMin} to ${range.xMax} and "y" from ${range.yMin} to ${range.yMax}\n`;
    }
    return str;
}
function checkMissingOrDefault(obj, defaults) {
    const missingKeys = Object.entries(defaults).reduce((acc, [key, value]) => {
        return obj[key] && obj[key] !== value ? acc : acc.concat(key);
    }, []);
    return missingKeys;
}
function assertValidScene(components, scene, opts = { log: false }) {
    if (!schemas_1.Scene.validate(scene)) {
        const errors = [];
        if (schemas_1.Scene.validate.errors) {
            for (const error of schemas_1.Scene.validate.errors) {
                const errorPath = error.instancePath.slice(1).replace(/\//g, ' => ');
                errors.push(`Error validating scene.json: ${errorPath} ${error.message}`);
            }
        }
        throw new error_1.CliError('Invalid scene.json file:\n' + errors.join('\n'));
    }
    const parcelSet = new Set(scene.scene?.parcels);
    if (parcelSet.size < scene.scene?.parcels?.length) {
        throw new error_1.CliError(`There are duplicated parcels at scene.json.`);
    }
    if (!parcelSet.has(scene.scene?.base)) {
        throw new error_1.CliError(`Your base parcel ${scene.scene?.base} should be included on parcels attribute at scene.json`);
    }
    const objParcels = scene.scene?.parcels?.map(coordinates_1.getObject);
    objParcels.forEach(({ x, y }) => {
        if ((0, schemas_1.isInsideWorldLimits)(x, y)) {
            return;
        }
        const constraints = getWorldRangesConstraintsMessage();
        throw new error_1.CliError(`Coordinates ${x},${y} are outside of allowed limits: \n\n${constraints}`);
    });
    if (!(0, dist_cjs_1.areConnected)(objParcels)) {
        throw new error_1.CliError('Parcels described on scene.json are not connected. They should be one next to each other');
    }
    if (!scene.main?.endsWith('.js')) {
        throw new error_1.CliError(`Main scene format file (${scene.main}) is not a supported format`);
    }
    const minimalScene = (0, project_1.getMinimalSceneJson)();
    const defaults = { ...minimalScene.display, navmapThumbnail: 'images/scene-thumbnail.png' };
    const missingKeys = checkMissingOrDefault(scene.display ?? {}, defaults);
    if (missingKeys.length && opts.log) {
        const missingKeysMsg = missingKeys.join(', ');
        (0, beautiful_logs_1.printWarning)(components.logger, `Don't forget to update your scene.json metadata: [${missingKeysMsg}]
https://docs.decentraland.org/creator/development-guide/scene-metadata/#scene-title-description-and-image`);
    }
}
exports.assertValidScene = assertValidScene;
/**
 * Get valid Scene JSON
 */
async function getValidSceneJson(components, projectRoot, opts) {
    try {
        const sceneJsonRaw = await components.fs.readFile(getSceneFilePath(projectRoot), 'utf8');
        const sceneJson = JSON.parse(sceneJsonRaw);
        assertValidScene(components, sceneJson, opts);
        return sceneJson;
    }
    catch (err) {
        throw new error_1.CliError(`Error reading the scene.json file: ${err.message}`);
    }
}
exports.getValidSceneJson = getValidSceneJson;
function getBaseCoords(scene) {
    const [x, y] = scene.scene.base
        .replace(/\ /g, '')
        .split(',')
        .map((a) => parseInt(a));
    return { x, y };
}
exports.getBaseCoords = getBaseCoords;
/**
 * Returns a promise of an array of objects containing the path and the content for all the files in the project.
 * All the paths added to the `.dclignore` file will be excluded from the results.
 * Windows directory separators are replaced for POSIX separators.
 * @param ignoreFile The contents of the .dclignore file
 */
async function getFiles(components, dir) {
    const files = await (0, project_files_1.getPublishableFiles)(components, dir);
    const data = [];
    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const filePath = (0, path_1.resolve)(dir, file);
        const stat = await components.fs.stat(filePath);
        const content = await components.fs.readFile(filePath);
        data.push({
            path: file.replace(/\\/g, '/'),
            content: Buffer.from(content),
            size: stat.size
        });
    }
    return data;
}
exports.getFiles = getFiles;
function validateFilesSizes(files) {
    for (const { path, size } of files) {
        if (size > exports.MAX_FILE_SIZE_BYTES) {
            throw new error_1.CliError(`Maximum file size exceeded: '${path}' is larger than ${exports.MAX_FILE_SIZE_BYTES / 1e6}MB`);
        }
    }
}
exports.validateFilesSizes = validateFilesSizes;
//# sourceMappingURL=scene-validations.js.map