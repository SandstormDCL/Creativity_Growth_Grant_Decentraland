"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setRoutes = void 0;
const path_1 = require("path");
const node_fetch_1 = __importDefault(require("node-fetch"));
const https_1 = __importDefault(require("https"));
const http_server_1 = require("@well-known-components/http-server");
/**
 * Set common routes to use on Linker dApp
 * @param components Server components
 * @param info Info to be sent within /api/info body response
 * @param mainRoute route to return the Linker dApp
 */
function setRoutes(components, info, mainRoute = '/') {
    const { fs } = components;
    const router = new http_server_1.Router();
    const linkerDapp = (0, path_1.dirname)(require.resolve('@dcl/linker-dapp/package.json'));
    router.get(mainRoute, async () => ({
        headers: { 'Content-Type': 'text/html' },
        body: fs.createReadStream((0, path_1.resolve)(linkerDapp, 'index.html'))
    }));
    router.get('/static/:type/:path', async (ctx) => {
        const contentType = getContentType(ctx.params.type);
        return {
            headers: { 'Content-Type': contentType },
            body: fs.createReadStream((0, path_1.resolve)(linkerDapp, 'static', ctx.params.type, ctx.params.path))
        };
    });
    router.get('/assets/:path', async (ctx) => {
        const contentType = getContentTypeFromPath(ctx.params.path);
        return {
            headers: { 'Content-Type': contentType },
            body: fs.createReadStream((0, path_1.resolve)(linkerDapp, 'assets', ctx.params.path))
        };
    });
    /* This route acts as a proxy to handle the auth flow with the Decentraland auth dApp,
     * because this latest one validates the communication be on the same domain.
     */
    router.get('/auth/(.*)', async (ctx) => {
        try {
            const httpsAgent = new https_1.default.Agent({
                rejectUnauthorized: false
            });
            const domain = 'decentraland.org';
            const url = `https://${domain}${ctx.url.pathname}${ctx.url.search}`;
            // Forward the incoming request to the Decentraland auth endpoint.
            const resp = await (0, node_fetch_1.default)(url, {
                method: ctx.request.method,
                headers: {
                    ...ctx.request.headers,
                    Host: domain,
                    Referer: url,
                    Origin: url
                },
                body: ctx.request.body,
                agent: httpsAgent // Use the insecure HTTPS agent.
            });
            // Remove content-encoding header if present to prevent issues with compressed responses.
            resp.headers.delete('content-encoding');
            // Return the proxied response, including body, status, and headers.
            return {
                body: resp.body,
                status: resp.status,
                headers: resp.headers
            };
        }
        catch (error) {
            return {
                status: 500,
                body: `Proxy error: ${error instanceof Error ? error.message : error}`
            };
        }
    });
    router.get('/manifest.json', async () => ({
        headers: { 'Content-Type': 'application/json' },
        body: fs.createReadStream((0, path_1.resolve)(linkerDapp, 'manifest.json'))
    }));
    router.get('/api/info', async () => ({
        body: info
    }));
    return { router };
}
exports.setRoutes = setRoutes;
function getContentType(type) {
    switch (type) {
        case 'css':
            return 'text/css';
        case 'js':
            return 'application/js';
        case 'media':
        default:
            return 'text/plain';
    }
}
function getContentTypeFromPath(path) {
    const ext = path.split('.').pop();
    switch (ext) {
        case 'css':
            return 'text/css';
        case 'js':
            return 'application/javascript';
        case 'media':
        default:
            return 'text/plain';
    }
}
//# sourceMappingURL=routes.js.map