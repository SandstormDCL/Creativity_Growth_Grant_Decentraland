import * as BABYLON from '@babylonjs/core';
import { ComponentDefinition, Entity, PBGltfContainer, PBMeshRenderer, PBPointerEvents, PBTextShape, TransformType, PBMaterial } from '@dcl/ecs';
import { IFuture } from 'fp-future';
import { SceneContext } from './SceneContext';
export type EcsComponents = Partial<{
    gltfContainer: PBGltfContainer;
    material: PBMaterial;
    meshRenderer: PBMeshRenderer;
    pointerEvents: PBPointerEvents;
    textShape: PBTextShape;
    transform: TransformType;
}>;
export declare class EcsEntity extends BABYLON.TransformNode {
    #private;
    entityId: Entity;
    context: WeakRef<SceneContext>;
    scene: BABYLON.Scene;
    readonly isDCLEntity = true;
    usedComponents: Map<number, ComponentDefinition<unknown>>;
    meshRenderer?: BABYLON.AbstractMesh;
    gltfContainer?: BABYLON.AbstractMesh;
    boundingInfoMesh?: BABYLON.AbstractMesh;
    gltfAssetContainer?: BABYLON.AssetContainer;
    textShape?: BABYLON.Mesh;
    material?: BABYLON.StandardMaterial | BABYLON.PBRMaterial;
    ecsComponentValues: EcsComponents;
    constructor(entityId: Entity, context: WeakRef<SceneContext>, scene: BABYLON.Scene);
    putComponent(component: ComponentDefinition<unknown>): void;
    deleteComponent(component: ComponentDefinition<unknown>): void;
    /**
     * Returns the children that extends EcsEntity, filtering any other Object3D
     */
    childrenEntities(): Iterable<EcsEntity>;
    dispose(_doNotRecurse?: boolean | undefined, _disposeMaterialAndTextures?: boolean | undefined): void;
    getMeshesBoundingBox(_children?: BABYLON.AbstractMesh[]): BABYLON.BoundingInfo;
    getGroupMeshesBoundingBox(): BABYLON.BoundingInfo | null;
    isGltfPathLoading(): boolean;
    getGltfPathLoading(): IFuture<string> | undefined;
    resolveGltfPathLoading(filePath: string): void;
    setGltfPathLoading(): void;
    onGltfContainerLoaded(): IFuture<BABYLON.AssetContainer>;
    setGltfAssetContainer(gltfAssetContainer: BABYLON.AssetContainer): void;
    setGltfContainer(mesh: BABYLON.AbstractMesh): void;
    setMeshRenderer(mesh: BABYLON.AbstractMesh): void;
    onAssetLoaded(): IFuture<BABYLON.AbstractMesh>;
    isHidden(): boolean;
    getRoot(): Entity | null;
    setVisibility(enabled: boolean): void;
    isLocked(): boolean | undefined;
    setLock(lock: boolean): void;
    generateBoundingBox(): void;
    isOutOfBoundaries(): boolean;
}
/**
 * Finds the closest parent that is or extends a EcsEntity
 * @param object the object to start looking
 */
export declare function findParentEntity(object: BABYLON.Node): EcsEntity | null;
/**
 * Finds the closest parent that is instance of the second parameter (constructor)
 * @param object the object to start looking
 * @param desiredClass the constructor of the kind of parent we want to find
 */
export declare function findParentEntityOfType<T extends EcsEntity>(object: BABYLON.Node, desiredClass: any): T | null;
