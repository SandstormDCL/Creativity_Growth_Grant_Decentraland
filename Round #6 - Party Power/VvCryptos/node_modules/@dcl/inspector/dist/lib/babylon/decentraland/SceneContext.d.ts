import * as BABYLON from '@babylonjs/core';
import { Entity } from '@dcl/ecs';
import * as components from '@dcl/ecs/dist/components';
import * as Schemas from '@dcl/schemas';
import { ComponentOperation } from './component-operations';
import { EcsEntity } from './EcsEntity';
export type LoadableScene = {
    readonly entity: Readonly<Omit<Schemas.Entity, 'id'>>;
    readonly baseUrl: string;
    readonly id: string;
};
export declare class SceneContext {
    #private;
    babylon: BABYLON.Engine;
    scene: BABYLON.Scene;
    loadableScene: LoadableScene;
    rootNode: EcsEntity;
    logger: {
        log: {
            (...data: any[]): void;
            (message?: any, ...optionalParams: any[]): void;
        };
        error: {
            (...data: any[]): void;
            (message?: any, ...optionalParams: any[]): void;
        };
    };
    engine: import("@dcl/ecs").IEngine;
    operations: {
        removeEntity: (entity: Entity) => void;
        updateValue: <T = unknown>(component: components.LastWriteWinElementSetComponentDefinition<T>, entity: Entity, data: Partial<T>) => void;
        addChild: (parent: Entity, name: string) => Entity;
        addAsset: (parent: Entity, src: string, name: string, position: import("@dcl/ecs").Vector3Type, base: string, enumEntityId: import("../../sdk/enum-entity").EnumEntity, composite?: import("@dcl/asset-packs").AssetData["composite"], assetId?: string) => Entity;
        setParent: (entity: Entity, parent: Entity) => void;
        reorder: (source: Entity, target: Entity, parent: Entity) => void;
        addComponent: (entity: Entity, componentId: number, value?: any) => void;
        removeComponent: <T>(entity: Entity, component: components.LastWriteWinElementSetComponentDefinition<T>) => void;
        updateSelectedEntity: (entity: Entity, multiple?: boolean) => void;
        removeSelectedEntities: () => void;
        duplicateEntity: (entity: Entity) => Entity;
        dispatch: ({ dirty }?: import("../../sdk/operations").Dispatch) => Promise<void>;
        getSelectedEntities: () => Entity[];
        setGround: (src: string) => void;
        lock: (entity: Entity, value: boolean) => void;
        hide: (entity: Entity, value: boolean) => void;
    };
    gizmos: {
        gizmoManager: import("./gizmo-patch").PatchedGizmoManager;
        isEnabled(): boolean;
        setEnabled: (value: boolean) => void;
        restoreParents: () => void;
        repositionGizmoOnCentroid: () => void;
        addEntity(entity: EcsEntity): void;
        getEntity(): EcsEntity;
        removeEntity(entity: EcsEntity): void;
        getGizmoTypes(): readonly [import("../../utils/gizmo").GizmoType.POSITION, import("../../utils/gizmo").GizmoType.ROTATION, import("../../utils/gizmo").GizmoType.SCALE, import("../../utils/gizmo").GizmoType.FREE];
        setGizmoType(type: import("../../utils/gizmo").GizmoType): void;
        isPositionGizmoWorldAligned: () => boolean;
        setPositionGizmoWorldAligned: (worldAligned: boolean) => void;
        fixPositionGizmoAlignment: (value: import("@dcl/ecs").TransformType) => void;
        isPositionGizmoAlignmentDisabled: () => boolean;
        isRotationGizmoWorldAligned: () => boolean;
        setRotationGizmoWorldAligned: (worldAligned: boolean) => void;
        fixRotationGizmoAlignment: (value: import("@dcl/ecs").TransformType) => void;
        isRotationGizmoAlignmentDisabled: () => boolean;
        onChange: (cb: () => void) => () => void;
    };
    Billboard: components.LastWriteWinElementSetComponentDefinition<components.PBBillboard>;
    Transform: import("@dcl/ecs").TransformComponentExtended;
    Material: import("@dcl/ecs").MaterialComponentDefinitionExtended;
    MeshRenderer: import("@dcl/ecs").MeshRendererComponentDefinitionExtended;
    GltfContainer: components.LastWriteWinElementSetComponentDefinition<components.PBGltfContainer>;
    TextShape: components.LastWriteWinElementSetComponentDefinition<components.PBTextShape>;
    Name: components.LastWriteWinElementSetComponentDefinition<import("@dcl/ecs").NameType>;
    Animator: import("@dcl/ecs").AnimatorComponentDefinitionExtended;
    NftShape: components.LastWriteWinElementSetComponentDefinition<components.PBNftShape>;
    VideoPlayer: components.LastWriteWinElementSetComponentDefinition<components.PBVideoPlayer>;
    readonly editorComponents: import("../../sdk/components").EditorComponents;
    readonly componentPutOperations: Record<number, ComponentOperation>;
    readonly componentDeleteOperations: Record<number, ComponentOperation>;
    readonly stopped: import("fp-future").IFuture<void>;
    constructor(babylon: BABYLON.Engine, scene: BABYLON.Scene, loadableScene: LoadableScene);
    private processEcsChange;
    removeEntity(entityId: Entity): void;
    getOrCreateEntity(entityId: Entity): EcsEntity;
    getEntityOrNull(entityId: Entity): EcsEntity | null;
    resolveFile(src: string): string | null;
    getFile(src: string): Promise<Uint8Array | null>;
    resolveFileAbsolute(src: string): string | null;
    dispose(): void;
}
