import { NetworkEntity as _NetworkEntity, NetworkParent as _NetworkParent, Transform as _Transform, SyncComponents as _SyncComponents } from '@dcl/ecs';
import { NOT_SYNC_COMPONENTS } from './state';
export function entityUtils(engine, profile) {
    const NetworkEntity = engine.getComponent(_NetworkEntity.componentId);
    const NetworkParent = engine.getComponent(_NetworkParent.componentId);
    const Transform = engine.getComponent(_Transform.componentId);
    const SyncComponents = engine.getComponent(_SyncComponents.componentId);
    /**
     * Create a network entity (sync) through comms, and sync the received components
     */
    function syncEntity(entityId, componentIds, entityEnumId) {
        let componentsIdsMutable = [...componentIds];
        // Profile not initialized
        if (!profile?.networkId) {
            throw new Error('Profile not initialized. Call syncEntity inside the main() function.');
        }
        // We use the networkId generated by the user address to identify this entity through the network
        const networkValue = { entityId, networkId: profile.networkId };
        // If there is an entityEnumId, it means is the same entity for all the clients created on the main funciton.
        // So the networkId should be the same in all the clients to avoid re-creating this entity.
        // For this case we use networkId = 0.
        if (entityEnumId !== undefined) {
            networkValue.networkId = 0;
            networkValue.entityId = entityEnumId;
            // Check if this enum is already used
            for (const [_, network] of engine.getEntitiesWith(NetworkEntity)) {
                if (network.networkId === networkValue.networkId && network.entityId === networkValue.entityId) {
                    throw new Error('syncEntity failed because the id provided is already in use');
                }
            }
        }
        for (const component of NOT_SYNC_COMPONENTS) {
            if (componentsIdsMutable.includes(component.componentId)) {
                console.log(`⚠️ ${component.componentName} can't be sync through the network!`);
                componentsIdsMutable = componentsIdsMutable.filter(($) => $ !== component.componentId);
            }
        }
        // If is not defined, then is a entity created in runtime (what we called dynamic/runtime entities).
        NetworkEntity.createOrReplace(entityId, networkValue);
        SyncComponents.createOrReplace(entityId, { componentIds: componentsIdsMutable });
    }
    /**
     * Returns an iterable of all the childrens of the given entity.
     * for (const children of getChildren(parent)) { console.log(children) }
     * or just => const childrens: Entity[] = Array.from(getChildren(parent))
     */
    function* getChildren(parent) {
        const network = NetworkEntity.getOrNull(parent);
        if (network) {
            for (const [entity, parent] of engine.getEntitiesWith(NetworkParent)) {
                if (parent.entityId === network.entityId && parent.networkId === network.networkId) {
                    yield entity;
                }
            }
        }
    }
    function getFirstChild(entity) {
        return Array.from(getChildren(entity))[0];
    }
    /**
     * Returns the parent entity of the given entity.
     */
    function getParent(child) {
        const parent = NetworkParent.getOrNull(child);
        if (!parent)
            return undefined;
        for (const [entity, network] of engine.getEntitiesWith(NetworkEntity)) {
            if (parent.networkId === network.networkId && parent.entityId === network.entityId) {
                return entity;
            }
        }
        return undefined;
    }
    /**
     * Adds the network parenting to sync entities.
     * Equivalent to Transform.parent for local entities
     */
    function parentEntity(entity, parent) {
        const network = NetworkEntity.getOrNull(parent);
        if (!network) {
            throw new Error('Entity is not sync. Call syncEntity on the parent.');
        }
        // Create network parent component
        NetworkParent.createOrReplace(entity, network);
        // If we dont have a transform for this entity, create an empty one to send it to the renderer
        if (!Transform.getOrNull(entity)) {
            Transform.create(entity);
        }
        else {
            // We force to send a tick update of the transform so we can send the NEW parent to the renderer
            Transform.getMutable(entity);
        }
    }
    /**
     * Removes the network parenting from an entity
     */
    function removeParent(entity) {
        const network = NetworkEntity.getOrNull(entity);
        if (!network) {
            throw new Error('Entity is not sync');
        }
        NetworkParent.deleteFrom(entity);
    }
    return {
        syncEntity,
        getChildren,
        getParent,
        parentEntity,
        removeParent,
        getFirstChild
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXRpZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbmV0d29yay9lbnRpdGllcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBR0wsYUFBYSxJQUFJLGNBQWMsRUFFL0IsYUFBYSxJQUFJLGNBQWMsRUFDL0IsU0FBUyxJQUFJLFVBQVUsRUFDdkIsY0FBYyxJQUFJLGVBQWUsRUFJbEMsTUFBTSxVQUFVLENBQUE7QUFFakIsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sU0FBUyxDQUFBO0FBSTdDLE1BQU0sVUFBVSxXQUFXLENBQUMsTUFBZSxFQUFFLE9BQWlCO0lBQzVELE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBbUIsQ0FBQTtJQUN2RixNQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQW1CLENBQUE7SUFDdkYsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUF1QixDQUFBO0lBQ25GLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBb0IsQ0FBQTtJQUUxRjs7T0FFRztJQUNILFNBQVMsVUFBVSxDQUFDLFFBQWdCLEVBQUUsWUFBc0IsRUFBRSxZQUFxQjtRQUNqRixJQUFJLG9CQUFvQixHQUFHLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQTtRQUM1QywwQkFBMEI7UUFDMUIsSUFBSSxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUU7WUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxzRUFBc0UsQ0FBQyxDQUFBO1NBQ3hGO1FBRUQsaUdBQWlHO1FBQ2pHLE1BQU0sWUFBWSxHQUFHLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUE7UUFFL0QsNkdBQTZHO1FBQzdHLDJGQUEyRjtRQUMz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QWEsQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFBO1FBRTlDLDhGQUE4RjtRQUM5RixJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNoQyxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1NBQ3pCO2FBQU07WUFDTCxnR0FBZ0c7WUFDaEcsU0FBUyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQTtTQUM3QjtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILFNBQVMsWUFBWSxDQUFDLE1BQWM7UUFDbEMsTUFBTSxPQUFPLEdBQUcsYUFBYSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQTtRQUUvQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ1osTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFBO1NBQ3RDO1FBRUQsYUFBYSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUNsQyxDQUFDO0lBRUQsT0FBTztRQUNMLFVBQVU7UUFDVixXQUFXO1FBQ1gsU0FBUztRQUNULFlBQVk7UUFDWixZQUFZO1FBQ1osYUFBYTtLQUNkLENBQUE7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRW50aXR5LFxuICBJRW5naW5lLFxuICBOZXR3b3JrRW50aXR5IGFzIF9OZXR3b3JrRW50aXR5LFxuICBJTmV0b3dya0VudGl0eSxcbiAgTmV0d29ya1BhcmVudCBhcyBfTmV0d29ya1BhcmVudCxcbiAgVHJhbnNmb3JtIGFzIF9UcmFuc2Zvcm0sXG4gIFN5bmNDb21wb25lbnRzIGFzIF9TeW5jQ29tcG9uZW50cyxcbiAgSU5ldG93cmtQYXJlbnQsXG4gIFRyYW5zZm9ybUNvbXBvbmVudCxcbiAgSVN5bmNDb21wb25lbnRzXG59IGZyb20gJ0BkY2wvZWNzJ1xuaW1wb3J0IHsgSVByb2ZpbGUgfSBmcm9tICcuL21lc3NhZ2UtYnVzLXN5bmMnXG5pbXBvcnQgeyBOT1RfU1lOQ19DT01QT05FTlRTIH0gZnJvbSAnLi9zdGF0ZSdcblxuZXhwb3J0IHR5cGUgU3luY0VudGl0eSA9IChlbnRpdHlJZDogRW50aXR5LCBjb21wb25lbnRJZHM6IG51bWJlcltdLCBlbnRpdHlFbnVtSWQ/OiBudW1iZXIpID0+IHZvaWRcblxuZXhwb3J0IGZ1bmN0aW9uIGVudGl0eVV0aWxzKGVuZ2luZTogSUVuZ2luZSwgcHJvZmlsZTogSVByb2ZpbGUpIHtcbiAgY29uc3QgTmV0d29ya0VudGl0eSA9IGVuZ2luZS5nZXRDb21wb25lbnQoX05ldHdvcmtFbnRpdHkuY29tcG9uZW50SWQpIGFzIElOZXRvd3JrRW50aXR5XG4gIGNvbnN0IE5ldHdvcmtQYXJlbnQgPSBlbmdpbmUuZ2V0Q29tcG9uZW50KF9OZXR3b3JrUGFyZW50LmNvbXBvbmVudElkKSBhcyBJTmV0b3dya1BhcmVudFxuICBjb25zdCBUcmFuc2Zvcm0gPSBlbmdpbmUuZ2V0Q29tcG9uZW50KF9UcmFuc2Zvcm0uY29tcG9uZW50SWQpIGFzIFRyYW5zZm9ybUNvbXBvbmVudFxuICBjb25zdCBTeW5jQ29tcG9uZW50cyA9IGVuZ2luZS5nZXRDb21wb25lbnQoX1N5bmNDb21wb25lbnRzLmNvbXBvbmVudElkKSBhcyBJU3luY0NvbXBvbmVudHNcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV0d29yayBlbnRpdHkgKHN5bmMpIHRocm91Z2ggY29tbXMsIGFuZCBzeW5jIHRoZSByZWNlaXZlZCBjb21wb25lbnRzXG4gICAqL1xuICBmdW5jdGlvbiBzeW5jRW50aXR5KGVudGl0eUlkOiBFbnRpdHksIGNvbXBvbmVudElkczogbnVtYmVyW10sIGVudGl0eUVudW1JZD86IG51bWJlcikge1xuICAgIGxldCBjb21wb25lbnRzSWRzTXV0YWJsZSA9IFsuLi5jb21wb25lbnRJZHNdXG4gICAgLy8gUHJvZmlsZSBub3QgaW5pdGlhbGl6ZWRcbiAgICBpZiAoIXByb2ZpbGU/Lm5ldHdvcmtJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9maWxlIG5vdCBpbml0aWFsaXplZC4gQ2FsbCBzeW5jRW50aXR5IGluc2lkZSB0aGUgbWFpbigpIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgLy8gV2UgdXNlIHRoZSBuZXR3b3JrSWQgZ2VuZXJhdGVkIGJ5IHRoZSB1c2VyIGFkZHJlc3MgdG8gaWRlbnRpZnkgdGhpcyBlbnRpdHkgdGhyb3VnaCB0aGUgbmV0d29ya1xuICAgIGNvbnN0IG5ldHdvcmtWYWx1ZSA9IHsgZW50aXR5SWQsIG5ldHdvcmtJZDogcHJvZmlsZS5uZXR3b3JrSWQgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gZW50aXR5RW51bUlkLCBpdCBtZWFucyBpcyB0aGUgc2FtZSBlbnRpdHkgZm9yIGFsbCB0aGUgY2xpZW50cyBjcmVhdGVkIG9uIHRoZSBtYWluIGZ1bmNpdG9uLlxuICAgIC8vIFNvIHRoZSBuZXR3b3JrSWQgc2hvdWxkIGJlIHRoZSBzYW1lIGluIGFsbCB0aGUgY2xpZW50cyB0byBhdm9pZCByZS1jcmVhdGluZyB0aGlzIGVudGl0eS5cbiAgICAvLyBGb3IgdGhpcyBjYXNlIHdlIHVzZSBuZXR3b3JrSWQgPSAwLlxuICAgIGlmIChlbnRpdHlFbnVtSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV0d29ya1ZhbHVlLm5ldHdvcmtJZCA9IDBcbiAgICAgIG5ldHdvcmtWYWx1ZS5lbnRpdHlJZCA9IGVudGl0eUVudW1JZCBhcyBFbnRpdHlcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBlbnVtIGlzIGFscmVhZHkgdXNlZFxuICAgICAgZm9yIChjb25zdCBbXywgbmV0d29ya10gb2YgZW5naW5lLmdldEVudGl0aWVzV2l0aChOZXR3b3JrRW50aXR5KSkge1xuICAgICAgICBpZiAobmV0d29yay5uZXR3b3JrSWQgPT09IG5ldHdvcmtWYWx1ZS5uZXR3b3JrSWQgJiYgbmV0d29yay5lbnRpdHlJZCA9PT0gbmV0d29ya1ZhbHVlLmVudGl0eUlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzeW5jRW50aXR5IGZhaWxlZCBiZWNhdXNlIHRoZSBpZCBwcm92aWRlZCBpcyBhbHJlYWR5IGluIHVzZScpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBOT1RfU1lOQ19DT01QT05FTlRTKSB7XG4gICAgICBpZiAoY29tcG9uZW50c0lkc011dGFibGUuaW5jbHVkZXMoY29tcG9uZW50LmNvbXBvbmVudElkKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPICR7Y29tcG9uZW50LmNvbXBvbmVudE5hbWV9IGNhbid0IGJlIHN5bmMgdGhyb3VnaCB0aGUgbmV0d29yayFgKVxuICAgICAgICBjb21wb25lbnRzSWRzTXV0YWJsZSA9IGNvbXBvbmVudHNJZHNNdXRhYmxlLmZpbHRlcigoJCkgPT4gJCAhPT0gY29tcG9uZW50LmNvbXBvbmVudElkKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGlzIG5vdCBkZWZpbmVkLCB0aGVuIGlzIGEgZW50aXR5IGNyZWF0ZWQgaW4gcnVudGltZSAod2hhdCB3ZSBjYWxsZWQgZHluYW1pYy9ydW50aW1lIGVudGl0aWVzKS5cbiAgICBOZXR3b3JrRW50aXR5LmNyZWF0ZU9yUmVwbGFjZShlbnRpdHlJZCwgbmV0d29ya1ZhbHVlKVxuICAgIFN5bmNDb21wb25lbnRzLmNyZWF0ZU9yUmVwbGFjZShlbnRpdHlJZCwgeyBjb21wb25lbnRJZHM6IGNvbXBvbmVudHNJZHNNdXRhYmxlIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBpdGVyYWJsZSBvZiBhbGwgdGhlIGNoaWxkcmVucyBvZiB0aGUgZ2l2ZW4gZW50aXR5LlxuICAgKiBmb3IgKGNvbnN0IGNoaWxkcmVuIG9mIGdldENoaWxkcmVuKHBhcmVudCkpIHsgY29uc29sZS5sb2coY2hpbGRyZW4pIH1cbiAgICogb3IganVzdCA9PiBjb25zdCBjaGlsZHJlbnM6IEVudGl0eVtdID0gQXJyYXkuZnJvbShnZXRDaGlsZHJlbihwYXJlbnQpKVxuICAgKi9cbiAgZnVuY3Rpb24qIGdldENoaWxkcmVuKHBhcmVudDogRW50aXR5KTogSXRlcmFibGU8RW50aXR5PiB7XG4gICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmtFbnRpdHkuZ2V0T3JOdWxsKHBhcmVudClcbiAgICBpZiAobmV0d29yaykge1xuICAgICAgZm9yIChjb25zdCBbZW50aXR5LCBwYXJlbnRdIG9mIGVuZ2luZS5nZXRFbnRpdGllc1dpdGgoTmV0d29ya1BhcmVudCkpIHtcbiAgICAgICAgaWYgKHBhcmVudC5lbnRpdHlJZCA9PT0gbmV0d29yay5lbnRpdHlJZCAmJiBwYXJlbnQubmV0d29ya0lkID09PSBuZXR3b3JrLm5ldHdvcmtJZCkge1xuICAgICAgICAgIHlpZWxkIGVudGl0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Rmlyc3RDaGlsZChlbnRpdHk6IEVudGl0eSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGdldENoaWxkcmVuKGVudGl0eSkpWzBdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFyZW50IGVudGl0eSBvZiB0aGUgZ2l2ZW4gZW50aXR5LlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UGFyZW50KGNoaWxkOiBFbnRpdHkpOiBFbnRpdHkgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBhcmVudCA9IE5ldHdvcmtQYXJlbnQuZ2V0T3JOdWxsKGNoaWxkKVxuICAgIGlmICghcGFyZW50KSByZXR1cm4gdW5kZWZpbmVkXG4gICAgZm9yIChjb25zdCBbZW50aXR5LCBuZXR3b3JrXSBvZiBlbmdpbmUuZ2V0RW50aXRpZXNXaXRoKE5ldHdvcmtFbnRpdHkpKSB7XG4gICAgICBpZiAocGFyZW50Lm5ldHdvcmtJZCA9PT0gbmV0d29yay5uZXR3b3JrSWQgJiYgcGFyZW50LmVudGl0eUlkID09PSBuZXR3b3JrLmVudGl0eUlkKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIG5ldHdvcmsgcGFyZW50aW5nIHRvIHN5bmMgZW50aXRpZXMuXG4gICAqIEVxdWl2YWxlbnQgdG8gVHJhbnNmb3JtLnBhcmVudCBmb3IgbG9jYWwgZW50aXRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIHBhcmVudEVudGl0eShlbnRpdHk6IEVudGl0eSwgcGFyZW50OiBFbnRpdHkpIHtcbiAgICBjb25zdCBuZXR3b3JrID0gTmV0d29ya0VudGl0eS5nZXRPck51bGwocGFyZW50KVxuICAgIGlmICghbmV0d29yaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbnRpdHkgaXMgbm90IHN5bmMuIENhbGwgc3luY0VudGl0eSBvbiB0aGUgcGFyZW50LicpXG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5ldHdvcmsgcGFyZW50IGNvbXBvbmVudFxuICAgIE5ldHdvcmtQYXJlbnQuY3JlYXRlT3JSZXBsYWNlKGVudGl0eSwgbmV0d29yaylcblxuICAgIC8vIElmIHdlIGRvbnQgaGF2ZSBhIHRyYW5zZm9ybSBmb3IgdGhpcyBlbnRpdHksIGNyZWF0ZSBhbiBlbXB0eSBvbmUgdG8gc2VuZCBpdCB0byB0aGUgcmVuZGVyZXJcbiAgICBpZiAoIVRyYW5zZm9ybS5nZXRPck51bGwoZW50aXR5KSkge1xuICAgICAgVHJhbnNmb3JtLmNyZWF0ZShlbnRpdHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIGZvcmNlIHRvIHNlbmQgYSB0aWNrIHVwZGF0ZSBvZiB0aGUgdHJhbnNmb3JtIHNvIHdlIGNhbiBzZW5kIHRoZSBORVcgcGFyZW50IHRvIHRoZSByZW5kZXJlclxuICAgICAgVHJhbnNmb3JtLmdldE11dGFibGUoZW50aXR5KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBuZXR3b3JrIHBhcmVudGluZyBmcm9tIGFuIGVudGl0eVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlUGFyZW50KGVudGl0eTogRW50aXR5KSB7XG4gICAgY29uc3QgbmV0d29yayA9IE5ldHdvcmtFbnRpdHkuZ2V0T3JOdWxsKGVudGl0eSlcblxuICAgIGlmICghbmV0d29yaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbnRpdHkgaXMgbm90IHN5bmMnKVxuICAgIH1cblxuICAgIE5ldHdvcmtQYXJlbnQuZGVsZXRlRnJvbShlbnRpdHkpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN5bmNFbnRpdHksXG4gICAgZ2V0Q2hpbGRyZW4sXG4gICAgZ2V0UGFyZW50LFxuICAgIHBhcmVudEVudGl0eSxcbiAgICByZW1vdmVQYXJlbnQsXG4gICAgZ2V0Rmlyc3RDaGlsZFxuICB9XG59XG4iXX0=