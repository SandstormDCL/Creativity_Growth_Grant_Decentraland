/** @alpha THIS FILE INITIALIZES THE DECENTRALAND RUNTIME. WILL CHANGE SOON */
import { Composite, engine } from '@dcl/ecs';
import { crdtGetState, crdtSendToRenderer, sendBatch } from '~system/EngineApi';
import { createRendererTransport } from './internal/transports/rendererTransport';
import { pollEvents } from './observables';
import { compositeProvider } from './composite-provider';
// Attach CRDT transport
// @internal
export const rendererTransport = createRendererTransport({ crdtSendToRenderer });
engine.addTransport(rendererTransport);
export async function onUpdate(deltaTime) {
    engine.seal();
    await engine.update(deltaTime);
    await pollEvents(sendBatch);
}
/**
 * @internal
 * Function that is called before the first update and after the evaluation of the code.
 */
export async function onStart() {
    const response = await crdtGetState({ data: new Uint8Array() });
    // when this condition is true something like `main.crdt` was pre-loaded from the runtime, we don't need to instance the main.composite
    if (!response.hasEntities) {
        const mainComposite = compositeProvider.getCompositeOrNull('main.composite');
        if (mainComposite) {
            try {
                Composite.instance(engine, mainComposite, compositeProvider);
            }
            catch (err) {
                console.log(`Warning: main.composite couldn't be instanced.`);
                console.error(err);
            }
        }
    }
    if (!!rendererTransport.onmessage) {
        if (response && response.data && response.data.length) {
            for (const byteArray of response.data) {
                rendererTransport.onmessage(byteArray);
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOEVBQThFO0FBQzlFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sVUFBVSxDQUFBO0FBQzVDLE9BQU8sRUFBRSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUE7QUFDL0UsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0seUNBQXlDLENBQUE7QUFDakYsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQTtBQUMxQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQTtBQUV4RCx3QkFBd0I7QUFDeEIsWUFBWTtBQUNaLE1BQU0sQ0FBQyxNQUFNLGlCQUFpQixHQUFHLHVCQUF1QixDQUFDLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQyxDQUFBO0FBQ2hGLE1BQU0sQ0FBQyxZQUFZLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtBQUV0QyxNQUFNLENBQUMsS0FBSyxVQUFVLFFBQVEsQ0FBQyxTQUFpQjtJQUM5QyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUE7SUFDYixNQUFNLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUE7SUFDOUIsTUFBTSxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUE7QUFDN0IsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sQ0FBQyxLQUFLLFVBQVUsT0FBTztJQUMzQixNQUFNLFFBQVEsR0FBRyxNQUFNLFlBQVksQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLFVBQVUsRUFBRSxFQUFFLENBQUMsQ0FBQTtJQUUvRCx1SUFBdUk7SUFDdkksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUU7UUFDekIsTUFBTSxhQUFhLEdBQUcsaUJBQWlCLENBQUMsa0JBQWtCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtRQUM1RSxJQUFJLGFBQWEsRUFBRTtZQUNqQixJQUFJO2dCQUNGLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxDQUFBO2FBQzdEO1lBQUMsT0FBTyxHQUFHLEVBQUU7Z0JBQ1osT0FBTyxDQUFDLEdBQUcsQ0FBQyxnREFBZ0QsQ0FBQyxDQUFBO2dCQUM3RCxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFBO2FBQ25CO1NBQ0Y7S0FDRjtJQUVELElBQUksQ0FBQyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsRUFBRTtRQUNqQyxJQUFJLFFBQVEsSUFBSSxRQUFRLENBQUMsSUFBSSxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ3JELEtBQUssTUFBTSxTQUFTLElBQUksUUFBUSxDQUFDLElBQUksRUFBRTtnQkFDckMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFBO2FBQ3ZDO1NBQ0Y7S0FDRjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGFscGhhIFRISVMgRklMRSBJTklUSUFMSVpFUyBUSEUgREVDRU5UUkFMQU5EIFJVTlRJTUUuIFdJTEwgQ0hBTkdFIFNPT04gKi9cbmltcG9ydCB7IENvbXBvc2l0ZSwgZW5naW5lIH0gZnJvbSAnQGRjbC9lY3MnXG5pbXBvcnQgeyBjcmR0R2V0U3RhdGUsIGNyZHRTZW5kVG9SZW5kZXJlciwgc2VuZEJhdGNoIH0gZnJvbSAnfnN5c3RlbS9FbmdpbmVBcGknXG5pbXBvcnQgeyBjcmVhdGVSZW5kZXJlclRyYW5zcG9ydCB9IGZyb20gJy4vaW50ZXJuYWwvdHJhbnNwb3J0cy9yZW5kZXJlclRyYW5zcG9ydCdcbmltcG9ydCB7IHBvbGxFdmVudHMgfSBmcm9tICcuL29ic2VydmFibGVzJ1xuaW1wb3J0IHsgY29tcG9zaXRlUHJvdmlkZXIgfSBmcm9tICcuL2NvbXBvc2l0ZS1wcm92aWRlcidcblxuLy8gQXR0YWNoIENSRFQgdHJhbnNwb3J0XG4vLyBAaW50ZXJuYWxcbmV4cG9ydCBjb25zdCByZW5kZXJlclRyYW5zcG9ydCA9IGNyZWF0ZVJlbmRlcmVyVHJhbnNwb3J0KHsgY3JkdFNlbmRUb1JlbmRlcmVyIH0pXG5lbmdpbmUuYWRkVHJhbnNwb3J0KHJlbmRlcmVyVHJhbnNwb3J0KVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gb25VcGRhdGUoZGVsdGFUaW1lOiBudW1iZXIpIHtcbiAgZW5naW5lLnNlYWwoKVxuICBhd2FpdCBlbmdpbmUudXBkYXRlKGRlbHRhVGltZSlcbiAgYXdhaXQgcG9sbEV2ZW50cyhzZW5kQmF0Y2gpXG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBhbmQgYWZ0ZXIgdGhlIGV2YWx1YXRpb24gb2YgdGhlIGNvZGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvblN0YXJ0KCkge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZHRHZXRTdGF0ZSh7IGRhdGE6IG5ldyBVaW50OEFycmF5KCkgfSlcblxuICAvLyB3aGVuIHRoaXMgY29uZGl0aW9uIGlzIHRydWUgc29tZXRoaW5nIGxpa2UgYG1haW4uY3JkdGAgd2FzIHByZS1sb2FkZWQgZnJvbSB0aGUgcnVudGltZSwgd2UgZG9uJ3QgbmVlZCB0byBpbnN0YW5jZSB0aGUgbWFpbi5jb21wb3NpdGVcbiAgaWYgKCFyZXNwb25zZS5oYXNFbnRpdGllcykge1xuICAgIGNvbnN0IG1haW5Db21wb3NpdGUgPSBjb21wb3NpdGVQcm92aWRlci5nZXRDb21wb3NpdGVPck51bGwoJ21haW4uY29tcG9zaXRlJylcbiAgICBpZiAobWFpbkNvbXBvc2l0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgQ29tcG9zaXRlLmluc3RhbmNlKGVuZ2luZSwgbWFpbkNvbXBvc2l0ZSwgY29tcG9zaXRlUHJvdmlkZXIpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFdhcm5pbmc6IG1haW4uY29tcG9zaXRlIGNvdWxkbid0IGJlIGluc3RhbmNlZC5gKVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoISFyZW5kZXJlclRyYW5zcG9ydC5vbm1lc3NhZ2UpIHtcbiAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBieXRlQXJyYXkgb2YgcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICByZW5kZXJlclRyYW5zcG9ydC5vbm1lc3NhZ2UoYnl0ZUFycmF5KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19