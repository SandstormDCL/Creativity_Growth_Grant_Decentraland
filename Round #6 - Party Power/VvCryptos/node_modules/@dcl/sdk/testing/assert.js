// VERBATIM COPY OF https://github.com/LemonPi/deep-close-to
const pSlice = Array.prototype.slice;
const floatEpsilon = 0.0000001;
export function assertEquals(a, b, message = 'Values are not equal') {
    if (!deepCloseTo(a, b))
        throw new Error(`${message} - ${JSON.stringify(a)} != ${JSON.stringify(b)}`);
}
export function assert(a, message = 'assertion failed') {
    if (!a)
        throw new Error(message);
}
export function assertComponentValue(entity, component, value) {
    assert(component.has(entity), `The entity doesn't have a ${component.componentName} component`);
    assertEquals(component.get(entity), value, `Invalid ${component.componentName} values`);
}
export function deepCloseTo(actual, expected, options = {}) {
    const opts = Object.assign({}, { comp: closeTo }, options);
    // 7.1. All identical values are equivalent, as determined by ===.
    if (actual === expected) {
        return true;
    }
    else if (actual instanceof Date && expected instanceof Date) {
        return opts.comp(actual, expected);
        // 7.3. Other pairs that do not both pass typeof value == 'object',
        // equivalence is determined by ==.
    }
    else if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
        if (opts.strict) {
            if (!actual && !expected) {
                return actual === expected;
            }
            if (typeof actual !== typeof expected) {
                return false;
            }
        }
        if (!actual && !expected) {
            return actual === expected;
        }
        return opts.comp(actual, expected);
        // 7.4. For all other Object pairs, including Array objects, equivalence is
        // determined by having the same number of owned properties (as verified
        // with Object.prototype.hasOwnProperty.call), the same set of keys
        // (although not necessarily the same order), equivalent values for every
        // corresponding key, and an identical 'prototype' property. Note: this
        // accounts for both named and indexed properties on Arrays.
    }
    else {
        return objEquiv(actual, expected, opts);
    }
}
function isUndefinedOrNull(value) {
    return value === null || value === undefined;
}
function isBuffer(x) {
    if (!x || typeof x !== 'object' || typeof x.length !== 'number')
        return false;
    if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
        return false;
    }
    if (x.length > 0 && typeof x[0] !== 'number')
        return false;
    return true;
}
function objEquiv(a, b, opts) {
    let i, key;
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
        return false;
    // an identical 'prototype' property.
    if (a.prototype !== b.prototype)
        return false;
    //~~~I've managed to break Object.keys through screwy arguments passing.
    //   Converting to array solves the problem.
    if (isArguments(a)) {
        if (!isArguments(b)) {
            return false;
        }
        return deepCloseTo(pSlice.call(a), pSlice.call(b), opts);
    }
    if (isBuffer(a)) {
        if (!isBuffer(b)) {
            return false;
        }
        if (a.length !== b.length)
            return false;
        for (i = 0; i < a.length; i++) {
            if (a[i] !== b[i])
                return false;
        }
        return true;
    }
    try {
        const ka = Object.keys(a);
        const kb = Object.keys(b);
        // having the same number of owned properties (keys incorporates
        // hasOwnProperty)
        if (ka.length !== kb.length)
            return false;
        //the same set of keys (although not necessarily the same order),
        ka.sort();
        kb.sort();
        //~~~cheap key test
        for (i = ka.length - 1; i >= 0; i--) {
            if (ka[i] !== kb[i])
                return false;
        }
        //equivalent values for every corresponding key, and
        //~~~possibly expensive deep test
        for (i = ka.length - 1; i >= 0; i--) {
            key = ka[i];
            if (!deepCloseTo(a[key], b[key], opts))
                return false;
        }
    }
    catch (e) {
        //happens when one is a string literal and the other isn't
        return false;
    }
    return typeof a === typeof b;
}
function isArguments(object) {
    return Object.prototype.toString.call(object) === '[object Arguments]';
}
function closeTo(actual, expected, delta = floatEpsilon) {
    return Math.abs(actual - expected) < delta;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZXJ0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3Rlc3RpbmcvYXNzZXJ0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDREQUE0RDtBQUk1RCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQTtBQUVwQyxNQUFNLFlBQVksR0FBRyxTQUFTLENBQUE7QUFJOUIsTUFBTSxVQUFVLFlBQVksQ0FBQyxDQUFNLEVBQUUsQ0FBTSxFQUFFLFVBQWtCLHNCQUFzQjtJQUNuRixJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsT0FBTyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUE7QUFDdEcsQ0FBQztBQUVELE1BQU0sVUFBVSxNQUFNLENBQUMsQ0FBTSxFQUFFLFVBQWtCLGtCQUFrQjtJQUNqRSxJQUFJLENBQUMsQ0FBQztRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUE7QUFDbEMsQ0FBQztBQUVELE1BQU0sVUFBVSxvQkFBb0IsQ0FDbEMsTUFBYyxFQUNkLFNBQXVELEVBQ3ZELEtBQVE7SUFFUixNQUFNLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSw2QkFBNkIsU0FBUyxDQUFDLGFBQWEsWUFBWSxDQUFDLENBQUE7SUFDL0YsWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFFLEVBQUUsS0FBSyxFQUFFLFdBQVcsU0FBUyxDQUFDLGFBQWEsU0FBUyxDQUFDLENBQUE7QUFDMUYsQ0FBQztBQUVELE1BQU0sVUFBVSxXQUFXLENBQUMsTUFBVyxFQUFFLFFBQWEsRUFBRSxVQUE0QixFQUFFO0lBQ3BGLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFN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QUFHLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQ1gsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQztnQkFBRSxPQUFPLEtBQUssQ0FBQTtTQUNyRDtLQUNGO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDViwwREFBMEQ7UUFDMUQsT0FBTyxLQUFLLENBQUE7S0FDYjtJQUVELE9BQU8sT0FBTyxDQUFDLEtBQUssT0FBTyxDQUFDLENBQUE7QUFDOUIsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUFDLE1BQVc7SUFDOUIsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssb0JBQW9CLENBQUE7QUFDeEUsQ0FBQztBQUNELFNBQVMsT0FBTyxDQUFDLE1BQVcsRUFBRSxRQUFhLEVBQUUsUUFBZ0IsWUFBWTtJQUN2RSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQTtBQUM1QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVkVSQkFUSU0gQ09QWSBPRiBodHRwczovL2dpdGh1Yi5jb20vTGVtb25QaS9kZWVwLWNsb3NlLXRvXG5cbmltcG9ydCB0eXBlIHsgRW50aXR5LCBMYXN0V3JpdGVXaW5FbGVtZW50U2V0Q29tcG9uZW50RGVmaW5pdGlvbiB9IGZyb20gJ0BkY2wvZWNzJ1xuXG5jb25zdCBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcblxuY29uc3QgZmxvYXRFcHNpbG9uID0gMC4wMDAwMDAxXG5cbnR5cGUgT3B0aW9ucyA9IHsgc3RyaWN0OiBib29sZWFuOyBjb21wOiB0eXBlb2YgY2xvc2VUbyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFcXVhbHMoYTogYW55LCBiOiBhbnksIG1lc3NhZ2U6IHN0cmluZyA9ICdWYWx1ZXMgYXJlIG5vdCBlcXVhbCcpIHtcbiAgaWYgKCFkZWVwQ2xvc2VUbyhhLCBiKSkgdGhyb3cgbmV3IEVycm9yKGAke21lc3NhZ2V9IC0gJHtKU09OLnN0cmluZ2lmeShhKX0gIT0gJHtKU09OLnN0cmluZ2lmeShiKX1gKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGE6IGFueSwgbWVzc2FnZTogc3RyaW5nID0gJ2Fzc2VydGlvbiBmYWlsZWQnKSB7XG4gIGlmICghYSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRDb21wb25lbnRWYWx1ZTxUPihcbiAgZW50aXR5OiBFbnRpdHksXG4gIGNvbXBvbmVudDogTGFzdFdyaXRlV2luRWxlbWVudFNldENvbXBvbmVudERlZmluaXRpb248VD4sXG4gIHZhbHVlOiBUXG4pIHtcbiAgYXNzZXJ0KGNvbXBvbmVudC5oYXMoZW50aXR5KSwgYFRoZSBlbnRpdHkgZG9lc24ndCBoYXZlIGEgJHtjb21wb25lbnQuY29tcG9uZW50TmFtZX0gY29tcG9uZW50YClcbiAgYXNzZXJ0RXF1YWxzKGNvbXBvbmVudC5nZXQoZW50aXR5KSEsIHZhbHVlLCBgSW52YWxpZCAke2NvbXBvbmVudC5jb21wb25lbnROYW1lfSB2YWx1ZXNgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVlcENsb3NlVG8oYWN0dWFsOiBhbnksIGV4cGVjdGVkOiBhbnksIG9wdGlvbnM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7fSk6IGJvb2xlYW4ge1xuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBjb21wOiBjbG9zZVRvIH0sIG9wdGlvbnMpXG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gb3B0cy5jb21wIShhY3R1YWwsIGV4cGVjdGVkKVxuXG4gICAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAgIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgKHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0KSB7XG4gICAgICBpZiAoIWFjdHVhbCAmJiAhZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGFjdHVhbCA9PT0gZXhwZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhY3R1YWwgIT09IHR5cGVvZiBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhY3R1YWwgJiYgIWV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gYWN0dWFsID09PSBleHBlY3RlZFxuICAgIH1cbiAgICByZXR1cm4gb3B0cy5jb21wIShhY3R1YWwsIGV4cGVjdGVkKVxuXG4gICAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gICAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gICAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAgIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAgIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzIGFzIGFueSlcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZTogYW55KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKHg6IGFueSkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZVxuICBpZiAodHlwZW9mIHguY29weSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeC5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYTogYW55LCBiOiBhbnksIG9wdHM6IE9wdGlvbnMpIHtcbiAgbGV0IGksIGtleVxuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpIHJldHVybiBmYWxzZVxuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZVxuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiBkZWVwQ2xvc2VUbyhwU2xpY2UuY2FsbChhKSwgcFNsaWNlLmNhbGwoYiksIG9wdHMpXG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZVxuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGthID0gT2JqZWN0LmtleXMoYSlcbiAgICBjb25zdCBrYiA9IE9iamVjdC5rZXlzKGIpXG5cbiAgICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gICAgLy8gaGFzT3duUHJvcGVydHkpXG4gICAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICAgIGthLnNvcnQoKVxuICAgIGtiLnNvcnQoKVxuICAgIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGthW2ldICE9PSBrYltpXSkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAga2V5ID0ga2FbaV1cbiAgICAgIGlmICghZGVlcENsb3NlVG8oYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiXG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdDogYW55KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSdcbn1cbmZ1bmN0aW9uIGNsb3NlVG8oYWN0dWFsOiBhbnksIGV4cGVjdGVkOiBhbnksIGRlbHRhOiBudW1iZXIgPSBmbG9hdEVwc2lsb24pIHtcbiAgcmV0dXJuIE1hdGguYWJzKGFjdHVhbCAtIGV4cGVjdGVkKSA8IGRlbHRhXG59XG4iXX0=