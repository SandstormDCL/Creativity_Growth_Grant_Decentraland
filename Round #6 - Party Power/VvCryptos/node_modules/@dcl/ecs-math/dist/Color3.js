import { ToLinearSpace, ToGammaSpace } from './types';
import { Color4 } from './Color4';
import { Scalar } from './Scalar';
/**
 * @public
 * Color3 is a type and a namespace.
 * ```
 * // The namespace contains all types and functions to operates with Color3
 * Color3.add(blue, red) // sum component by component resulting pink
 * // The type Color3 is an alias to Color3.ReadonlyColor3
 * const readonlyBlue: Color3 = Color3.Blue()
 * readonlyBlue.r = 0.1 // this FAILS
 *
 * // For mutable usage, use `Color3.Mutable`
 * const blue: Color3.Mutable = Color3.Blue()
 * blue.r = 0.1 // this WORKS
 * ```
 */
export var Color3;
(function (Color3) {
    /**
     * Creates Color3 object from red, green, blue values, all between 0 and 1
     * @param r - defines the red component (between 0 and 1, default is 0)
     * @param g - defines the green component (between 0 and 1, default is 0)
     * @param b - defines the blue component (between 0 and 1, default is 0)
     */
    function create(
    /**
     * Defines the red component (between 0 and 1, default is 0)
     */
    r = 0, 
    /**
     * Defines the green component (between 0 and 1, default is 0)
     */
    g = 0, 
    /**
     * Defines the blue component (between 0 and 1, default is 0)
     */
    b = 0) {
        return { r, g, b };
    }
    Color3.create = create;
    /**
     * Creates a Vector3 from the string containing valid hexadecimal values
     * @param hex - defines a string containing valid hexadecimal values
     * @returns a new Vector3
     */
    function fromHexString(hex) {
        if (hex.substring(0, 1) !== '#' || hex.length !== 7) {
            return create(0, 0, 0);
        }
        const r = parseInt(hex.substring(1, 3), 16);
        const g = parseInt(hex.substring(3, 5), 16);
        const b = parseInt(hex.substring(5, 7), 16);
        return fromInts(r, g, b);
    }
    Color3.fromHexString = fromHexString;
    /**
     * Creates a new Vector3 from the starting index of the given array
     * @param array - defines the source array
     * @param offset - defines an offset in the source array
     * @returns a new Vector3
     */
    function fromArray(array, offset = 0) {
        return create(array[offset], array[offset + 1], array[offset + 2]);
    }
    Color3.fromArray = fromArray;
    /**
     * Creates a Vector3 from integer values (less than 256)
     * @param r - defines the red component to read from (value between 0 and 255)
     * @param g - defines the green component to read from (value between 0 and 255)
     * @param b - defines the blue component to read from (value between 0 and 255)
     * @returns a new Vector3
     */
    function fromInts(r, g, b) {
        return create(r / 255.0, g / 255.0, b / 255.0);
    }
    Color3.fromInts = fromInts;
    /**
     * Creates a Vector3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
     * @param start - defines the start Color3 value
     * @param end - defines the end Color3 value
     * @param amount - defines the gradient value between start and end
     * @returns a new Vector3
     */
    function lerp(start, end, amount) {
        const result = create(0.0, 0.0, 0.0);
        Color3.lerpToRef(start, end, amount, result);
        return result;
    }
    Color3.lerp = lerp;
    /**
     * Creates a Vector3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
     * @param left - defines the start value
     * @param right - defines the end value
     * @param amount - defines the gradient factor
     * @param result - defines the Color3 object where to store the result
     */
    function lerpToRef(left, right, amount, result) {
        result.r = left.r + (right.r - left.r) * amount;
        result.g = left.g + (right.g - left.g) * amount;
        result.b = left.b + (right.b - left.b) * amount;
    }
    Color3.lerpToRef = lerpToRef;
    /**
     * Returns a Color3 value containing a red color
     * @returns a new Vector3
     */
    function Red() {
        return create(1, 0, 0);
    }
    Color3.Red = Red;
    /**
     * Returns a Color3 value containing a green color
     * @returns a new Vector3
     */
    function Green() {
        return create(0, 1, 0);
    }
    Color3.Green = Green;
    /**
     * Returns a Color3 value containing a blue color
     * @returns a new Vector3
     */
    function Blue() {
        return create(0, 0, 1);
    }
    Color3.Blue = Blue;
    /**
     * Returns a Color3 value containing a black color
     * @returns a new Vector3
     */
    function Black() {
        return create(0, 0, 0);
    }
    Color3.Black = Black;
    /**
     * Returns a Color3 value containing a white color
     * @returns a new Vector3
     */
    function White() {
        return create(1, 1, 1);
    }
    Color3.White = White;
    /**
     * Returns a Color3 value containing a purple color
     * @returns a new Vector3
     */
    function Purple() {
        return create(0.5, 0, 0.5);
    }
    Color3.Purple = Purple;
    /**
     * Returns a Color3 value containing a magenta color
     * @returns a new Vector3
     */
    function Magenta() {
        return create(1, 0, 1);
    }
    Color3.Magenta = Magenta;
    /**
     * Returns a Color3 value containing a yellow color
     * @returns a new Vector3
     */
    function Yellow() {
        return create(1, 1, 0);
    }
    Color3.Yellow = Yellow;
    /**
     * Returns a Color3 value containing a gray color
     * @returns a new Vector3
     */
    function Gray() {
        return create(0.5, 0.5, 0.5);
    }
    Color3.Gray = Gray;
    /**
     * Returns a Color3 value containing a teal color
     * @returns a new Vector3
     */
    function Teal() {
        return create(0, 1.0, 1.0);
    }
    Color3.Teal = Teal;
    /**
     * Returns a Color3 value containing a random color
     * @returns a new Vector3
     */
    function Random() {
        return create(Math.random(), Math.random(), Math.random());
    }
    Color3.Random = Random;
    /**
     * Creates a string with the Color3 current values
     * @returns the string representation of the Color3 object
     */
    function toString(value) {
        return '{R: ' + value.r + ' G:' + value.g + ' B:' + value.b + '}';
    }
    Color3.toString = toString;
    /**
     * Compute the Color3 hash code
     * @returns an unique number that can be used to hash Color3 objects
     */
    function getHashCode(value) {
        let hash = value.r || 0;
        hash = (hash * 397) ^ (value.g || 0);
        hash = (hash * 397) ^ (value.b || 0);
        return hash;
    }
    Color3.getHashCode = getHashCode;
    // Operators
    /**
     * Stores in the given array from the given starting index the red, green, blue values as successive elements
     * @param array - defines the array where to store the r,g,b components
     * @param index - defines an optional index in the target array to define where to start storing values
     *
     */
    function toArray(value, array, index = 0) {
        array[index] = value.r;
        array[index + 1] = value.g;
        array[index + 2] = value.b;
    }
    Color3.toArray = toArray;
    /**
     * Returns a new Color4 object from the current Color3 and the given alpha
     * @param alpha - defines the alpha component on the new Color4 object (default is 1)
     * @returns a new Color4 object
     */
    function toColor4(value, alpha = 1) {
        return Color4.create(value.r, value.g, value.b, alpha);
    }
    Color3.toColor4 = toColor4;
    /**
     * Returns a new array populated with 3 numeric elements : red, green and blue values
     * @returns the new array
     */
    function asArray(value) {
        const result = new Array();
        toArray(value, result, 0);
        return result;
    }
    Color3.asArray = asArray;
    /**
     * Returns the luminance value
     * @returns a float value
     */
    function toLuminance(value) {
        return value.r * 0.3 + value.g * 0.59 + value.b * 0.11;
    }
    Color3.toLuminance = toLuminance;
    /**
     * Multiply each Color3 rgb values by the given Color3 rgb values in Color3 object
     * @param otherColor - defines the second operand
     * @returns the create object
     */
    function multiply(value, otherColor) {
        return create(value.r * otherColor.r, value.g * otherColor.g, value.b * otherColor.b);
    }
    Color3.multiply = multiply;
    /**
     * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object "result"
     * @param otherColor - defines the second operand
     * @param result - defines the Color3 object where to store the result
     * @returns the current Color3
     */
    function multiplyToRef(value, otherColor, result) {
        result.r = value.r * otherColor.r;
        result.g = value.g * otherColor.g;
        result.b = value.b * otherColor.b;
    }
    Color3.multiplyToRef = multiplyToRef;
    /**
     * Determines equality between Color3 objects
     * @param otherColor - defines the second operand
     * @returns true if the rgb values are equal to the given ones
     */
    function equals(value, otherColor) {
        return (otherColor &&
            value.r === otherColor.r &&
            value.g === otherColor.g &&
            value.b === otherColor.b);
    }
    Color3.equals = equals;
    /**
     * Determines equality between the current Color3 object and a set of r,b,g values
     * @param r - defines the red component to check
     * @param g - defines the green component to check
     * @param b - defines the blue component to check
     * @returns true if the rgb values are equal to the given ones
     */
    function equalsFloats(value, r, g, b) {
        return value.r === r && value.g === g && value.b === b;
    }
    Color3.equalsFloats = equalsFloats;
    /**
     * Multiplies in place each rgb value by scale
     * @param scale - defines the scaling factor
     * @returns the updated Color3
     */
    function scale(value, scale) {
        return create(value.r * scale, value.g * scale, value.b * scale);
    }
    Color3.scale = scale;
    /**
     * Multiplies the rgb values by scale and stores the result into "result"
     * @param scale - defines the scaling factor
     * @param result - defines the Color3 object where to store the result
     * @returns the unmodified current Color3
     */
    function scaleToRef(value, scale, result) {
        result.r = value.r * scale;
        result.g = value.g * scale;
        result.b = value.b * scale;
    }
    Color3.scaleToRef = scaleToRef;
    /**
     * Scale the current Color3 values by a factor and add the result to a given Color3
     * @param scale - defines the scale factor
     * @param result - defines color to store the result into
     * @returns the unmodified current Color3
     */
    function scaleAndAddToRef(value, scale, result) {
        result.r += value.r * scale;
        result.g += value.g * scale;
        result.b += value.b * scale;
    }
    Color3.scaleAndAddToRef = scaleAndAddToRef;
    /**
     * Clamps the rgb values by the min and max values and stores the result into "result"
     * @param min - defines minimum clamping value (default is 0)
     * @param max - defines maximum clamping value (default is 1)
     * @param result - defines color to store the result into
     * @returns the original Color3
     */
    function clampToRef(value, min = 0, max = 1, result) {
        result.r = Scalar.clamp(value.r, min, max);
        result.g = Scalar.clamp(value.g, min, max);
        result.b = Scalar.clamp(value.b, min, max);
    }
    Color3.clampToRef = clampToRef;
    /**
     * Clamps the rgb values by the min and max values and returns the result
     * @param min - defines minimum clamping value (default is 0)
     * @param max - defines maximum clamping value (default is 1)
     * @returns result
     */
    function clamp(value, min = 0, max = 1) {
        const result = Color3.Black();
        clampToRef(value, min, max, result);
        return result;
    }
    Color3.clamp = clamp;
    /**
     * Creates Color3 set with the added values of the current Color3 and of the given one
     * @param otherColor - defines the second operand
     * @returns the create
     */
    function add(value, otherColor) {
        return create(value.r + otherColor.r, value.g + otherColor.g, value.b + otherColor.b);
    }
    Color3.add = add;
    /**
     * Stores the result of the addition of the current Color3 and given one rgb values into "result"
     * @param otherColor - defines the second operand
     * @param result - defines Color3 object to store the result into
     * @returns the unmodified current Color3
     */
    function addToRef(value, otherColor, result) {
        result.r = value.r + otherColor.r;
        result.g = value.g + otherColor.g;
        result.b = value.b + otherColor.b;
    }
    Color3.addToRef = addToRef;
    /**
     * Returns Color3 set with the subtracted values of the given one from the current Color3
     * @param otherColor - defines the second operand
     * @returns the create
     */
    function subtract(value, otherColor) {
        return create(value.r - otherColor.r, value.g - otherColor.g, value.b - otherColor.b);
    }
    Color3.subtract = subtract;
    /**
     * Stores the result of the subtraction of given one from the current Color3 rgb values into "result"
     * @param otherColor - defines the second operand
     * @param result - defines Color3 object to store the result into
     * @returns the unmodified current Color3
     */
    function subtractToRef(value, otherColor, result) {
        result.r = value.r - otherColor.r;
        result.g = value.g - otherColor.g;
        result.b = value.b - otherColor.b;
    }
    Color3.subtractToRef = subtractToRef;
    /**
     * Copy the current object
     * @returns Color3 copied the current one
     */
    function clone(value) {
        return create(value.r, value.g, value.b);
    }
    Color3.clone = clone;
    /**
     * Copies the rgb values from the source in the current Color3
     * @param source - defines the source Color3 object
     * @returns the updated Color3 object
     */
    function copyFrom(source, dest) {
        dest.r = source.r;
        dest.g = source.g;
        dest.b = source.b;
    }
    Color3.copyFrom = copyFrom;
    /**
     * Updates the Color3 rgb values from the given floats
     * @param dest -
     * @param r - defines the red component to read from
     * @param g - defines the green component to read from
     * @param b - defines the blue component to read from
     * @returns
     */
    function set(dest, r, g, b) {
        dest.r = r;
        dest.g = g;
        dest.b = b;
    }
    Color3.set = set;
    /**
     * Compute the Color3 hexadecimal code as a string
     * @returns a string containing the hexadecimal representation of the Color3 object
     */
    function toHexString(value) {
        const intR = (value.r * 255) | 0;
        const intG = (value.g * 255) | 0;
        const intB = (value.b * 255) | 0;
        return '#' + Scalar.toHex(intR) + Scalar.toHex(intG) + Scalar.toHex(intB);
    }
    Color3.toHexString = toHexString;
    /**
     * Computes Color3 converted from the current one to linear space
     * @returns a new Vector3
     */
    function toLinearSpace(value) {
        const convertedColor = create();
        toLinearSpaceToRef(value, convertedColor);
        return convertedColor;
    }
    Color3.toLinearSpace = toLinearSpace;
    /**
     * Converts the Color3 values to linear space and stores the result in "convertedColor"
     * @param convertedColor - defines the Color3 object where to store the linear space version
     * @returns the unmodified Color3
     */
    function toLinearSpaceToRef(value, convertedColor) {
        convertedColor.r = Math.pow(value.r, ToLinearSpace);
        convertedColor.g = Math.pow(value.g, ToLinearSpace);
        convertedColor.b = Math.pow(value.b, ToLinearSpace);
    }
    Color3.toLinearSpaceToRef = toLinearSpaceToRef;
    /**
     * Computes Color3 converted from the current one to gamma space
     * @returns a new Vector3
     */
    function toGammaSpace(value) {
        const convertedColor = create();
        toGammaSpaceToRef(value, convertedColor);
        return convertedColor;
    }
    Color3.toGammaSpace = toGammaSpace;
    /**
     * Converts the Color3 values to gamma space and stores the result in "convertedColor"
     * @param convertedColor - defines the Color3 object where to store the gamma space version
     * @returns the unmodified Color3
     */
    function toGammaSpaceToRef(value, convertedColor) {
        convertedColor.r = Math.pow(value.r, ToGammaSpace);
        convertedColor.g = Math.pow(value.g, ToGammaSpace);
        convertedColor.b = Math.pow(value.b, ToGammaSpace);
    }
    Color3.toGammaSpaceToRef = toGammaSpaceToRef;
})(Color3 || (Color3 = {}));
