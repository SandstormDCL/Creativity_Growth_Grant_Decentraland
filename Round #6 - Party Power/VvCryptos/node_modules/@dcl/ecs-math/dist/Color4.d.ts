import { Color3 } from './Color3';
/**
 * @public
 * Color4 is a type and a namespace.
 * - The namespace contains all types and functions to operates with Color4
 * - The type Color4 is an alias to Color4.ReadonlyColor4
 * ```
 *
 * // Namespace usage example
 * Color4.add(blue, red) // sum component by component resulting pink
 *
 * // Type usage example
 * const readonlyBlue: Color4 = Color4.Blue()
 * readonlyBlue.a = 0.1 // this FAILS
 *
 * // For mutable usage, use `Color4.Mutable`
 * const blue: Color4.Mutable = Color4.Blue()
 * blue.a = 0.1 // this WORKS
 * ```
 */
export declare type Color4 = Color4.ReadonlyColor4;
/**
 * @public
 * Color4 is a type and a namespace.
 * ```
 * // The namespace contains all types and functions to operates with Color4
 * Color4.add(blue, red) // sum component by component resulting pink
 * // The type Color4 is an alias to Color4.ReadonlyColor4
 * const readonlyBlue: Color4 = Color4.Blue()
 * readonlyBlue.a = 0.1 // this FAILS
 *
 * // For mutable usage, use `Color4.Mutable`
 * const blue: Color4.Mutable = Color4.Blue()
 * blue.a = 0.1 // this WORKS
 * ```
 */
export declare namespace Color4 {
    /**
     * @public
     * For external use, type with `Color4`, e.g. `const blackColor: Color4 = Color4.Black()`.
     * For mutable typing, use `Color4.Mutable`, e.g. `const redColor: Color4.Mutable = Color4.Red()`.
     */
    type ReadonlyColor4 = {
        readonly r: number;
        readonly g: number;
        readonly b: number;
        readonly a: number;
    };
    /**
     * @public
     * For external usage, type with `Color4`, e.g. `const blackColor: Color4 = Color4.Black()`.
     * For mutable typing, use `Color4.Mutable`, e.g. `const redColor: Color4.Mutable = Color4.Red()`.
     */
    type MutableColor4 = {
        r: number;
        g: number;
        b: number;
        a: number;
    };
    /**
     * @public
     * Type with `Color4` for readonly usage, e.g. `const blackColor: Color4 = Color4.Black()`.
     * For mutable, use `Color4.Mutable`, e.g. `const redColor: Color4.Mutable = Color4.Red()`.
     */
    type Mutable = MutableColor4;
    /**
     * Creates create mutable Color4 from red, green, blue values, all between 0 and 1
     * @param r - defines the red component (between 0 and 1, default is 0)
     * @param g - defines the green component (between 0 and 1, default is 0)
     * @param b - defines the blue component (between 0 and 1, default is 0)
     * @param a - defines the alpha component (between 0 and 1, default is 1)
     */
    function create(
    /**
     * Defines the red component (between 0 and 1, default is 0)
     */
    r?: number, 
    /**
     * Defines the green component (between 0 and 1, default is 0)
     */
    g?: number, 
    /**
     * Defines the blue component (between 0 and 1, default is 0)
     */
    b?: number, 
    /**
     * Defines the alpha component (between 0 and 1, default is 1)
     */
    a?: number): MutableColor4;
    /**
     * Creates a Color4 from the string containing valid hexadecimal values
     * @param hex - defines a string containing valid hexadecimal values
     * @returns create mutable Color4
     */
    function fromHexString(hex: string): MutableColor4;
    /**
     * Creates create mutable Color4  set with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
     * @param left - defines the start value
     * @param right - defines the end value
     * @param amount - defines the gradient factor
     * @returns create mutable Color4
     */
    function lerp(left: ReadonlyColor4, right: ReadonlyColor4, amount: number): MutableColor4;
    /**
     * Set the given "result" with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
     * @param left - defines the start value
     * @param right - defines the end value
     * @param amount - defines the gradient factor
     * @param result - defines the Color4 object where to store data
     */
    function lerpToRef(left: ReadonlyColor4, right: ReadonlyColor4, amount: number, result: MutableColor4): void;
    /**
     * Returns a Color4 value containing a red color
     * @returns a new Color4
     */
    function Red(): MutableColor4;
    /**
     * Returns a Color4 value containing a green color
     * @returns create mutable Color4
     */
    function Green(): MutableColor4;
    /**
     * Returns a Color4 value containing a blue color
     * @returns create mutable Color4
     */
    function Blue(): MutableColor4;
    /**
     * Returns a Color4 value containing a black color
     * @returns create mutable Color4
     */
    function Black(): MutableColor4;
    /**
     * Returns a Color4 value containing a white color
     * @returns create mutable Color4
     */
    function White(): MutableColor4;
    /**
     * Returns a Color4 value containing a purple color
     * @returns create mutable Color4
     */
    function Purple(): MutableColor4;
    /**
     * Returns a Color4 value containing a magenta color
     * @returns create mutable Color4
     */
    function Magenta(): MutableColor4;
    /**
     * Returns a Color4 value containing a yellow color
     * @returns create mutable Color4
     */
    function Yellow(): MutableColor4;
    /**
     * Returns a Color4 value containing a gray color
     * @returns create mutable Color4
     */
    function Gray(): MutableColor4;
    /**
     * Returns a Color4 value containing a teal color
     * @returns create mutable Color4
     */
    function Teal(): MutableColor4;
    /**
     * Returns a Color4 value containing a transparent color
     * @returns create mutable Color4
     */
    function Clear(): MutableColor4;
    /**
     * Creates a Color4 from a Color3 and an alpha value
     * @param color3 - defines the source Color3 to read from
     * @param alpha - defines the alpha component (1.0 by default)
     * @returns create mutable Color4
     */
    function fromColor3(color3: Color3.ReadonlyColor3, alpha?: number): MutableColor4;
    /**
     * Creates a Color4 from the starting index element of the given array
     * @param array - defines the source array to read from
     * @param offset - defines the offset in the source array
     * @returns create mutable Color4
     */
    function fromArray(array: ArrayLike<number>, offset?: number): ReadonlyColor4;
    /**
     * Creates a new Color3 from integer values (less than 256)
     * @param r - defines the red component to read from (value between 0 and 255)
     * @param g - defines the green component to read from (value between 0 and 255)
     * @param b - defines the blue component to read from (value between 0 and 255)
     * @param a - defines the alpha component to read from (value between 0 and 255)
     * @returns a new Color4
     */
    function fromInts(r: number, g: number, b: number, a: number): MutableColor4;
    /**
     * Check the content of a given array and convert it to an array containing RGBA data
     * If the original array was already containing count * 4 values then it is returned directly
     * @param colors - defines the array to check
     * @param count - defines the number of RGBA data to expect
     * @returns an array containing count * 4 values (RGBA)
     */
    function checkColors4(colors: number[], count: number): number[];
    /**
     * Adds  the given Color4 values to the ref Color4 object
     * @param a - defines the first operand
     * @param b - defines the second operand
     * @param ref - defines the result rference
     * @returns
     */
    function addToRef(a: ReadonlyColor4, b: ReadonlyColor4, ref: MutableColor4): void;
    /**
     * Stores from the starting index in the given array the Color4 successive values
     * @param array - defines the array where to store the r,g,b components
     * @param index - defines an optional index in the target array to define where to start storing values
     * @returns the current Color4 object
     */
    function toArray(value: ReadonlyColor4, array: number[], index?: number): void;
    /**
     * Creates a Color4 set with the added values of the current Color4 and of the given one
     * @param right - defines the second operand
     * @returns create mutable Color4
     */
    function add(value: ReadonlyColor4, right: ReadonlyColor4): MutableColor4;
    /**
     * Creates a Color4 set with the subtracted values of the given one from the current Color4
     * @param right - defines the second operand
     * @returns create mutable Color4
     */
    function subtract(value: ReadonlyColor4, right: ReadonlyColor4): ReadonlyColor4;
    /**
     * Subtracts the given ones from the current Color4 values and stores the results in "result"
     * @param right - defines the second operand
     * @param result - defines the Color4 object where to store the result
     * @returns the current Color4 object
     */
    function subtractToRef(a: ReadonlyColor4, b: ReadonlyColor4, result: MutableColor4): void;
    /**
     * Creates a Color4 with the current Color4 values multiplied by scale
     * @param scale - defines the scaling factor to apply
     * @returns create mutable Color4
     */
    function scale(value: ReadonlyColor4, scale: number): ReadonlyColor4;
    /**
     * Multiplies the current Color4 values by scale and stores the result in "result"
     * @param scale - defines the scaling factor to apply
     * @param result - defines the Color4 object where to store the result
     */
    function scaleToRef(value: ReadonlyColor4, scale: number, result: MutableColor4): void;
    /**
     * Scale the current Color4 values by a factor and add the result to a given Color4
     * @param scale - defines the scale factor
     * @param result - defines the Color4 object where to store the result
     */
    function scaleAndAddToRef(value: ReadonlyColor4, scale: number, result: MutableColor4): void;
    /**
     * Clamps the rgb values by the min and max values and stores the result into "result"
     * @param min - defines minimum clamping value (default is 0)
     * @param max - defines maximum clamping value (default is 1)
     * @param result - defines color to store the result into.
     */
    function clampToRef(value: ReadonlyColor4, min: number | undefined, max: number | undefined, result: MutableColor4): void;
    /**
     * Multipy an Color4 value by another and return create mutable Color4
     * @param color - defines the Color4 value to multiply by
     * @returns create mutable Color4
     */
    function multiply(value: ReadonlyColor4, color: ReadonlyColor4): ReadonlyColor4;
    /**
     * Multipy a Color4 value by another and push the result in a reference value
     * @param color - defines the Color4 value to multiply by
     * @param result - defines the Color4 to fill the result in
     * @returns the result Color4
     */
    function multiplyToRef(value: ReadonlyColor4, color: ReadonlyColor4, result: MutableColor4): void;
    /**
     * Creates a string with the Color4 current values
     * @returns the string representation of the Color4 object
     */
    function toString(value: ReadonlyColor4): string;
    /**
     * Compute the Color4 hash code
     * @returns an unique number that can be used to hash Color4 objects
     */
    function getHashCode(value: ReadonlyColor4): number;
    /**
     * Creates a Color4 copied from the current one
     * @returns create mutable Color4
     */
    function clone(value: ReadonlyColor4): MutableColor4;
    /**
     * Copies the given Color4 values into the destination
     * @param source - defines the source Color4 object
     * @param dest - defines the destination Color4 object
     * @returns
     */
    function copyFrom(source: ReadonlyColor4, dest: MutableColor4): void;
    /**
     * Copies the given float values into the current one
     * @param r - defines the red component to read from
     * @param g - defines the green component to read from
     * @param b - defines the blue component to read from
     * @param a - defines the alpha component to read from
     * @returns the current updated Color4 object
     */
    function copyFromFloats(r: number, g: number, b: number, a: number, dest: MutableColor4): void;
    /**
     * Copies the given float values into the current one
     * @param r - defines the red component to read from
     * @param g - defines the green component to read from
     * @param b - defines the blue component to read from
     * @param a - defines the alpha component to read from
     * @returns the current updated Color4 object
     */
    function set(r: number, g: number, b: number, a: number, dest: MutableColor4): void;
    /**
     * Compute the Color4 hexadecimal code as a string
     * @returns a string containing the hexadecimal representation of the Color4 object
     */
    function toHexString(value: ReadonlyColor4): string;
    /**
     * Computes a Color4 converted from the current one to linear space
     * @returns create mutable Color4
     */
    function toLinearSpace(value: ReadonlyColor4): MutableColor4;
    /**
     * Converts the Color4 values to linear space and stores the result in "convertedColor"
     * @param convertedColor - defines the Color4 object where to store the linear space version
     * @returns the unmodified Color4
     */
    function toLinearSpaceToRef(value: ReadonlyColor4, ref: MutableColor4): void;
    /**
     * Computes a Color4 converted from the current one to gamma space
     * @returns create mutable Color4
     */
    function toGammaSpace(value: ReadonlyColor4): ReadonlyColor4;
    /**
     * Converts the Color4 values to gamma space and stores the result in "convertedColor"
     * @param convertedColor - defines the Color4 object where to store the gamma space version
     * @returns the unmodified Color4
     */
    function toGammaSpaceToRef(value: ReadonlyColor4, convertedColor: MutableColor4): void;
}
