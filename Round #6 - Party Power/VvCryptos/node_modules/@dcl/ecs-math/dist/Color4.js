import { Scalar } from './Scalar';
import { ToLinearSpace, ToGammaSpace } from './types';
/**
 * @public
 * Color4 is a type and a namespace.
 * ```
 * // The namespace contains all types and functions to operates with Color4
 * Color4.add(blue, red) // sum component by component resulting pink
 * // The type Color4 is an alias to Color4.ReadonlyColor4
 * const readonlyBlue: Color4 = Color4.Blue()
 * readonlyBlue.a = 0.1 // this FAILS
 *
 * // For mutable usage, use `Color4.Mutable`
 * const blue: Color4.Mutable = Color4.Blue()
 * blue.a = 0.1 // this WORKS
 * ```
 */
export var Color4;
(function (Color4) {
    /**
     * Creates create mutable Color4 from red, green, blue values, all between 0 and 1
     * @param r - defines the red component (between 0 and 1, default is 0)
     * @param g - defines the green component (between 0 and 1, default is 0)
     * @param b - defines the blue component (between 0 and 1, default is 0)
     * @param a - defines the alpha component (between 0 and 1, default is 1)
     */
    function create(
    /**
     * Defines the red component (between 0 and 1, default is 0)
     */
    r = 0, 
    /**
     * Defines the green component (between 0 and 1, default is 0)
     */
    g = 0, 
    /**
     * Defines the blue component (between 0 and 1, default is 0)
     */
    b = 0, 
    /**
     * Defines the alpha component (between 0 and 1, default is 1)
     */
    a = 1) {
        return { r, g, b, a };
    }
    Color4.create = create;
    // Statics
    /**
     * Creates a Color4 from the string containing valid hexadecimal values
     * @param hex - defines a string containing valid hexadecimal values
     * @returns create mutable Color4
     */
    function fromHexString(hex) {
        if (hex.substring(0, 1) !== '#' || (hex.length !== 7 && hex.length !== 9)) {
            return create(0.0, 0.0, 0.0, 1.0);
        }
        const r = parseInt(hex.substring(1, 3), 16);
        const g = parseInt(hex.substring(3, 5), 16);
        const b = parseInt(hex.substring(5, 7), 16);
        const aStr = hex.substring(7, 9);
        const a = aStr ? parseInt(aStr, 16) : 255;
        return Color4.fromInts(r, g, b, a);
    }
    Color4.fromHexString = fromHexString;
    /**
     * Creates create mutable Color4  set with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
     * @param left - defines the start value
     * @param right - defines the end value
     * @param amount - defines the gradient factor
     * @returns create mutable Color4
     */
    function lerp(left, right, amount) {
        const result = create(0.0, 0.0, 0.0, 0.0);
        Color4.lerpToRef(left, right, amount, result);
        return result;
    }
    Color4.lerp = lerp;
    /**
     * Set the given "result" with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
     * @param left - defines the start value
     * @param right - defines the end value
     * @param amount - defines the gradient factor
     * @param result - defines the Color4 object where to store data
     */
    function lerpToRef(left, right, amount, result) {
        result.r = left.r + (right.r - left.r) * amount;
        result.g = left.g + (right.g - left.g) * amount;
        result.b = left.b + (right.b - left.b) * amount;
        result.a = left.a + (right.a - left.a) * amount;
    }
    Color4.lerpToRef = lerpToRef;
    /**
     * Returns a Color4 value containing a red color
     * @returns a new Color4
     */
    function Red() {
        return create(1.0, 0, 0, 1.0);
    }
    Color4.Red = Red;
    /**
     * Returns a Color4 value containing a green color
     * @returns create mutable Color4
     */
    function Green() {
        return create(0, 1.0, 0, 1.0);
    }
    Color4.Green = Green;
    /**
     * Returns a Color4 value containing a blue color
     * @returns create mutable Color4
     */
    function Blue() {
        return create(0, 0, 1.0, 1.0);
    }
    Color4.Blue = Blue;
    /**
     * Returns a Color4 value containing a black color
     * @returns create mutable Color4
     */
    function Black() {
        return create(0, 0, 0, 1);
    }
    Color4.Black = Black;
    /**
     * Returns a Color4 value containing a white color
     * @returns create mutable Color4
     */
    function White() {
        return create(1, 1, 1, 1);
    }
    Color4.White = White;
    /**
     * Returns a Color4 value containing a purple color
     * @returns create mutable Color4
     */
    function Purple() {
        return create(0.5, 0, 0.5, 1);
    }
    Color4.Purple = Purple;
    /**
     * Returns a Color4 value containing a magenta color
     * @returns create mutable Color4
     */
    function Magenta() {
        return create(1, 0, 1, 1);
    }
    Color4.Magenta = Magenta;
    /**
     * Returns a Color4 value containing a yellow color
     * @returns create mutable Color4
     */
    function Yellow() {
        return create(1, 1, 0, 1);
    }
    Color4.Yellow = Yellow;
    /**
     * Returns a Color4 value containing a gray color
     * @returns create mutable Color4
     */
    function Gray() {
        return create(0.5, 0.5, 0.5, 1.0);
    }
    Color4.Gray = Gray;
    /**
     * Returns a Color4 value containing a teal color
     * @returns create mutable Color4
     */
    function Teal() {
        return create(0, 1.0, 1.0, 1.0);
    }
    Color4.Teal = Teal;
    /**
     * Returns a Color4 value containing a transparent color
     * @returns create mutable Color4
     */
    function Clear() {
        return create(0, 0, 0, 0);
    }
    Color4.Clear = Clear;
    /**
     * Creates a Color4 from a Color3 and an alpha value
     * @param color3 - defines the source Color3 to read from
     * @param alpha - defines the alpha component (1.0 by default)
     * @returns create mutable Color4
     */
    function fromColor3(color3, alpha = 1.0) {
        return create(color3.r, color3.g, color3.b, alpha);
    }
    Color4.fromColor3 = fromColor3;
    /**
     * Creates a Color4 from the starting index element of the given array
     * @param array - defines the source array to read from
     * @param offset - defines the offset in the source array
     * @returns create mutable Color4
     */
    function fromArray(array, offset = 0) {
        return create(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
    }
    Color4.fromArray = fromArray;
    /**
     * Creates a new Color3 from integer values (less than 256)
     * @param r - defines the red component to read from (value between 0 and 255)
     * @param g - defines the green component to read from (value between 0 and 255)
     * @param b - defines the blue component to read from (value between 0 and 255)
     * @param a - defines the alpha component to read from (value between 0 and 255)
     * @returns a new Color4
     */
    function fromInts(r, g, b, a) {
        return create(r / 255.0, g / 255.0, b / 255.0, a / 255.0);
    }
    Color4.fromInts = fromInts;
    /**
     * Check the content of a given array and convert it to an array containing RGBA data
     * If the original array was already containing count * 4 values then it is returned directly
     * @param colors - defines the array to check
     * @param count - defines the number of RGBA data to expect
     * @returns an array containing count * 4 values (RGBA)
     */
    function checkColors4(colors, count) {
        // Check if color3 was used
        if (colors.length === count * 3) {
            const colors4 = [];
            for (let index = 0; index < colors.length; index += 3) {
                const newIndex = (index / 3) * 4;
                colors4[newIndex] = colors[index];
                colors4[newIndex + 1] = colors[index + 1];
                colors4[newIndex + 2] = colors[index + 2];
                colors4[newIndex + 3] = 1.0;
            }
            return colors4;
        }
        return colors;
    }
    Color4.checkColors4 = checkColors4;
    // Operators
    /**
     * Adds  the given Color4 values to the ref Color4 object
     * @param a - defines the first operand
     * @param b - defines the second operand
     * @param ref - defines the result rference
     * @returns
     */
    function addToRef(a, b, ref) {
        ref.r = a.r + b.r;
        ref.g = a.g + b.g;
        ref.b = a.b + b.b;
        ref.a = a.a + b.a;
    }
    Color4.addToRef = addToRef;
    /**
     * Stores from the starting index in the given array the Color4 successive values
     * @param array - defines the array where to store the r,g,b components
     * @param index - defines an optional index in the target array to define where to start storing values
     * @returns the current Color4 object
     */
    function toArray(value, array, index = 0) {
        array[index] = value.r;
        array[index + 1] = value.g;
        array[index + 2] = value.b;
        array[index + 3] = value.a;
    }
    Color4.toArray = toArray;
    /**
     * Creates a Color4 set with the added values of the current Color4 and of the given one
     * @param right - defines the second operand
     * @returns create mutable Color4
     */
    function add(value, right) {
        const ret = Clear();
        addToRef(value, right, ret);
        return ret;
    }
    Color4.add = add;
    /**
     * Creates a Color4 set with the subtracted values of the given one from the current Color4
     * @param right - defines the second operand
     * @returns create mutable Color4
     */
    function subtract(value, right) {
        const ret = Clear();
        subtractToRef(value, right, ret);
        return ret;
    }
    Color4.subtract = subtract;
    /**
     * Subtracts the given ones from the current Color4 values and stores the results in "result"
     * @param right - defines the second operand
     * @param result - defines the Color4 object where to store the result
     * @returns the current Color4 object
     */
    function subtractToRef(a, b, result) {
        result.r = a.r - b.r;
        result.g = a.g - b.g;
        result.b = a.b - b.b;
        result.a = a.a - b.a;
    }
    Color4.subtractToRef = subtractToRef;
    /**
     * Creates a Color4 with the current Color4 values multiplied by scale
     * @param scale - defines the scaling factor to apply
     * @returns create mutable Color4
     */
    function scale(value, scale) {
        return create(value.r * scale, value.g * scale, value.b * scale, value.a * scale);
    }
    Color4.scale = scale;
    /**
     * Multiplies the current Color4 values by scale and stores the result in "result"
     * @param scale - defines the scaling factor to apply
     * @param result - defines the Color4 object where to store the result
     */
    function scaleToRef(value, scale, result) {
        result.r = value.r * scale;
        result.g = value.g * scale;
        result.b = value.b * scale;
        result.a = value.a * scale;
    }
    Color4.scaleToRef = scaleToRef;
    /**
     * Scale the current Color4 values by a factor and add the result to a given Color4
     * @param scale - defines the scale factor
     * @param result - defines the Color4 object where to store the result
     */
    function scaleAndAddToRef(value, scale, result) {
        result.r += value.r * scale;
        result.g += value.g * scale;
        result.b += value.b * scale;
        result.a += value.a * scale;
    }
    Color4.scaleAndAddToRef = scaleAndAddToRef;
    /**
     * Clamps the rgb values by the min and max values and stores the result into "result"
     * @param min - defines minimum clamping value (default is 0)
     * @param max - defines maximum clamping value (default is 1)
     * @param result - defines color to store the result into.
     */
    function clampToRef(value, min = 0, max = 1, result) {
        result.r = Scalar.clamp(value.r, min, max);
        result.g = Scalar.clamp(value.g, min, max);
        result.b = Scalar.clamp(value.b, min, max);
        result.a = Scalar.clamp(value.a, min, max);
    }
    Color4.clampToRef = clampToRef;
    /**
     * Multipy an Color4 value by another and return create mutable Color4
     * @param color - defines the Color4 value to multiply by
     * @returns create mutable Color4
     */
    function multiply(value, color) {
        return create(value.r * color.r, value.g * color.g, value.b * color.b, value.a * color.a);
    }
    Color4.multiply = multiply;
    /**
     * Multipy a Color4 value by another and push the result in a reference value
     * @param color - defines the Color4 value to multiply by
     * @param result - defines the Color4 to fill the result in
     * @returns the result Color4
     */
    function multiplyToRef(value, color, result) {
        result.r = value.r * color.r;
        result.g = value.g * color.g;
        result.b = value.b * color.b;
        result.a = value.a * color.a;
    }
    Color4.multiplyToRef = multiplyToRef;
    /**
     * Creates a string with the Color4 current values
     * @returns the string representation of the Color4 object
     */
    function toString(value) {
        return ('{R: ' +
            value.r +
            ' G:' +
            value.g +
            ' B:' +
            value.b +
            ' A:' +
            value.a +
            '}');
    }
    Color4.toString = toString;
    /**
     * Compute the Color4 hash code
     * @returns an unique number that can be used to hash Color4 objects
     */
    function getHashCode(value) {
        let hash = value.r || 0;
        hash = (hash * 397) ^ (value.g || 0);
        hash = (hash * 397) ^ (value.b || 0);
        hash = (hash * 397) ^ (value.a || 0);
        return hash;
    }
    Color4.getHashCode = getHashCode;
    /**
     * Creates a Color4 copied from the current one
     * @returns create mutable Color4
     */
    function clone(value) {
        return create(value.r, value.g, value.b, value.a);
    }
    Color4.clone = clone;
    /**
     * Copies the given Color4 values into the destination
     * @param source - defines the source Color4 object
     * @param dest - defines the destination Color4 object
     * @returns
     */
    function copyFrom(source, dest) {
        dest.r = source.r;
        dest.g = source.g;
        dest.b = source.b;
        dest.a = source.a;
    }
    Color4.copyFrom = copyFrom;
    /**
     * Copies the given float values into the current one
     * @param r - defines the red component to read from
     * @param g - defines the green component to read from
     * @param b - defines the blue component to read from
     * @param a - defines the alpha component to read from
     * @returns the current updated Color4 object
     */
    function copyFromFloats(r, g, b, a, dest) {
        dest.r = r;
        dest.g = g;
        dest.b = b;
        dest.a = a;
    }
    Color4.copyFromFloats = copyFromFloats;
    /**
     * Copies the given float values into the current one
     * @param r - defines the red component to read from
     * @param g - defines the green component to read from
     * @param b - defines the blue component to read from
     * @param a - defines the alpha component to read from
     * @returns the current updated Color4 object
     */
    function set(r, g, b, a, dest) {
        dest.r = r;
        dest.g = g;
        dest.b = b;
        dest.a = a;
    }
    Color4.set = set;
    /**
     * Compute the Color4 hexadecimal code as a string
     * @returns a string containing the hexadecimal representation of the Color4 object
     */
    function toHexString(value) {
        const intR = (value.r * 255) | 0;
        const intG = (value.g * 255) | 0;
        const intB = (value.b * 255) | 0;
        const intA = (value.a * 255) | 0;
        return ('#' +
            Scalar.toHex(intR) +
            Scalar.toHex(intG) +
            Scalar.toHex(intB) +
            Scalar.toHex(intA));
    }
    Color4.toHexString = toHexString;
    /**
     * Computes a Color4 converted from the current one to linear space
     * @returns create mutable Color4
     */
    function toLinearSpace(value) {
        const convertedColor = create();
        toLinearSpaceToRef(value, convertedColor);
        return convertedColor;
    }
    Color4.toLinearSpace = toLinearSpace;
    /**
     * Converts the Color4 values to linear space and stores the result in "convertedColor"
     * @param convertedColor - defines the Color4 object where to store the linear space version
     * @returns the unmodified Color4
     */
    function toLinearSpaceToRef(value, ref) {
        ref.r = Math.pow(value.r, ToLinearSpace);
        ref.g = Math.pow(value.g, ToLinearSpace);
        ref.b = Math.pow(value.b, ToLinearSpace);
        ref.a = value.a;
    }
    Color4.toLinearSpaceToRef = toLinearSpaceToRef;
    /**
     * Computes a Color4 converted from the current one to gamma space
     * @returns create mutable Color4
     */
    function toGammaSpace(value) {
        const convertedColor = create();
        toGammaSpaceToRef(value, convertedColor);
        return convertedColor;
    }
    Color4.toGammaSpace = toGammaSpace;
    /**
     * Converts the Color4 values to gamma space and stores the result in "convertedColor"
     * @param convertedColor - defines the Color4 object where to store the gamma space version
     * @returns the unmodified Color4
     */
    function toGammaSpaceToRef(value, convertedColor) {
        convertedColor.r = Math.pow(value.r, ToGammaSpace);
        convertedColor.g = Math.pow(value.g, ToGammaSpace);
        convertedColor.b = Math.pow(value.b, ToGammaSpace);
        convertedColor.a = value.a;
    }
    Color4.toGammaSpaceToRef = toGammaSpaceToRef;
})(Color4 || (Color4 = {}));
