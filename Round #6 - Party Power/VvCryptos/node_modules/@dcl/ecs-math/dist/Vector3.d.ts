import { FloatArray } from './types';
import { Quaternion } from './Quaternion';
import { Matrix } from './Matrix';
/**
 * @public
 * Vector3 is a type and a namespace.
 * - The namespace contains all types and functions to operates with Vector3
 * - The type Vector3 is an alias to Vector3.ReadonlyVector3
 * ```
 *
 * // Namespace usage example
 * const next = Vector3.add(pointA, velocityA)
 *
 * // Type usage example
 * const readonlyPosition: Vector3 = Vector3.Zero()
 * readonlyPosition.x = 0.1 // this FAILS
 *
 * // For mutable usage, use `Vector3.Mutable`
 * const position: Vector3.Mutable = Vector3.One()
 * position.x = 3.0 // this WORKS
 * ```
 */
export declare type Vector3 = Vector3.ReadonlyVector3;
/**
 * @public
 * Vector3 is a type and a namespace.
 * ```
 * // The namespace contains all types and functions to operates with Vector3
 * const next = Vector3.add(pointA, velocityA)
 * // The type Vector3 is an alias to Vector3.ReadonlyVector3
 * const readonlyPosition: Vector3 = Vector3.Zero()
 * readonlyPosition.x = 0.1 // this FAILS
 *
 * // For mutable usage, use `Vector3.Mutable`
 * const position: Vector3.Mutable = Vector3.One()
 * position.x = 3.0 // this WORKS
 * ```
 */
export declare namespace Vector3 {
    /**
     * @public
     * For external use, type with `Vector3`, e.g. `const zeroPosition: Vector3 = Vector3.Zero()`.
     * For mutable typing, use `Vector3.Mutable`, e.g. `const upVector: Vector3.Mutable = Vector3.Up()`.
     */
    type ReadonlyVector3 = {
        readonly x: number;
        readonly y: number;
        readonly z: number;
    };
    /**
     * @public
     * For external usage, type with `Vector3`, e.g. `const zeroPosition: Vector3 = Vector3.Zero()`.
     * For mutable typing, use `Vector3.Mutable`, e.g. `const upVector: Vector3.Mutable = Vector3.Up()`.
     */
    type MutableVector3 = {
        x: number;
        y: number;
        z: number;
    };
    /**
     * @public
     * Type with `Vector3` for readonly usage, e.g. `const zeroPosition: Vector3 = Vector3.Zero()`.
     * For mutable, use `Vector3.Mutable`, e.g. `const upVector: Vector3.Mutable = Vector3.Up()`.
     */
    type Mutable = MutableVector3;
    /**
     * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same
     * @param vector - vector to check
     */
    function isNonUniform(vector: ReadonlyVector3): boolean;
    /**
     * Creates a new Vector3 object from the given x, y, z (floats) coordinates.
     * @param x - defines the first coordinates (on X axis)
     * @param y - defines the second coordinates (on Y axis)
     * @param z - defines the third coordinates (on Z axis)
     */
    function create(
    /**
     * Defines the first coordinates (on X axis)
     */
    x?: number, 
    /**
     * Defines the second coordinates (on Y axis)
     */
    y?: number, 
    /**
     * Defines the third coordinates (on Z axis)
     */
    z?: number): MutableVector3;
    /**
     * Returns a new Vector3 as the result of the addition of the two given vectors.
     * @param vector1 - the first vector
     * @param vector2 - the second vector
     * @returns the resulting vector
     */
    function add(vector1: ReadonlyVector3, vector2: ReadonlyVector3): MutableVector3;
    /**
     * Performs addition between vectorA and vectorB and stores the result into result
     * @param vectorA - the first vector for the addition operation
     * @param vectorB - the second vector for the addition operation
     * @param result - the vector where the result of the addition is stored
     */
    function addToRef(vectorA: ReadonlyVector3, vectorB: ReadonlyVector3, result: MutableVector3): void;
    /**
     * Returns a new Vector3 as the result of the substraction of the two given vectors.
     * @returns the resulting vector
     */
    function subtract(vector1: ReadonlyVector3, vector2: ReadonlyVector3): MutableVector3;
    /**
     * Performs substraction between vectorA and vectorB and stores the result into result
     * @param vectorA - the first vector for the substraction operation
     * @param vectorB - the second vector for the substraction operation
     * @param result - the vector where the result of the substraction is stored
     */
    function subtractToRef(vectorA: ReadonlyVector3, vectorB: ReadonlyVector3, result: MutableVector3): void;
    /**
     * Subtracts the given floats from the current Vector3 coordinates and set the given vector "result" with this result
     * @param x - defines the x coordinate of the operand
     * @param y - defines the y coordinate of the operand
     * @param z - defines the z coordinate of the operand
     * @param result - defines the Vector3 object where to store the result
     */
    function subtractFromFloatsToRef(vector1: ReadonlyVector3, x: number, y: number, z: number, result: MutableVector3): void;
    /**
     * Returns a new Vector3 with the other sign
     * @returns the resulting vector
     */
    function negate(value: ReadonlyVector3): MutableVector3;
    /**
     * Copy source into dest
     *
     */
    function copyFrom(source: ReadonlyVector3, dest: MutableVector3): void;
    /**
     * Sets the given vector "dest" with the given floats.
     * @param x - defines the x coordinate of the source
     * @param y - defines the y coordinate of the source
     * @param z - defines the z coordinate of the source
     * @param dest - defines the Vector3 where to store the result
     */
    function copyFromFloats(x: number, y: number, z: number, dest: MutableVector3): void;
    /**
     * Returns a new Vector3 with the same value
     * @returns the resulting vector
     */
    function clone(source: ReadonlyVector3): MutableVector3;
    /**
     * Get the clip factor between two vectors
     * @param vector0 - defines the first operand
     * @param vector1 - defines the second operand
     * @param axis - defines the axis to use
     * @param size - defines the size along the axis
     * @returns the clip factor
     */
    function getClipFactor(vector0: ReadonlyVector3, vector1: ReadonlyVector3, axis: ReadonlyVector3, size: number): number;
    /**
     * Get angle between two vectors
     * @param vector0 - angle between vector0 and vector1
     * @param vector1 - angle between vector0 and vector1
     * @param normal - direction of the normal
     * @returns the angle between vector0 and vector1
     */
    function getAngleBetweenVectors(vector0: ReadonlyVector3, vector1: ReadonlyVector3, normal: ReadonlyVector3): number;
    /**
     * Returns a new Vector3 set from the index "offset" of the given array
     * @param array - defines the source array
     * @param offset - defines the offset in the source array
     * @returns the new Vector3
     */
    function fromArray(array: FloatArray, offset?: number): MutableVector3;
    /**
     * Returns a new Vector3 set from the index "offset" of the given FloatArray
     * This function is deprecated.  Use FromArray instead
     * @param array - defines the source array
     * @param offset - defines the offset in the source array
     * @returns the new Vector3
     */
    function fromFloatArray(array: FloatArray, offset?: number): MutableVector3;
    /**
     * Sets the given vector "result" with the element values from the index "offset" of the given array
     * @param array - defines the source array
     * @param offset - defines the offset in the source array
     * @param result - defines the Vector3 where to store the result
     */
    function fromArrayToRef(array: number[], offset: number, result: MutableVector3): void;
    /**
     * Sets the given vector "result" with the element values from the index "offset" of the given FloatArray
     * This function is deprecated.  Use FromArrayToRef instead.
     * @param array - defines the source array
     * @param offset - defines the offset in the source array
     * @param result - defines the Vector3 where to store the result
     */
    function fromFloatArrayToRef(array: FloatArray, offset: number, result: MutableVector3): void;
    /**
     * Gets the length of the Vector3
     * @returns the length of the Vector3
     */
    function length(vector: ReadonlyVector3): number;
    /**
     * Gets the squared length of the Vector3
     * @returns squared length of the Vector3
     */
    function lengthSquared(vector: ReadonlyVector3): number;
    /**
     * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float "scale"
     * @param scale - defines the multiplier factor
     * @returns a new Vector3
     */
    function scaleToRef(vector: ReadonlyVector3, scale: number, result: MutableVector3): void;
    /**
     * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float "scale"
     * @param scale - defines the multiplier factor
     * @returns a new Vector3
     */
    function scale(vector: ReadonlyVector3, scale: number): MutableVector3;
    /**
     * Normalize the current Vector3 with the given input length.
     * Please note that this is an in place operation.
     * @param len - the length of the vector
     * @returns the current updated Vector3
     */
    function normalizeFromLength(vector: ReadonlyVector3, len: number): MutableVector3;
    /**
     * Normalize the current Vector3 with the given input length.
     * Please note that this is an in place operation.
     * @param len - the length of the vector
     * @returns the current updated Vector3
     */
    function normalizeFromLengthToRef(vector: ReadonlyVector3, len: number, result: MutableVector3): void;
    /**
     * Normalize the current Vector3.
     * Please note that this is an in place operation.
     * @returns the current updated Vector3
     */
    function normalize(vector: ReadonlyVector3): MutableVector3;
    /**
     * Normalize the current Vector3.
     * Please note that this is an in place operation.
     * @returns the current updated Vector3
     */
    function normalizeToRef(vector: ReadonlyVector3, result: MutableVector3): void;
    /**
     * Returns the dot product (float) between the vectors "left" and "right"
     * @param left - defines the left operand
     * @param right - defines the right operand
     * @returns the dot product
     */
    function dot(left: ReadonlyVector3, right: ReadonlyVector3): number;
    /**
     * Multiplies this vector (with an implicit 1 in the 4th dimension) and m, and divides by perspective
     * @param matrix - The transformation matrix
     * @returns result Vector3
     */
    function applyMatrix4(vector: ReadonlyVector3, matrix: Matrix.ReadonlyMatrix): MutableVector3;
    /**
     * Multiplies this vector (with an implicit 1 in the 4th dimension) and m, and divides by perspective and set the given vector "result" with this result
     * @param matrix - The transformation matrix
     * @param result - defines the Vector3 object where to store the result
     */
    function applyMatrix4ToRef(vector: ReadonlyVector3, matrix: Matrix.ReadonlyMatrix, result: MutableVector3): void;
    /**
     * Rotates the current Vector3 based on the given quaternion
     * @param q - defines the Quaternion
     * @returns the current Vector3
     */
    function rotate(vector: ReadonlyVector3, q: Quaternion.ReadonlyQuaternion): MutableVector3;
    /**
     * Rotates current Vector3 based on the given quaternion, but applies the rotation to target Vector3.
     * @param q - defines the Quaternion
     * @param result - defines the target Vector3
     * @returns the current Vector3
     */
    function rotateToRef(vector: ReadonlyVector3, q: Quaternion.ReadonlyQuaternion, result: MutableVector3): void;
    /**
     * Returns a new Vector3 located for "amount" (float) on the linear interpolation between the vectors "start" and "end"
     * @param start - defines the start value
     * @param end - defines the end value
     * @param amount - max defines amount between both (between 0 and 1)
     * @returns the new Vector3
     */
    function lerp(start: ReadonlyVector3, end: ReadonlyVector3, amount: number): MutableVector3;
    /**
     * Sets the given vector "result" with the result of the linear interpolation from the vector "start" for "amount" to the vector "end"
     * @param start - defines the start value
     * @param end - defines the end value
     * @param amount - max defines amount between both (between 0 and 1)
     * @param result - defines the Vector3 where to store the result
     */
    function lerpToRef(start: ReadonlyVector3, end: ReadonlyVector3, amount: number, result: MutableVector3): void;
    /**
     * Returns a new Vector3 as the cross product of the vectors "left" and "right"
     * The cross product is then orthogonal to both "left" and "right"
     * @param left - defines the left operand
     * @param right - defines the right operand
     * @returns the cross product
     */
    function cross(left: ReadonlyVector3, right: ReadonlyVector3): MutableVector3;
    /**
     * Sets the given vector "result" with the cross product of "left" and "right"
     * The cross product is then orthogonal to both "left" and "right"
     * @param left - defines the left operand
     * @param right - defines the right operand
     * @param result - defines the Vector3 where to store the result
     */
    function crossToRef(left: ReadonlyVector3, right: ReadonlyVector3, result: MutableVector3): void;
    /**
     * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.
     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
     * @param vector - defines the Vector3 to transform
     * @param transformation - defines the transformation matrix
     * @returns the transformed Vector3
     */
    function transformCoordinates(vector: ReadonlyVector3, transformation: Matrix.ReadonlyMatrix): MutableVector3;
    /**
     * Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given vector
     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
     * @param vector - defines the Vector3 to transform
     * @param transformation - defines the transformation matrix
     * @param result - defines the Vector3 where to store the result
     */
    function transformCoordinatesToRef(vector: ReadonlyVector3, transformation: Matrix.ReadonlyMatrix, result: MutableVector3): void;
    /**
     * Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)
     * This method computes tranformed coordinates only, not transformed direction vectors
     * @param x - define the x coordinate of the source vector
     * @param y - define the y coordinate of the source vector
     * @param z - define the z coordinate of the source vector
     * @param transformation - defines the transformation matrix
     * @param result - defines the Vector3 where to store the result
     */
    function transformCoordinatesFromFloatsToRef(x: number, y: number, z: number, transformation: Matrix.ReadonlyMatrix, result: MutableVector3): void;
    /**
     * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector
     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
     * @param vector - defines the Vector3 to transform
     * @param transformation - defines the transformation matrix
     * @returns the new Vector3
     */
    function transformNormal(vector: ReadonlyVector3, transformation: Matrix.ReadonlyMatrix): MutableVector3;
    /**
     * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector
     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
     * @param vector - defines the Vector3 to transform
     * @param transformation - defines the transformation matrix
     * @param result - defines the Vector3 where to store the result
     */
    function transformNormalToRef(vector: ReadonlyVector3, transformation: Matrix.ReadonlyMatrix, result: MutableVector3): void;
    /**
     * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z)
     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
     * @param x - define the x coordinate of the source vector
     * @param y - define the y coordinate of the source vector
     * @param z - define the z coordinate of the source vector
     * @param transformation - defines the transformation matrix
     * @param result - defines the Vector3 where to store the result
     */
    function transformNormalFromFloatsToRef(x: number, y: number, z: number, transformation: Matrix.ReadonlyMatrix, result: MutableVector3): void;
    /**
     * Returns a new Vector3 located for "amount" on the CatmullRom interpolation spline defined by the vectors "value1", "value2", "value3", "value4"
     * @param value1 - defines the first control point
     * @param value2 - defines the second control point
     * @param value3 - defines the third control point
     * @param value4 - defines the fourth control point
     * @param amount - defines the amount on the spline to use
     * @returns the new Vector3
     */
    function catmullRom(value1: ReadonlyVector3, value2: ReadonlyVector3, value3: ReadonlyVector3, value4: ReadonlyVector3, amount: number): MutableVector3;
    /**
     * Returns a new Vector3 set with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
     * If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
     * If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one
     * @param value - defines the current value
     * @param min - defines the lower range value
     * @param max - defines the upper range value
     * @returns the new Vector3
     */
    function clamp(value: ReadonlyVector3, min: ReadonlyVector3, max: ReadonlyVector3): MutableVector3;
    /**
     * Sets the given vector "result" with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
     * If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
     * If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one
     * @param value - defines the current value
     * @param min - defines the lower range value
     * @param max - defines the upper range value
     * @param result - defines the Vector3 where to store the result
     */
    function clampToRef(value: ReadonlyVector3, min: ReadonlyVector3, max: ReadonlyVector3, result: MutableVector3): void;
    /**
     * Returns a new Vector3 located for "amount" (float) on the Hermite interpolation spline defined by the vectors "value1", "tangent1", "value2", "tangent2"
     * @param value1 - defines the first control point
     * @param tangent1 - defines the first tangent vector
     * @param value2 - defines the second control point
     * @param tangent2 - defines the second tangent vector
     * @param amount - defines the amount on the interpolation spline (between 0 and 1)
     * @returns the new Vector3
     */
    function hermite(value1: ReadonlyVector3, tangent1: ReadonlyVector3, value2: ReadonlyVector3, tangent2: ReadonlyVector3, amount: number): MutableVector3;
    /**
     * Gets the minimal coordinate values between two Vector3
     * @param left - defines the first operand
     * @param right - defines the second operand
     * @returns the new Vector3
     */
    function minimize(left: ReadonlyVector3, right: ReadonlyVector3): MutableVector3;
    /**
     * Gets the maximal coordinate values between two Vector3
     * @param left - defines the first operand
     * @param right - defines the second operand
     * @returns the new Vector3
     */
    function maximize(left: MutableVector3, right: MutableVector3): MutableVector3;
    /**
     * Returns the distance between the vectors "value1" and "value2"
     * @param value1 - defines the first operand
     * @param value2 - defines the second operand
     * @returns the distance
     */
    function distance(value1: ReadonlyVector3, value2: ReadonlyVector3): number;
    /**
     * Returns the squared distance between the vectors "value1" and "value2"
     * @param value1 - defines the first operand
     * @param value2 - defines the second operand
     * @returns the squared distance
     */
    function distanceSquared(value1: ReadonlyVector3, value2: ReadonlyVector3): number;
    /**
     * Returns a new Vector3 located at the center between "value1" and "value2"
     * @param value1 - defines the first operand
     * @param value2 - defines the second operand
     * @returns the new Vector3
     */
    function center(value1: ReadonlyVector3, value2: ReadonlyVector3): MutableVector3;
    /**
     * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),
     * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply
     * to something in order to rotate it from its local system to the given target system
     * Note: axis1, axis2 and axis3 are normalized during this operation
     * @param axis1 - defines the first axis
     * @param axis2 - defines the second axis
     * @param axis3 - defines the third axis
     * @returns a new Vector3
     */
    function rotationFromAxis(axis1: MutableVector3, axis2: MutableVector3, axis3: MutableVector3): MutableVector3;
    /**
     * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3
     * @param axis1 - defines the first axis
     * @param axis2 - defines the second axis
     * @param axis3 - defines the third axis
     * @param ref - defines the Vector3 where to store the result
     */
    function rotationFromAxisToRef(axis1: MutableVector3, axis2: MutableVector3, axis3: MutableVector3, result: MutableVector3): void;
    /**
     * Creates a string representation of the Vector3
     * @returns a string with the Vector3 coordinates.
     */
    function toString(vector: ReadonlyVector3): string;
    /**
     * Creates the Vector3 hash code
     * @returns a number which tends to be unique between Vector3 instances
     */
    function getHashCode(vector: ReadonlyVector3): number;
    /**
     * Returns true if the vector1 and the vector2 coordinates are strictly equal
     * @param vector1 - defines the first operand
     * @param vector2 - defines the second operand
     * @returns true if both vectors are equals
     */
    function equals(vector1: ReadonlyVector3, vector2: ReadonlyVector3): boolean;
    /**
     * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon
     * @param otherVector - defines the second operand
     * @param epsilon - defines the minimal distance to define values as equals
     * @returns true if both vectors are distant less than epsilon
     */
    function equalsWithEpsilon(vector1: ReadonlyVector3, vector2: ReadonlyVector3, epsilon?: number): boolean;
    /**
     * Returns true if the current Vector3 coordinates equals the given floats
     * @param x - defines the x coordinate of the operand
     * @param y - defines the y coordinate of the operand
     * @param z - defines the z coordinate of the operand
     * @returns true if both vectors are equals
     */
    function equalsToFloats(vector: ReadonlyVector3, x: number, y: number, z: number): boolean;
    /**
     * Returns a new Vector3, result of the multiplication of vector1 by the vector2
     * @param vector1 - defines the first operand
     * @param vector2 - defines the second operand
     * @returns the new Vector3
     */
    function multiply(vector1: ReadonlyVector3, vector2: ReadonlyVector3): MutableVector3;
    /**
     * Multiplies the current Vector3 by the given one and stores the result in the given vector "result"
     * @param otherVector - defines the second operand
     * @param result - defines the Vector3 object where to store the result
     * @returns the current Vector3
     */
    function multiplyToRef(vector1: ReadonlyVector3, vector2: ReadonlyVector3, result: MutableVector3): void;
    /**
     * Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats
     * @param x - defines the x coordinate of the operand
     * @param y - defines the y coordinate of the operand
     * @param z - defines the z coordinate of the operand
     * @returns the new Vector3
     */
    function multiplyByFloatsToRef(vector1: ReadonlyVector3, x: number, y: number, z: number, result: MutableVector3): void;
    /**
     * Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats
     * @param x - defines the x coordinate of the operand
     * @param y - defines the y coordinate of the operand
     * @param z - defines the z coordinate of the operand
     * @returns the new Vector3
     */
    function multiplyByFloats(vector1: ReadonlyVector3, x: number, y: number, z: number): MutableVector3;
    /**
     * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones
     * @param otherVector - defines the second operand
     * @returns the new Vector3
     */
    function divide(vector1: ReadonlyVector3, vector2: ReadonlyVector3): MutableVector3;
    /**
     * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector "result"
     * @param otherVector - defines the second operand
     * @param result - defines the Vector3 object where to store the result
     * @returns the current Vector3
     */
    function divideToRef(vector1: ReadonlyVector3, vector2: ReadonlyVector3, result: MutableVector3): void;
    /**
     * Set result Vector3 with the maximal coordinate values between vector1 and the given coordinates
     * @param x - defines the x coordinate of the operand
     * @param y - defines the y coordinate of the operand
     * @param z - defines the z coordinate of the operand
     * @param result - the set Vector3
     */
    function maximizeInPlaceFromFloatsToRef(vector1: ReadonlyVector3, x: number, y: number, z: number, result: MutableVector3): void;
    /**
     * Set result Vector3 with the minimal coordinate values between vector1 and the given coordinates
     * @param x - defines the x coordinate of the operand
     * @param y - defines the y coordinate of the operand
     * @param z - defines the z coordinate of the operand
     * @param result - the set Vector3
     */
    function minimizeInPlaceFromFloatsToRef(vector1: ReadonlyVector3, x: number, y: number, z: number, result: MutableVector3): void;
    /**
     * Gets a new Vector3 from vector1 floored values
     * @returns a new Vector3
     */
    function floor(vector1: ReadonlyVector3): MutableVector3;
    /**
     * Gets a new Vector3 from vector1 floored values
     * @returns a new Vector3
     */
    function fract(vector1: ReadonlyVector3): MutableVector3;
    /**
     * Returns a new Vector3 set to (0.0, 0.0, 0.0)
     * @returns a new empty Vector3
     */
    function Zero(): MutableVector3;
    /**
     * Returns a new Vector3 set to (1.0, 1.0, 1.0)
     * @returns a new unit Vector3
     */
    function One(): MutableVector3;
    /**
     * Returns a new Vector3 set tolengthSquared (0.0, 1.0, 0.0)
     * @returns a new up Vector3
     */
    function Up(): MutableVector3;
    /**
     * Returns a new Vector3 set to (0.0, -1.0, 0.0)
     * @returns a new down Vector3
     */
    function Down(): MutableVector3;
    /**
     * Returns a new Vector3 set to (0.0, 0.0, 1.0)
     * @returns a new forward Vector3
     */
    function Forward(): MutableVector3;
    /**
     * Returns a new Vector3 set to (0.0, 0.0, -1.0)
     * @returns a new forward Vector3
     */
    function Backward(): MutableVector3;
    /**
     * Returns a new Vector3 set to (1.0, 0.0, 0.0)
     * @returns a new right Vector3
     */
    function Right(): MutableVector3;
    /**
     * Returns a new Vector3 set to (-1.0, 0.0, 0.0)
     * @returns a new left Vector3
     */
    function Left(): MutableVector3;
    /**
     * Returns a new random Vector3
     * @returns a random Vector3
     */
    function Random(): MutableVector3;
}
