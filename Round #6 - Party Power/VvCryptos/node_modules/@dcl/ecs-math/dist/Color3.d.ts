import { FloatArray } from './types';
import { Color4 } from './Color4';
/**
 * @public
 * Color3 is a type and a namespace.
 * - The namespace contains all types and functions to operates with Color3
 * - The type Color3 is an alias to Color3.ReadonlyColor3
 * ```
 *
 * // Namespace usage example
 * Color3.add(blue, red) // sum component by component resulting pink
 *
 * // Type usage example
 * const readonlyBlue: Color3 = Color3.Blue()
 * readonlyBlue.r = 0.1 // this FAILS
 *
 * // For mutable usage, use `Color3.Mutable`
 * const blue: Color3.Mutable = Color3.Blue()
 * blue.r = 0.1 // this WORKS
 * ```
 */
export declare type Color3 = Color3.ReadonlyColor3;
/**
 * @public
 * Color3 is a type and a namespace.
 * ```
 * // The namespace contains all types and functions to operates with Color3
 * Color3.add(blue, red) // sum component by component resulting pink
 * // The type Color3 is an alias to Color3.ReadonlyColor3
 * const readonlyBlue: Color3 = Color3.Blue()
 * readonlyBlue.r = 0.1 // this FAILS
 *
 * // For mutable usage, use `Color3.Mutable`
 * const blue: Color3.Mutable = Color3.Blue()
 * blue.r = 0.1 // this WORKS
 * ```
 */
export declare namespace Color3 {
    /**
     * @public
     * For external use, type with `Color3`, e.g. `const blackColor: Color3 = Color3.Black()`.
     * For mutable typing, use `Color3.Mutable`, e.g. `const redColor: Color3.Mutable = Color3.Red()`.
     */
    type ReadonlyColor3 = {
        readonly r: number;
        readonly g: number;
        readonly b: number;
    };
    /**
     * @public
     * For external usage, type with `Color3`, e.g. `const blackColor: Color3 = Color3.Black()`.
     * For mutable typing, use `Color3.Mutable`, e.g. `const redColor: Color3.Mutable = Color3.Red()`.
     */
    type MutableColor3 = {
        r: number;
        g: number;
        b: number;
    };
    /**
     * @public
     * Type with `Color3` for readonly usage, e.g. `const blackColor: Color3 = Color3.Black()`.
     * For mutable, use `Color3.Mutable`, e.g. `const redColor: Color3.Mutable = Color3.Red()`.
     */
    type Mutable = MutableColor3;
    /**
     * Creates Color3 object from red, green, blue values, all between 0 and 1
     * @param r - defines the red component (between 0 and 1, default is 0)
     * @param g - defines the green component (between 0 and 1, default is 0)
     * @param b - defines the blue component (between 0 and 1, default is 0)
     */
    function create(
    /**
     * Defines the red component (between 0 and 1, default is 0)
     */
    r?: number, 
    /**
     * Defines the green component (between 0 and 1, default is 0)
     */
    g?: number, 
    /**
     * Defines the blue component (between 0 and 1, default is 0)
     */
    b?: number): {
        r: number;
        g: number;
        b: number;
    };
    /**
     * Creates a Vector3 from the string containing valid hexadecimal values
     * @param hex - defines a string containing valid hexadecimal values
     * @returns a new Vector3
     */
    function fromHexString(hex: string): MutableColor3;
    /**
     * Creates a new Vector3 from the starting index of the given array
     * @param array - defines the source array
     * @param offset - defines an offset in the source array
     * @returns a new Vector3
     */
    function fromArray(array: ArrayLike<number>, offset?: number): MutableColor3;
    /**
     * Creates a Vector3 from integer values (less than 256)
     * @param r - defines the red component to read from (value between 0 and 255)
     * @param g - defines the green component to read from (value between 0 and 255)
     * @param b - defines the blue component to read from (value between 0 and 255)
     * @returns a new Vector3
     */
    function fromInts(r: number, g: number, b: number): MutableColor3;
    /**
     * Creates a Vector3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
     * @param start - defines the start Color3 value
     * @param end - defines the end Color3 value
     * @param amount - defines the gradient value between start and end
     * @returns a new Vector3
     */
    function lerp(start: ReadonlyColor3, end: ReadonlyColor3, amount: number): MutableColor3;
    /**
     * Creates a Vector3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
     * @param left - defines the start value
     * @param right - defines the end value
     * @param amount - defines the gradient factor
     * @param result - defines the Color3 object where to store the result
     */
    function lerpToRef(left: ReadonlyColor3, right: ReadonlyColor3, amount: number, result: MutableColor3): void;
    /**
     * Returns a Color3 value containing a red color
     * @returns a new Vector3
     */
    function Red(): MutableColor3;
    /**
     * Returns a Color3 value containing a green color
     * @returns a new Vector3
     */
    function Green(): MutableColor3;
    /**
     * Returns a Color3 value containing a blue color
     * @returns a new Vector3
     */
    function Blue(): MutableColor3;
    /**
     * Returns a Color3 value containing a black color
     * @returns a new Vector3
     */
    function Black(): MutableColor3;
    /**
     * Returns a Color3 value containing a white color
     * @returns a new Vector3
     */
    function White(): MutableColor3;
    /**
     * Returns a Color3 value containing a purple color
     * @returns a new Vector3
     */
    function Purple(): MutableColor3;
    /**
     * Returns a Color3 value containing a magenta color
     * @returns a new Vector3
     */
    function Magenta(): MutableColor3;
    /**
     * Returns a Color3 value containing a yellow color
     * @returns a new Vector3
     */
    function Yellow(): MutableColor3;
    /**
     * Returns a Color3 value containing a gray color
     * @returns a new Vector3
     */
    function Gray(): MutableColor3;
    /**
     * Returns a Color3 value containing a teal color
     * @returns a new Vector3
     */
    function Teal(): MutableColor3;
    /**
     * Returns a Color3 value containing a random color
     * @returns a new Vector3
     */
    function Random(): MutableColor3;
    /**
     * Creates a string with the Color3 current values
     * @returns the string representation of the Color3 object
     */
    function toString(value: ReadonlyColor3): string;
    /**
     * Compute the Color3 hash code
     * @returns an unique number that can be used to hash Color3 objects
     */
    function getHashCode(value: ReadonlyColor3): number;
    /**
     * Stores in the given array from the given starting index the red, green, blue values as successive elements
     * @param array - defines the array where to store the r,g,b components
     * @param index - defines an optional index in the target array to define where to start storing values
     *
     */
    function toArray(value: ReadonlyColor3, array: FloatArray, index?: number): void;
    /**
     * Returns a new Color4 object from the current Color3 and the given alpha
     * @param alpha - defines the alpha component on the new Color4 object (default is 1)
     * @returns a new Color4 object
     */
    function toColor4(value: ReadonlyColor3, alpha?: number): Color4.MutableColor4;
    /**
     * Returns a new array populated with 3 numeric elements : red, green and blue values
     * @returns the new array
     */
    function asArray(value: ReadonlyColor3): number[];
    /**
     * Returns the luminance value
     * @returns a float value
     */
    function toLuminance(value: ReadonlyColor3): number;
    /**
     * Multiply each Color3 rgb values by the given Color3 rgb values in Color3 object
     * @param otherColor - defines the second operand
     * @returns the create object
     */
    function multiply(value: ReadonlyColor3, otherColor: ReadonlyColor3): MutableColor3;
    /**
     * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object "result"
     * @param otherColor - defines the second operand
     * @param result - defines the Color3 object where to store the result
     * @returns the current Color3
     */
    function multiplyToRef(value: ReadonlyColor3, otherColor: ReadonlyColor3, result: MutableColor3): void;
    /**
     * Determines equality between Color3 objects
     * @param otherColor - defines the second operand
     * @returns true if the rgb values are equal to the given ones
     */
    function equals(value: ReadonlyColor3, otherColor: ReadonlyColor3): boolean;
    /**
     * Determines equality between the current Color3 object and a set of r,b,g values
     * @param r - defines the red component to check
     * @param g - defines the green component to check
     * @param b - defines the blue component to check
     * @returns true if the rgb values are equal to the given ones
     */
    function equalsFloats(value: ReadonlyColor3, r: number, g: number, b: number): boolean;
    /**
     * Multiplies in place each rgb value by scale
     * @param scale - defines the scaling factor
     * @returns the updated Color3
     */
    function scale(value: ReadonlyColor3, scale: number): MutableColor3;
    /**
     * Multiplies the rgb values by scale and stores the result into "result"
     * @param scale - defines the scaling factor
     * @param result - defines the Color3 object where to store the result
     * @returns the unmodified current Color3
     */
    function scaleToRef(value: ReadonlyColor3, scale: number, result: MutableColor3): void;
    /**
     * Scale the current Color3 values by a factor and add the result to a given Color3
     * @param scale - defines the scale factor
     * @param result - defines color to store the result into
     * @returns the unmodified current Color3
     */
    function scaleAndAddToRef(value: ReadonlyColor3, scale: number, result: MutableColor3): void;
    /**
     * Clamps the rgb values by the min and max values and stores the result into "result"
     * @param min - defines minimum clamping value (default is 0)
     * @param max - defines maximum clamping value (default is 1)
     * @param result - defines color to store the result into
     * @returns the original Color3
     */
    function clampToRef(value: ReadonlyColor3, min: number | undefined, max: number | undefined, result: MutableColor3): void;
    /**
     * Clamps the rgb values by the min and max values and returns the result
     * @param min - defines minimum clamping value (default is 0)
     * @param max - defines maximum clamping value (default is 1)
     * @returns result
     */
    function clamp(value: ReadonlyColor3, min?: number, max?: number): MutableColor3;
    /**
     * Creates Color3 set with the added values of the current Color3 and of the given one
     * @param otherColor - defines the second operand
     * @returns the create
     */
    function add(value: ReadonlyColor3, otherColor: ReadonlyColor3): MutableColor3;
    /**
     * Stores the result of the addition of the current Color3 and given one rgb values into "result"
     * @param otherColor - defines the second operand
     * @param result - defines Color3 object to store the result into
     * @returns the unmodified current Color3
     */
    function addToRef(value: ReadonlyColor3, otherColor: ReadonlyColor3, result: MutableColor3): void;
    /**
     * Returns Color3 set with the subtracted values of the given one from the current Color3
     * @param otherColor - defines the second operand
     * @returns the create
     */
    function subtract(value: ReadonlyColor3, otherColor: ReadonlyColor3): MutableColor3;
    /**
     * Stores the result of the subtraction of given one from the current Color3 rgb values into "result"
     * @param otherColor - defines the second operand
     * @param result - defines Color3 object to store the result into
     * @returns the unmodified current Color3
     */
    function subtractToRef(value: ReadonlyColor3, otherColor: ReadonlyColor3, result: MutableColor3): void;
    /**
     * Copy the current object
     * @returns Color3 copied the current one
     */
    function clone(value: ReadonlyColor3): MutableColor3;
    /**
     * Copies the rgb values from the source in the current Color3
     * @param source - defines the source Color3 object
     * @returns the updated Color3 object
     */
    function copyFrom(source: ReadonlyColor3, dest: MutableColor3): void;
    /**
     * Updates the Color3 rgb values from the given floats
     * @param dest -
     * @param r - defines the red component to read from
     * @param g - defines the green component to read from
     * @param b - defines the blue component to read from
     * @returns
     */
    function set(dest: MutableColor3, r: number, g: number, b: number): void;
    /**
     * Compute the Color3 hexadecimal code as a string
     * @returns a string containing the hexadecimal representation of the Color3 object
     */
    function toHexString(value: ReadonlyColor3): string;
    /**
     * Computes Color3 converted from the current one to linear space
     * @returns a new Vector3
     */
    function toLinearSpace(value: ReadonlyColor3): MutableColor3;
    /**
     * Converts the Color3 values to linear space and stores the result in "convertedColor"
     * @param convertedColor - defines the Color3 object where to store the linear space version
     * @returns the unmodified Color3
     */
    function toLinearSpaceToRef(value: ReadonlyColor3, convertedColor: MutableColor3): void;
    /**
     * Computes Color3 converted from the current one to gamma space
     * @returns a new Vector3
     */
    function toGammaSpace(value: ReadonlyColor3): ReadonlyColor3;
    /**
     * Converts the Color3 values to gamma space and stores the result in "convertedColor"
     * @param convertedColor - defines the Color3 object where to store the gamma space version
     * @returns the unmodified Color3
     */
    function toGammaSpaceToRef(value: ReadonlyColor3, convertedColor: MutableColor3): void;
}
