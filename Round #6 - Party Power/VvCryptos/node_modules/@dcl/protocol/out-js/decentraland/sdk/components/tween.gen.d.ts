import _m0 from "protobufjs/minimal";
import { Quaternion, Vector3 } from "../../common/vectors.gen";
export declare const protobufPackage = "decentraland.sdk.components";
/**
 * Implementation guidelines for these easing functions can be found
 * at https://github.com/ai/easings.net/blob/6fcd5f852a470bf1a7890e8178afa0f471d5f2ec/src/easings/easingsFunctions.ts
 */
export declare enum EasingFunction {
    /** EF_LINEAR - default */
    EF_LINEAR = 0,
    EF_EASEINQUAD = 1,
    EF_EASEOUTQUAD = 2,
    EF_EASEQUAD = 3,
    EF_EASEINSINE = 4,
    EF_EASEOUTSINE = 5,
    EF_EASESINE = 6,
    EF_EASEINEXPO = 7,
    EF_EASEOUTEXPO = 8,
    EF_EASEEXPO = 9,
    EF_EASEINELASTIC = 10,
    EF_EASEOUTELASTIC = 11,
    EF_EASEELASTIC = 12,
    EF_EASEINBOUNCE = 13,
    EF_EASEOUTBOUNCE = 14,
    EF_EASEBOUNCE = 15,
    EF_EASEINCUBIC = 16,
    EF_EASEOUTCUBIC = 17,
    EF_EASECUBIC = 18,
    EF_EASEINQUART = 19,
    EF_EASEOUTQUART = 20,
    EF_EASEQUART = 21,
    EF_EASEINQUINT = 22,
    EF_EASEOUTQUINT = 23,
    EF_EASEQUINT = 24,
    EF_EASEINCIRC = 25,
    EF_EASEOUTCIRC = 26,
    EF_EASECIRC = 27,
    EF_EASEINBACK = 28,
    EF_EASEOUTBACK = 29,
    EF_EASEBACK = 30,
    UNRECOGNIZED = -1
}
export declare function easingFunctionFromJSON(object: any): EasingFunction;
export declare function easingFunctionToJSON(object: EasingFunction): string;
export interface PBTween {
    /** in milliseconds */
    duration: number;
    easingFunction: EasingFunction;
    mode?: {
        $case: "move";
        move: Move;
    } | {
        $case: "rotate";
        rotate: Rotate;
    } | {
        $case: "scale";
        scale: Scale;
    } | undefined;
    /** default true (pause or running) */
    playing?: boolean | undefined;
    /** between 0 and 1 */
    currentTime?: number | undefined;
}
export interface Move {
    start: Vector3 | undefined;
    end: Vector3 | undefined;
    faceDirection?: boolean | undefined;
}
export interface Rotate {
    start: Quaternion | undefined;
    end: Quaternion | undefined;
}
export interface Scale {
    start: Vector3 | undefined;
    end: Vector3 | undefined;
}
export declare namespace PBTween {
    function encode(message: PBTween, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBTween;
    function fromJSON(object: any): PBTween;
    function toJSON(message: PBTween): unknown;
    function create<I extends Exact<DeepPartial<PBTween>, I>>(base?: I): PBTween;
    function fromPartial<I extends Exact<DeepPartial<PBTween>, I>>(object: I): PBTween;
}
export declare namespace Move {
    function encode(message: Move, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): Move;
    function fromJSON(object: any): Move;
    function toJSON(message: Move): unknown;
    function create<I extends Exact<DeepPartial<Move>, I>>(base?: I): Move;
    function fromPartial<I extends Exact<DeepPartial<Move>, I>>(object: I): Move;
}
export declare namespace Rotate {
    function encode(message: Rotate, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): Rotate;
    function fromJSON(object: any): Rotate;
    function toJSON(message: Rotate): unknown;
    function create<I extends Exact<DeepPartial<Rotate>, I>>(base?: I): Rotate;
    function fromPartial<I extends Exact<DeepPartial<Rotate>, I>>(object: I): Rotate;
}
export declare namespace Scale {
    function encode(message: Scale, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): Scale;
    function fromJSON(object: any): Scale;
    function toJSON(message: Scale): unknown;
    function create<I extends Exact<DeepPartial<Scale>, I>>(base?: I): Scale;
    function fromPartial<I extends Exact<DeepPartial<Scale>, I>>(object: I): Scale;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]>;
} & {
    $case: T["$case"];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
