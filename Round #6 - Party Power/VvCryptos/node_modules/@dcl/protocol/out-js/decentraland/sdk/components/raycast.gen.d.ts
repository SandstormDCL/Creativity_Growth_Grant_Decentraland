import _m0 from "protobufjs/minimal";
import { Vector3 } from "../../common/vectors.gen";
export declare const protobufPackage = "decentraland.sdk.components";
/** RaycastQueryType indicates whether the ray should stop on the first collition, or continue. */
export declare enum RaycastQueryType {
    /** RQT_HIT_FIRST - Pick the first (not necessarily the closest) hit within the range */
    RQT_HIT_FIRST = 0,
    /** RQT_QUERY_ALL - Pick all hits within the range */
    RQT_QUERY_ALL = 1,
    /** RQT_NONE - Do not perform the raycast, only set the raycast result with empty hits */
    RQT_NONE = 2,
    UNRECOGNIZED = -1
}
export declare function raycastQueryTypeFromJSON(object: any): RaycastQueryType;
export declare function raycastQueryTypeToJSON(object: RaycastQueryType): string;
/**
 * The PBRaycast component and PBRaycastResult are defined in https://adr.decentraland.org/adr/ADR-200
 *
 * The Raycast component allows scenes to request raycasting from the game engine. The results will
 * be available in a RaycastResult component set later on the same Entity.
 */
export interface PBRaycast {
    /** Correlation ID, defined by the scene and used internally by the scene */
    timestamp?: number | undefined;
    /**
     * How much to offset the starting point of the ray, relative to the entity's transform.
     * Defaults to vec3(0,0,0)
     */
    originOffset?: Vector3 | undefined;
    direction?: {
        $case: "localDirection";
        localDirection: Vector3;
    } | {
        $case: "globalDirection";
        globalDirection: Vector3;
    } | {
        $case: "globalTarget";
        globalTarget: Vector3;
    } | {
        $case: "targetEntity";
        targetEntity: number;
    } | undefined;
    /** Maximum length of the ray in virtual meters (global space) */
    maxDistance: number;
    /** the RaycastQueryType behavior */
    queryType: RaycastQueryType;
    /**
     * Indicates the renderer to perform the raycast on every scene tick (ADR-148),
     * otherwise it will be performed only once, defaults to false
     */
    continuous?: boolean | undefined;
    /** Collision mask, by default CL_POINTER | CL_PHYSICS */
    collisionMask?: number | undefined;
}
export declare namespace PBRaycast {
    function encode(message: PBRaycast, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBRaycast;
    function fromJSON(object: any): PBRaycast;
    function toJSON(message: PBRaycast): unknown;
    function create<I extends Exact<DeepPartial<PBRaycast>, I>>(base?: I): PBRaycast;
    function fromPartial<I extends Exact<DeepPartial<PBRaycast>, I>>(object: I): PBRaycast;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]>;
} & {
    $case: T["$case"];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
