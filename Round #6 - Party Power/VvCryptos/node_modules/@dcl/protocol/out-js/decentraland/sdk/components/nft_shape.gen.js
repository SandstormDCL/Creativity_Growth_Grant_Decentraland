"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PBNftShape = exports.NftFrameType = exports.protobufPackage = void 0;
exports.nftFrameTypeFromJSON = nftFrameTypeFromJSON;
exports.nftFrameTypeToJSON = nftFrameTypeToJSON;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const colors_gen_1 = require("../../common/colors.gen");
exports.protobufPackage = "decentraland.sdk.components";
/** NftFrameType is a predefined framing style for the image. */
var NftFrameType;
(function (NftFrameType) {
    NftFrameType[NftFrameType["NFT_CLASSIC"] = 0] = "NFT_CLASSIC";
    NftFrameType[NftFrameType["NFT_BAROQUE_ORNAMENT"] = 1] = "NFT_BAROQUE_ORNAMENT";
    NftFrameType[NftFrameType["NFT_DIAMOND_ORNAMENT"] = 2] = "NFT_DIAMOND_ORNAMENT";
    NftFrameType[NftFrameType["NFT_MINIMAL_WIDE"] = 3] = "NFT_MINIMAL_WIDE";
    NftFrameType[NftFrameType["NFT_MINIMAL_GREY"] = 4] = "NFT_MINIMAL_GREY";
    NftFrameType[NftFrameType["NFT_BLOCKY"] = 5] = "NFT_BLOCKY";
    NftFrameType[NftFrameType["NFT_GOLD_EDGES"] = 6] = "NFT_GOLD_EDGES";
    NftFrameType[NftFrameType["NFT_GOLD_CARVED"] = 7] = "NFT_GOLD_CARVED";
    NftFrameType[NftFrameType["NFT_GOLD_WIDE"] = 8] = "NFT_GOLD_WIDE";
    NftFrameType[NftFrameType["NFT_GOLD_ROUNDED"] = 9] = "NFT_GOLD_ROUNDED";
    NftFrameType[NftFrameType["NFT_METAL_MEDIUM"] = 10] = "NFT_METAL_MEDIUM";
    NftFrameType[NftFrameType["NFT_METAL_WIDE"] = 11] = "NFT_METAL_WIDE";
    NftFrameType[NftFrameType["NFT_METAL_SLIM"] = 12] = "NFT_METAL_SLIM";
    NftFrameType[NftFrameType["NFT_METAL_ROUNDED"] = 13] = "NFT_METAL_ROUNDED";
    NftFrameType[NftFrameType["NFT_PINS"] = 14] = "NFT_PINS";
    NftFrameType[NftFrameType["NFT_MINIMAL_BLACK"] = 15] = "NFT_MINIMAL_BLACK";
    NftFrameType[NftFrameType["NFT_MINIMAL_WHITE"] = 16] = "NFT_MINIMAL_WHITE";
    NftFrameType[NftFrameType["NFT_TAPE"] = 17] = "NFT_TAPE";
    NftFrameType[NftFrameType["NFT_WOOD_SLIM"] = 18] = "NFT_WOOD_SLIM";
    NftFrameType[NftFrameType["NFT_WOOD_WIDE"] = 19] = "NFT_WOOD_WIDE";
    NftFrameType[NftFrameType["NFT_WOOD_TWIGS"] = 20] = "NFT_WOOD_TWIGS";
    NftFrameType[NftFrameType["NFT_CANVAS"] = 21] = "NFT_CANVAS";
    NftFrameType[NftFrameType["NFT_NONE"] = 22] = "NFT_NONE";
    NftFrameType[NftFrameType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(NftFrameType || (exports.NftFrameType = NftFrameType = {}));
function nftFrameTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "NFT_CLASSIC":
            return NftFrameType.NFT_CLASSIC;
        case 1:
        case "NFT_BAROQUE_ORNAMENT":
            return NftFrameType.NFT_BAROQUE_ORNAMENT;
        case 2:
        case "NFT_DIAMOND_ORNAMENT":
            return NftFrameType.NFT_DIAMOND_ORNAMENT;
        case 3:
        case "NFT_MINIMAL_WIDE":
            return NftFrameType.NFT_MINIMAL_WIDE;
        case 4:
        case "NFT_MINIMAL_GREY":
            return NftFrameType.NFT_MINIMAL_GREY;
        case 5:
        case "NFT_BLOCKY":
            return NftFrameType.NFT_BLOCKY;
        case 6:
        case "NFT_GOLD_EDGES":
            return NftFrameType.NFT_GOLD_EDGES;
        case 7:
        case "NFT_GOLD_CARVED":
            return NftFrameType.NFT_GOLD_CARVED;
        case 8:
        case "NFT_GOLD_WIDE":
            return NftFrameType.NFT_GOLD_WIDE;
        case 9:
        case "NFT_GOLD_ROUNDED":
            return NftFrameType.NFT_GOLD_ROUNDED;
        case 10:
        case "NFT_METAL_MEDIUM":
            return NftFrameType.NFT_METAL_MEDIUM;
        case 11:
        case "NFT_METAL_WIDE":
            return NftFrameType.NFT_METAL_WIDE;
        case 12:
        case "NFT_METAL_SLIM":
            return NftFrameType.NFT_METAL_SLIM;
        case 13:
        case "NFT_METAL_ROUNDED":
            return NftFrameType.NFT_METAL_ROUNDED;
        case 14:
        case "NFT_PINS":
            return NftFrameType.NFT_PINS;
        case 15:
        case "NFT_MINIMAL_BLACK":
            return NftFrameType.NFT_MINIMAL_BLACK;
        case 16:
        case "NFT_MINIMAL_WHITE":
            return NftFrameType.NFT_MINIMAL_WHITE;
        case 17:
        case "NFT_TAPE":
            return NftFrameType.NFT_TAPE;
        case 18:
        case "NFT_WOOD_SLIM":
            return NftFrameType.NFT_WOOD_SLIM;
        case 19:
        case "NFT_WOOD_WIDE":
            return NftFrameType.NFT_WOOD_WIDE;
        case 20:
        case "NFT_WOOD_TWIGS":
            return NftFrameType.NFT_WOOD_TWIGS;
        case 21:
        case "NFT_CANVAS":
            return NftFrameType.NFT_CANVAS;
        case 22:
        case "NFT_NONE":
            return NftFrameType.NFT_NONE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return NftFrameType.UNRECOGNIZED;
    }
}
function nftFrameTypeToJSON(object) {
    switch (object) {
        case NftFrameType.NFT_CLASSIC:
            return "NFT_CLASSIC";
        case NftFrameType.NFT_BAROQUE_ORNAMENT:
            return "NFT_BAROQUE_ORNAMENT";
        case NftFrameType.NFT_DIAMOND_ORNAMENT:
            return "NFT_DIAMOND_ORNAMENT";
        case NftFrameType.NFT_MINIMAL_WIDE:
            return "NFT_MINIMAL_WIDE";
        case NftFrameType.NFT_MINIMAL_GREY:
            return "NFT_MINIMAL_GREY";
        case NftFrameType.NFT_BLOCKY:
            return "NFT_BLOCKY";
        case NftFrameType.NFT_GOLD_EDGES:
            return "NFT_GOLD_EDGES";
        case NftFrameType.NFT_GOLD_CARVED:
            return "NFT_GOLD_CARVED";
        case NftFrameType.NFT_GOLD_WIDE:
            return "NFT_GOLD_WIDE";
        case NftFrameType.NFT_GOLD_ROUNDED:
            return "NFT_GOLD_ROUNDED";
        case NftFrameType.NFT_METAL_MEDIUM:
            return "NFT_METAL_MEDIUM";
        case NftFrameType.NFT_METAL_WIDE:
            return "NFT_METAL_WIDE";
        case NftFrameType.NFT_METAL_SLIM:
            return "NFT_METAL_SLIM";
        case NftFrameType.NFT_METAL_ROUNDED:
            return "NFT_METAL_ROUNDED";
        case NftFrameType.NFT_PINS:
            return "NFT_PINS";
        case NftFrameType.NFT_MINIMAL_BLACK:
            return "NFT_MINIMAL_BLACK";
        case NftFrameType.NFT_MINIMAL_WHITE:
            return "NFT_MINIMAL_WHITE";
        case NftFrameType.NFT_TAPE:
            return "NFT_TAPE";
        case NftFrameType.NFT_WOOD_SLIM:
            return "NFT_WOOD_SLIM";
        case NftFrameType.NFT_WOOD_WIDE:
            return "NFT_WOOD_WIDE";
        case NftFrameType.NFT_WOOD_TWIGS:
            return "NFT_WOOD_TWIGS";
        case NftFrameType.NFT_CANVAS:
            return "NFT_CANVAS";
        case NftFrameType.NFT_NONE:
            return "NFT_NONE";
        case NftFrameType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBasePBNftShape() {
    return { urn: "", style: undefined, color: undefined };
}
var PBNftShape;
(function (PBNftShape) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.urn !== "") {
            writer.uint32(10).string(message.urn);
        }
        if (message.style !== undefined) {
            writer.uint32(16).int32(message.style);
        }
        if (message.color !== undefined) {
            colors_gen_1.Color3.encode(message.color, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    }
    PBNftShape.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePBNftShape();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.urn = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.style = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.color = colors_gen_1.Color3.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PBNftShape.decode = decode;
    function fromJSON(object) {
        return {
            urn: isSet(object.urn) ? String(object.urn) : "",
            style: isSet(object.style) ? nftFrameTypeFromJSON(object.style) : undefined,
            color: isSet(object.color) ? colors_gen_1.Color3.fromJSON(object.color) : undefined,
        };
    }
    PBNftShape.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.urn !== undefined && (obj.urn = message.urn);
        message.style !== undefined &&
            (obj.style = message.style !== undefined ? nftFrameTypeToJSON(message.style) : undefined);
        message.color !== undefined && (obj.color = message.color ? colors_gen_1.Color3.toJSON(message.color) : undefined);
        return obj;
    }
    PBNftShape.toJSON = toJSON;
    function create(base) {
        return PBNftShape.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    PBNftShape.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBasePBNftShape();
        message.urn = (_a = object.urn) !== null && _a !== void 0 ? _a : "";
        message.style = (_b = object.style) !== null && _b !== void 0 ? _b : undefined;
        message.color = (object.color !== undefined && object.color !== null)
            ? colors_gen_1.Color3.fromPartial(object.color)
            : undefined;
        return message;
    }
    PBNftShape.fromPartial = fromPartial;
})(PBNftShape || (exports.PBNftShape = PBNftShape = {}));
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=nft_shape.gen.js.map