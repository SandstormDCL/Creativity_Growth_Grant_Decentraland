import _m0 from "protobufjs/minimal";
import { Color3 } from "../../common/colors.gen";
export declare const protobufPackage = "decentraland.sdk.components";
/** NftFrameType is a predefined framing style for the image. */
export declare enum NftFrameType {
    NFT_CLASSIC = 0,
    NFT_BAROQUE_ORNAMENT = 1,
    NFT_DIAMOND_ORNAMENT = 2,
    NFT_MINIMAL_WIDE = 3,
    NFT_MINIMAL_GREY = 4,
    NFT_BLOCKY = 5,
    NFT_GOLD_EDGES = 6,
    NFT_GOLD_CARVED = 7,
    NFT_GOLD_WIDE = 8,
    NFT_GOLD_ROUNDED = 9,
    NFT_METAL_MEDIUM = 10,
    NFT_METAL_WIDE = 11,
    NFT_METAL_SLIM = 12,
    NFT_METAL_ROUNDED = 13,
    NFT_PINS = 14,
    NFT_MINIMAL_BLACK = 15,
    NFT_MINIMAL_WHITE = 16,
    NFT_TAPE = 17,
    NFT_WOOD_SLIM = 18,
    NFT_WOOD_WIDE = 19,
    NFT_WOOD_TWIGS = 20,
    NFT_CANVAS = 21,
    NFT_NONE = 22,
    UNRECOGNIZED = -1
}
export declare function nftFrameTypeFromJSON(object: any): NftFrameType;
export declare function nftFrameTypeToJSON(object: NftFrameType): string;
/**
 * The NftShape component renders a framed picture from an NFT. It supports PNG, JPEG and GIF files.
 *
 * The `urn` field is the URI of the NFT, and must follow the format 'urn:decentraland:<CHAIN>:<CONTRACT_STANDARD>:<CONTRACT_ADDRESS>:<TOKEN_ID>'
 * Example: 'urn:decentraland:ethereum:erc721:0x00000000:123'
 *
 * The picture frame can have several different styles, plus a background color for images that have
 * transparent pixels.
 */
export interface PBNftShape {
    /** the URI of the NFT */
    urn: string;
    /** the frame style (default NFT_CLASSIC) */
    style?: NftFrameType | undefined;
    /** RGB background (default [0.6404918, 0.611472, 0.8584906]) */
    color?: Color3 | undefined;
}
export declare namespace PBNftShape {
    function encode(message: PBNftShape, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBNftShape;
    function fromJSON(object: any): PBNftShape;
    function toJSON(message: PBNftShape): unknown;
    function create<I extends Exact<DeepPartial<PBNftShape>, I>>(base?: I): PBNftShape;
    function fromPartial<I extends Exact<DeepPartial<PBNftShape>, I>>(object: I): PBNftShape;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]>;
} & {
    $case: T["$case"];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
