import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "decentraland.sdk.components";
export declare enum YGPositionType {
    YGPT_RELATIVE = 0,
    YGPT_ABSOLUTE = 1,
    UNRECOGNIZED = -1
}
export declare function yGPositionTypeFromJSON(object: any): YGPositionType;
export declare function yGPositionTypeToJSON(object: YGPositionType): string;
export declare enum YGAlign {
    YGA_AUTO = 0,
    YGA_FLEX_START = 1,
    YGA_CENTER = 2,
    YGA_FLEX_END = 3,
    YGA_STRETCH = 4,
    YGA_BASELINE = 5,
    YGA_SPACE_BETWEEN = 6,
    YGA_SPACE_AROUND = 7,
    UNRECOGNIZED = -1
}
export declare function yGAlignFromJSON(object: any): YGAlign;
export declare function yGAlignToJSON(object: YGAlign): string;
export declare enum YGUnit {
    YGU_UNDEFINED = 0,
    YGU_POINT = 1,
    YGU_PERCENT = 2,
    YGU_AUTO = 3,
    UNRECOGNIZED = -1
}
export declare function yGUnitFromJSON(object: any): YGUnit;
export declare function yGUnitToJSON(object: YGUnit): string;
export declare enum YGFlexDirection {
    YGFD_ROW = 0,
    YGFD_COLUMN = 1,
    YGFD_COLUMN_REVERSE = 2,
    YGFD_ROW_REVERSE = 3,
    UNRECOGNIZED = -1
}
export declare function yGFlexDirectionFromJSON(object: any): YGFlexDirection;
export declare function yGFlexDirectionToJSON(object: YGFlexDirection): string;
export declare enum YGWrap {
    YGW_NO_WRAP = 0,
    YGW_WRAP = 1,
    YGW_WRAP_REVERSE = 2,
    UNRECOGNIZED = -1
}
export declare function yGWrapFromJSON(object: any): YGWrap;
export declare function yGWrapToJSON(object: YGWrap): string;
export declare enum YGJustify {
    YGJ_FLEX_START = 0,
    YGJ_CENTER = 1,
    YGJ_FLEX_END = 2,
    YGJ_SPACE_BETWEEN = 3,
    YGJ_SPACE_AROUND = 4,
    YGJ_SPACE_EVENLY = 5,
    UNRECOGNIZED = -1
}
export declare function yGJustifyFromJSON(object: any): YGJustify;
export declare function yGJustifyToJSON(object: YGJustify): string;
export declare enum YGOverflow {
    YGO_VISIBLE = 0,
    YGO_HIDDEN = 1,
    YGO_SCROLL = 2,
    UNRECOGNIZED = -1
}
export declare function yGOverflowFromJSON(object: any): YGOverflow;
export declare function yGOverflowToJSON(object: YGOverflow): string;
export declare enum YGDisplay {
    YGD_FLEX = 0,
    YGD_NONE = 1,
    UNRECOGNIZED = -1
}
export declare function yGDisplayFromJSON(object: any): YGDisplay;
export declare function yGDisplayToJSON(object: YGDisplay): string;
export declare enum YGEdge {
    YGE_LEFT = 0,
    YGE_TOP = 1,
    YGE_RIGHT = 2,
    YGE_BOTTOM = 3,
    YGE_START = 4,
    YGE_END = 5,
    YGE_HORIZONTAL = 6,
    YGE_VERTICAL = 7,
    YGE_ALL = 8,
    UNRECOGNIZED = -1
}
export declare function yGEdgeFromJSON(object: any): YGEdge;
export declare function yGEdgeToJSON(object: YGEdge): string;
export declare enum PointerFilterMode {
    PFM_NONE = 0,
    PFM_BLOCK = 1,
    UNRECOGNIZED = -1
}
export declare function pointerFilterModeFromJSON(object: any): PointerFilterMode;
export declare function pointerFilterModeToJSON(object: PointerFilterMode): string;
export interface PBUiTransform {
    parent: number;
    rightOf: number;
    /** default: YGAlign.YGA_FLEX_START */
    alignContent?: YGAlign | undefined;
    /** default: YGAlign.YGA_STRETCH */
    alignItems?: YGAlign | undefined;
    /** default: YGWrap.YGW_WRAP */
    flexWrap?: YGWrap | undefined;
    /** default: 1 */
    flexShrink?: number | undefined;
    /** YGPositionType.YGPT_RELATIVE */
    positionType: YGPositionType;
    /** YGAlign.YGA_AUTO */
    alignSelf: YGAlign;
    /** YGFlexDirection.YGFD_ROW */
    flexDirection: YGFlexDirection;
    /** YGJustify.YGJ_FLEX_START */
    justifyContent: YGJustify;
    /** YGOverflow.YGO_VISIBLE */
    overflow: YGOverflow;
    /** YGDisplay.YGD_FLEX */
    display: YGDisplay;
    /** YGUnit.YGU_UNDEFINED */
    flexBasisUnit: YGUnit;
    flexBasis: number;
    flexGrow: number;
    /** YGUnit.YGU_UNDEFINED */
    widthUnit: YGUnit;
    width: number;
    /** YGUnit.YGU_UNDEFINED */
    heightUnit: YGUnit;
    height: number;
    /** YGUnit.YGU_UNDEFINED */
    minWidthUnit: YGUnit;
    minWidth: number;
    /** YGUnit.YGU_UNDEFINED */
    minHeightUnit: YGUnit;
    minHeight: number;
    /** YGUnit.YGU_UNDEFINED */
    maxWidthUnit: YGUnit;
    maxWidth: number;
    /** YGUnit.YGU_UNDEFINED */
    maxHeightUnit: YGUnit;
    maxHeight: number;
    /** YGUnit.YGU_UNDEFINED */
    positionLeftUnit: YGUnit;
    positionLeft: number;
    /** YGUnit.YGU_UNDEFINED */
    positionTopUnit: YGUnit;
    positionTop: number;
    /** YGUnit.YGU_UNDEFINED */
    positionRightUnit: YGUnit;
    positionRight: number;
    /** YGUnit.YGU_UNDEFINED */
    positionBottomUnit: YGUnit;
    positionBottom: number;
    /** YGUnit.YGU_UNDEFINED */
    marginLeftUnit: YGUnit;
    marginLeft: number;
    /** YGUnit.YGU_UNDEFINED */
    marginTopUnit: YGUnit;
    marginTop: number;
    /** YGUnit.YGU_UNDEFINED */
    marginRightUnit: YGUnit;
    marginRight: number;
    /** YGUnit.YGU_UNDEFINED */
    marginBottomUnit: YGUnit;
    marginBottom: number;
    /** YGUnit.YGU_UNDEFINED */
    paddingLeftUnit: YGUnit;
    paddingLeft: number;
    /** YGUnit.YGU_UNDEFINED */
    paddingTopUnit: YGUnit;
    paddingTop: number;
    /** YGUnit.YGU_UNDEFINED */
    paddingRightUnit: YGUnit;
    paddingRight: number;
    /** YGUnit.YGU_UNDEFINED */
    paddingBottomUnit: YGUnit;
    paddingBottom: number;
    /** default: PointerFilterMode.PFM_NONE */
    pointerFilter?: PointerFilterMode | undefined;
}
export declare namespace PBUiTransform {
    function encode(message: PBUiTransform, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBUiTransform;
    function fromJSON(object: any): PBUiTransform;
    function toJSON(message: PBUiTransform): unknown;
    function create<I extends Exact<DeepPartial<PBUiTransform>, I>>(base?: I): PBUiTransform;
    function fromPartial<I extends Exact<DeepPartial<PBUiTransform>, I>>(object: I): PBUiTransform;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]>;
} & {
    $case: T["$case"];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
