"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PBMeshCollider_SphereMesh = exports.PBMeshCollider_PlaneMesh = exports.PBMeshCollider_CylinderMesh = exports.PBMeshCollider_BoxMesh = exports.PBMeshCollider = exports.ColliderLayer = exports.protobufPackage = void 0;
exports.colliderLayerFromJSON = colliderLayerFromJSON;
exports.colliderLayerToJSON = colliderLayerToJSON;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "decentraland.sdk.components";
/** ColliderLayer determines the kind of collision to detect, in OR-able bit flag form. */
var ColliderLayer;
(function (ColliderLayer) {
    /** CL_NONE - no collisions */
    ColliderLayer[ColliderLayer["CL_NONE"] = 0] = "CL_NONE";
    /** CL_POINTER - collisions with the player's pointer ray (e.g. mouse cursor hovering) */
    ColliderLayer[ColliderLayer["CL_POINTER"] = 1] = "CL_POINTER";
    /** CL_PHYSICS - collision affecting your player's physics i.e. walls, floor, moving platfroms */
    ColliderLayer[ColliderLayer["CL_PHYSICS"] = 2] = "CL_PHYSICS";
    ColliderLayer[ColliderLayer["CL_RESERVED1"] = 4] = "CL_RESERVED1";
    ColliderLayer[ColliderLayer["CL_RESERVED2"] = 8] = "CL_RESERVED2";
    ColliderLayer[ColliderLayer["CL_RESERVED3"] = 16] = "CL_RESERVED3";
    ColliderLayer[ColliderLayer["CL_RESERVED4"] = 32] = "CL_RESERVED4";
    ColliderLayer[ColliderLayer["CL_RESERVED5"] = 64] = "CL_RESERVED5";
    ColliderLayer[ColliderLayer["CL_RESERVED6"] = 128] = "CL_RESERVED6";
    ColliderLayer[ColliderLayer["CL_CUSTOM1"] = 256] = "CL_CUSTOM1";
    ColliderLayer[ColliderLayer["CL_CUSTOM2"] = 512] = "CL_CUSTOM2";
    ColliderLayer[ColliderLayer["CL_CUSTOM3"] = 1024] = "CL_CUSTOM3";
    ColliderLayer[ColliderLayer["CL_CUSTOM4"] = 2048] = "CL_CUSTOM4";
    ColliderLayer[ColliderLayer["CL_CUSTOM5"] = 4096] = "CL_CUSTOM5";
    ColliderLayer[ColliderLayer["CL_CUSTOM6"] = 8192] = "CL_CUSTOM6";
    ColliderLayer[ColliderLayer["CL_CUSTOM7"] = 16384] = "CL_CUSTOM7";
    ColliderLayer[ColliderLayer["CL_CUSTOM8"] = 32768] = "CL_CUSTOM8";
    ColliderLayer[ColliderLayer["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ColliderLayer || (exports.ColliderLayer = ColliderLayer = {}));
function colliderLayerFromJSON(object) {
    switch (object) {
        case 0:
        case "CL_NONE":
            return ColliderLayer.CL_NONE;
        case 1:
        case "CL_POINTER":
            return ColliderLayer.CL_POINTER;
        case 2:
        case "CL_PHYSICS":
            return ColliderLayer.CL_PHYSICS;
        case 4:
        case "CL_RESERVED1":
            return ColliderLayer.CL_RESERVED1;
        case 8:
        case "CL_RESERVED2":
            return ColliderLayer.CL_RESERVED2;
        case 16:
        case "CL_RESERVED3":
            return ColliderLayer.CL_RESERVED3;
        case 32:
        case "CL_RESERVED4":
            return ColliderLayer.CL_RESERVED4;
        case 64:
        case "CL_RESERVED5":
            return ColliderLayer.CL_RESERVED5;
        case 128:
        case "CL_RESERVED6":
            return ColliderLayer.CL_RESERVED6;
        case 256:
        case "CL_CUSTOM1":
            return ColliderLayer.CL_CUSTOM1;
        case 512:
        case "CL_CUSTOM2":
            return ColliderLayer.CL_CUSTOM2;
        case 1024:
        case "CL_CUSTOM3":
            return ColliderLayer.CL_CUSTOM3;
        case 2048:
        case "CL_CUSTOM4":
            return ColliderLayer.CL_CUSTOM4;
        case 4096:
        case "CL_CUSTOM5":
            return ColliderLayer.CL_CUSTOM5;
        case 8192:
        case "CL_CUSTOM6":
            return ColliderLayer.CL_CUSTOM6;
        case 16384:
        case "CL_CUSTOM7":
            return ColliderLayer.CL_CUSTOM7;
        case 32768:
        case "CL_CUSTOM8":
            return ColliderLayer.CL_CUSTOM8;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ColliderLayer.UNRECOGNIZED;
    }
}
function colliderLayerToJSON(object) {
    switch (object) {
        case ColliderLayer.CL_NONE:
            return "CL_NONE";
        case ColliderLayer.CL_POINTER:
            return "CL_POINTER";
        case ColliderLayer.CL_PHYSICS:
            return "CL_PHYSICS";
        case ColliderLayer.CL_RESERVED1:
            return "CL_RESERVED1";
        case ColliderLayer.CL_RESERVED2:
            return "CL_RESERVED2";
        case ColliderLayer.CL_RESERVED3:
            return "CL_RESERVED3";
        case ColliderLayer.CL_RESERVED4:
            return "CL_RESERVED4";
        case ColliderLayer.CL_RESERVED5:
            return "CL_RESERVED5";
        case ColliderLayer.CL_RESERVED6:
            return "CL_RESERVED6";
        case ColliderLayer.CL_CUSTOM1:
            return "CL_CUSTOM1";
        case ColliderLayer.CL_CUSTOM2:
            return "CL_CUSTOM2";
        case ColliderLayer.CL_CUSTOM3:
            return "CL_CUSTOM3";
        case ColliderLayer.CL_CUSTOM4:
            return "CL_CUSTOM4";
        case ColliderLayer.CL_CUSTOM5:
            return "CL_CUSTOM5";
        case ColliderLayer.CL_CUSTOM6:
            return "CL_CUSTOM6";
        case ColliderLayer.CL_CUSTOM7:
            return "CL_CUSTOM7";
        case ColliderLayer.CL_CUSTOM8:
            return "CL_CUSTOM8";
        case ColliderLayer.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBasePBMeshCollider() {
    return { collisionMask: undefined, mesh: undefined };
}
var PBMeshCollider;
(function (PBMeshCollider) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        var _a;
        if (message.collisionMask !== undefined) {
            writer.uint32(8).uint32(message.collisionMask);
        }
        switch ((_a = message.mesh) === null || _a === void 0 ? void 0 : _a.$case) {
            case "box":
                PBMeshCollider_BoxMesh.encode(message.mesh.box, writer.uint32(18).fork()).ldelim();
                break;
            case "sphere":
                PBMeshCollider_SphereMesh.encode(message.mesh.sphere, writer.uint32(26).fork()).ldelim();
                break;
            case "cylinder":
                PBMeshCollider_CylinderMesh.encode(message.mesh.cylinder, writer.uint32(34).fork()).ldelim();
                break;
            case "plane":
                PBMeshCollider_PlaneMesh.encode(message.mesh.plane, writer.uint32(42).fork()).ldelim();
                break;
        }
        return writer;
    }
    PBMeshCollider.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePBMeshCollider();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.collisionMask = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.mesh = { $case: "box", box: PBMeshCollider_BoxMesh.decode(reader, reader.uint32()) };
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.mesh = { $case: "sphere", sphere: PBMeshCollider_SphereMesh.decode(reader, reader.uint32()) };
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.mesh = { $case: "cylinder", cylinder: PBMeshCollider_CylinderMesh.decode(reader, reader.uint32()) };
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.mesh = { $case: "plane", plane: PBMeshCollider_PlaneMesh.decode(reader, reader.uint32()) };
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PBMeshCollider.decode = decode;
    function fromJSON(object) {
        return {
            collisionMask: isSet(object.collisionMask) ? Number(object.collisionMask) : undefined,
            mesh: isSet(object.box)
                ? { $case: "box", box: PBMeshCollider_BoxMesh.fromJSON(object.box) }
                : isSet(object.sphere)
                    ? { $case: "sphere", sphere: PBMeshCollider_SphereMesh.fromJSON(object.sphere) }
                    : isSet(object.cylinder)
                        ? { $case: "cylinder", cylinder: PBMeshCollider_CylinderMesh.fromJSON(object.cylinder) }
                        : isSet(object.plane)
                            ? { $case: "plane", plane: PBMeshCollider_PlaneMesh.fromJSON(object.plane) }
                            : undefined,
        };
    }
    PBMeshCollider.fromJSON = fromJSON;
    function toJSON(message) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const obj = {};
        message.collisionMask !== undefined && (obj.collisionMask = Math.round(message.collisionMask));
        ((_a = message.mesh) === null || _a === void 0 ? void 0 : _a.$case) === "box" &&
            (obj.box = ((_b = message.mesh) === null || _b === void 0 ? void 0 : _b.box) ? PBMeshCollider_BoxMesh.toJSON((_c = message.mesh) === null || _c === void 0 ? void 0 : _c.box) : undefined);
        ((_d = message.mesh) === null || _d === void 0 ? void 0 : _d.$case) === "sphere" &&
            (obj.sphere = ((_e = message.mesh) === null || _e === void 0 ? void 0 : _e.sphere) ? PBMeshCollider_SphereMesh.toJSON((_f = message.mesh) === null || _f === void 0 ? void 0 : _f.sphere) : undefined);
        ((_g = message.mesh) === null || _g === void 0 ? void 0 : _g.$case) === "cylinder" &&
            (obj.cylinder = ((_h = message.mesh) === null || _h === void 0 ? void 0 : _h.cylinder) ? PBMeshCollider_CylinderMesh.toJSON((_j = message.mesh) === null || _j === void 0 ? void 0 : _j.cylinder) : undefined);
        ((_k = message.mesh) === null || _k === void 0 ? void 0 : _k.$case) === "plane" &&
            (obj.plane = ((_l = message.mesh) === null || _l === void 0 ? void 0 : _l.plane) ? PBMeshCollider_PlaneMesh.toJSON((_m = message.mesh) === null || _m === void 0 ? void 0 : _m.plane) : undefined);
        return obj;
    }
    PBMeshCollider.toJSON = toJSON;
    function create(base) {
        return PBMeshCollider.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    PBMeshCollider.create = create;
    function fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const message = createBasePBMeshCollider();
        message.collisionMask = (_a = object.collisionMask) !== null && _a !== void 0 ? _a : undefined;
        if (((_b = object.mesh) === null || _b === void 0 ? void 0 : _b.$case) === "box" && ((_c = object.mesh) === null || _c === void 0 ? void 0 : _c.box) !== undefined && ((_d = object.mesh) === null || _d === void 0 ? void 0 : _d.box) !== null) {
            message.mesh = { $case: "box", box: PBMeshCollider_BoxMesh.fromPartial(object.mesh.box) };
        }
        if (((_e = object.mesh) === null || _e === void 0 ? void 0 : _e.$case) === "sphere" && ((_f = object.mesh) === null || _f === void 0 ? void 0 : _f.sphere) !== undefined && ((_g = object.mesh) === null || _g === void 0 ? void 0 : _g.sphere) !== null) {
            message.mesh = { $case: "sphere", sphere: PBMeshCollider_SphereMesh.fromPartial(object.mesh.sphere) };
        }
        if (((_h = object.mesh) === null || _h === void 0 ? void 0 : _h.$case) === "cylinder" && ((_j = object.mesh) === null || _j === void 0 ? void 0 : _j.cylinder) !== undefined && ((_k = object.mesh) === null || _k === void 0 ? void 0 : _k.cylinder) !== null) {
            message.mesh = { $case: "cylinder", cylinder: PBMeshCollider_CylinderMesh.fromPartial(object.mesh.cylinder) };
        }
        if (((_l = object.mesh) === null || _l === void 0 ? void 0 : _l.$case) === "plane" && ((_m = object.mesh) === null || _m === void 0 ? void 0 : _m.plane) !== undefined && ((_o = object.mesh) === null || _o === void 0 ? void 0 : _o.plane) !== null) {
            message.mesh = { $case: "plane", plane: PBMeshCollider_PlaneMesh.fromPartial(object.mesh.plane) };
        }
        return message;
    }
    PBMeshCollider.fromPartial = fromPartial;
})(PBMeshCollider || (exports.PBMeshCollider = PBMeshCollider = {}));
function createBasePBMeshCollider_BoxMesh() {
    return {};
}
var PBMeshCollider_BoxMesh;
(function (PBMeshCollider_BoxMesh) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    PBMeshCollider_BoxMesh.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePBMeshCollider_BoxMesh();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PBMeshCollider_BoxMesh.decode = decode;
    function fromJSON(_) {
        return {};
    }
    PBMeshCollider_BoxMesh.fromJSON = fromJSON;
    function toJSON(_) {
        const obj = {};
        return obj;
    }
    PBMeshCollider_BoxMesh.toJSON = toJSON;
    function create(base) {
        return PBMeshCollider_BoxMesh.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    PBMeshCollider_BoxMesh.create = create;
    function fromPartial(_) {
        const message = createBasePBMeshCollider_BoxMesh();
        return message;
    }
    PBMeshCollider_BoxMesh.fromPartial = fromPartial;
})(PBMeshCollider_BoxMesh || (exports.PBMeshCollider_BoxMesh = PBMeshCollider_BoxMesh = {}));
function createBasePBMeshCollider_CylinderMesh() {
    return { radiusTop: undefined, radiusBottom: undefined };
}
var PBMeshCollider_CylinderMesh;
(function (PBMeshCollider_CylinderMesh) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.radiusTop !== undefined) {
            writer.uint32(13).float(message.radiusTop);
        }
        if (message.radiusBottom !== undefined) {
            writer.uint32(21).float(message.radiusBottom);
        }
        return writer;
    }
    PBMeshCollider_CylinderMesh.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePBMeshCollider_CylinderMesh();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 13) {
                        break;
                    }
                    message.radiusTop = reader.float();
                    continue;
                case 2:
                    if (tag !== 21) {
                        break;
                    }
                    message.radiusBottom = reader.float();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PBMeshCollider_CylinderMesh.decode = decode;
    function fromJSON(object) {
        return {
            radiusTop: isSet(object.radiusTop) ? Number(object.radiusTop) : undefined,
            radiusBottom: isSet(object.radiusBottom) ? Number(object.radiusBottom) : undefined,
        };
    }
    PBMeshCollider_CylinderMesh.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.radiusTop !== undefined && (obj.radiusTop = message.radiusTop);
        message.radiusBottom !== undefined && (obj.radiusBottom = message.radiusBottom);
        return obj;
    }
    PBMeshCollider_CylinderMesh.toJSON = toJSON;
    function create(base) {
        return PBMeshCollider_CylinderMesh.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    PBMeshCollider_CylinderMesh.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBasePBMeshCollider_CylinderMesh();
        message.radiusTop = (_a = object.radiusTop) !== null && _a !== void 0 ? _a : undefined;
        message.radiusBottom = (_b = object.radiusBottom) !== null && _b !== void 0 ? _b : undefined;
        return message;
    }
    PBMeshCollider_CylinderMesh.fromPartial = fromPartial;
})(PBMeshCollider_CylinderMesh || (exports.PBMeshCollider_CylinderMesh = PBMeshCollider_CylinderMesh = {}));
function createBasePBMeshCollider_PlaneMesh() {
    return {};
}
var PBMeshCollider_PlaneMesh;
(function (PBMeshCollider_PlaneMesh) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    PBMeshCollider_PlaneMesh.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePBMeshCollider_PlaneMesh();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PBMeshCollider_PlaneMesh.decode = decode;
    function fromJSON(_) {
        return {};
    }
    PBMeshCollider_PlaneMesh.fromJSON = fromJSON;
    function toJSON(_) {
        const obj = {};
        return obj;
    }
    PBMeshCollider_PlaneMesh.toJSON = toJSON;
    function create(base) {
        return PBMeshCollider_PlaneMesh.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    PBMeshCollider_PlaneMesh.create = create;
    function fromPartial(_) {
        const message = createBasePBMeshCollider_PlaneMesh();
        return message;
    }
    PBMeshCollider_PlaneMesh.fromPartial = fromPartial;
})(PBMeshCollider_PlaneMesh || (exports.PBMeshCollider_PlaneMesh = PBMeshCollider_PlaneMesh = {}));
function createBasePBMeshCollider_SphereMesh() {
    return {};
}
var PBMeshCollider_SphereMesh;
(function (PBMeshCollider_SphereMesh) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    PBMeshCollider_SphereMesh.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePBMeshCollider_SphereMesh();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PBMeshCollider_SphereMesh.decode = decode;
    function fromJSON(_) {
        return {};
    }
    PBMeshCollider_SphereMesh.fromJSON = fromJSON;
    function toJSON(_) {
        const obj = {};
        return obj;
    }
    PBMeshCollider_SphereMesh.toJSON = toJSON;
    function create(base) {
        return PBMeshCollider_SphereMesh.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    PBMeshCollider_SphereMesh.create = create;
    function fromPartial(_) {
        const message = createBasePBMeshCollider_SphereMesh();
        return message;
    }
    PBMeshCollider_SphereMesh.fromPartial = fromPartial;
})(PBMeshCollider_SphereMesh || (exports.PBMeshCollider_SphereMesh = PBMeshCollider_SphereMesh = {}));
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=mesh_collider.gen.js.map