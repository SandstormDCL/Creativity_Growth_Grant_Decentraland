import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "decentraland.sdk.components";
/** ColliderLayer determines the kind of collision to detect, in OR-able bit flag form. */
export declare enum ColliderLayer {
    /** CL_NONE - no collisions */
    CL_NONE = 0,
    /** CL_POINTER - collisions with the player's pointer ray (e.g. mouse cursor hovering) */
    CL_POINTER = 1,
    /** CL_PHYSICS - collision affecting your player's physics i.e. walls, floor, moving platfroms */
    CL_PHYSICS = 2,
    CL_RESERVED1 = 4,
    CL_RESERVED2 = 8,
    CL_RESERVED3 = 16,
    CL_RESERVED4 = 32,
    CL_RESERVED5 = 64,
    CL_RESERVED6 = 128,
    CL_CUSTOM1 = 256,
    CL_CUSTOM2 = 512,
    CL_CUSTOM3 = 1024,
    CL_CUSTOM4 = 2048,
    CL_CUSTOM5 = 4096,
    CL_CUSTOM6 = 8192,
    CL_CUSTOM7 = 16384,
    CL_CUSTOM8 = 32768,
    UNRECOGNIZED = -1
}
export declare function colliderLayerFromJSON(object: any): ColliderLayer;
export declare function colliderLayerToJSON(object: ColliderLayer): string;
/**
 * The MeshCollider component provides basic collision detection between Entities and Avatars. It
 * can behave like a cube, a plane, a sphere or a cylinder.
 *
 * The Entity's Transform affects the MeshCollider, scaling it and rotating it appropriately. If
 * the Transform for the collision mesh must be different than the Transform for rendering the Entity,
 * two different Entities must be used.
 *
 * More complex shapes require the use of a `GltfContainer` component.
 */
export interface PBMeshCollider {
    /** enabled ColliderLayers (default CL_POINTER | CL_PHYSICS) */
    collisionMask?: number | undefined;
    mesh?: {
        $case: "box";
        box: PBMeshCollider_BoxMesh;
    } | {
        $case: "sphere";
        sphere: PBMeshCollider_SphereMesh;
    } | {
        $case: "cylinder";
        cylinder: PBMeshCollider_CylinderMesh;
    } | {
        $case: "plane";
        plane: PBMeshCollider_PlaneMesh;
    } | undefined;
}
/** BoxMesh is a prism shape that contains the Entity. */
export interface PBMeshCollider_BoxMesh {
}
/** CylinderMesh is a truncated cone shape that contains the Entity. */
export interface PBMeshCollider_CylinderMesh {
    /** (default 0.5) */
    radiusTop?: number | undefined;
    /** (default 0.5) */
    radiusBottom?: number | undefined;
}
/** PlaneMesh is a 2D rectangle described by the Entity's Transform. */
export interface PBMeshCollider_PlaneMesh {
}
/** SphereMesh is a sphere shape that contains the Entity. */
export interface PBMeshCollider_SphereMesh {
}
export declare namespace PBMeshCollider {
    function encode(message: PBMeshCollider, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider;
    function fromJSON(object: any): PBMeshCollider;
    function toJSON(message: PBMeshCollider): unknown;
    function create<I extends Exact<DeepPartial<PBMeshCollider>, I>>(base?: I): PBMeshCollider;
    function fromPartial<I extends Exact<DeepPartial<PBMeshCollider>, I>>(object: I): PBMeshCollider;
}
export declare namespace PBMeshCollider_BoxMesh {
    function encode(_: PBMeshCollider_BoxMesh, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_BoxMesh;
    function fromJSON(_: any): PBMeshCollider_BoxMesh;
    function toJSON(_: PBMeshCollider_BoxMesh): unknown;
    function create<I extends Exact<DeepPartial<PBMeshCollider_BoxMesh>, I>>(base?: I): PBMeshCollider_BoxMesh;
    function fromPartial<I extends Exact<DeepPartial<PBMeshCollider_BoxMesh>, I>>(_: I): PBMeshCollider_BoxMesh;
}
export declare namespace PBMeshCollider_CylinderMesh {
    function encode(message: PBMeshCollider_CylinderMesh, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_CylinderMesh;
    function fromJSON(object: any): PBMeshCollider_CylinderMesh;
    function toJSON(message: PBMeshCollider_CylinderMesh): unknown;
    function create<I extends Exact<DeepPartial<PBMeshCollider_CylinderMesh>, I>>(base?: I): PBMeshCollider_CylinderMesh;
    function fromPartial<I extends Exact<DeepPartial<PBMeshCollider_CylinderMesh>, I>>(object: I): PBMeshCollider_CylinderMesh;
}
export declare namespace PBMeshCollider_PlaneMesh {
    function encode(_: PBMeshCollider_PlaneMesh, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_PlaneMesh;
    function fromJSON(_: any): PBMeshCollider_PlaneMesh;
    function toJSON(_: PBMeshCollider_PlaneMesh): unknown;
    function create<I extends Exact<DeepPartial<PBMeshCollider_PlaneMesh>, I>>(base?: I): PBMeshCollider_PlaneMesh;
    function fromPartial<I extends Exact<DeepPartial<PBMeshCollider_PlaneMesh>, I>>(_: I): PBMeshCollider_PlaneMesh;
}
export declare namespace PBMeshCollider_SphereMesh {
    function encode(_: PBMeshCollider_SphereMesh, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_SphereMesh;
    function fromJSON(_: any): PBMeshCollider_SphereMesh;
    function toJSON(_: PBMeshCollider_SphereMesh): unknown;
    function create<I extends Exact<DeepPartial<PBMeshCollider_SphereMesh>, I>>(base?: I): PBMeshCollider_SphereMesh;
    function fromPartial<I extends Exact<DeepPartial<PBMeshCollider_SphereMesh>, I>>(_: I): PBMeshCollider_SphereMesh;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]>;
} & {
    $case: T["$case"];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
