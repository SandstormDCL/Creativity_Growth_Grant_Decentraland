import _m0 from "protobufjs/minimal";
import { Vector2 } from "./vectors.gen";
export declare const protobufPackage = "decentraland.common";
export declare enum TextureWrapMode {
    TWM_REPEAT = 0,
    TWM_CLAMP = 1,
    TWM_MIRROR = 2,
    UNRECOGNIZED = -1
}
export declare function textureWrapModeFromJSON(object: any): TextureWrapMode;
export declare function textureWrapModeToJSON(object: TextureWrapMode): string;
export declare enum TextureFilterMode {
    TFM_POINT = 0,
    TFM_BILINEAR = 1,
    TFM_TRILINEAR = 2,
    UNRECOGNIZED = -1
}
export declare function textureFilterModeFromJSON(object: any): TextureFilterMode;
export declare function textureFilterModeToJSON(object: TextureFilterMode): string;
export interface Texture {
    src: string;
    /** default = TextureWrapMode.Clamp */
    wrapMode?: TextureWrapMode | undefined;
    /** default = FilterMode.Bilinear */
    filterMode?: TextureFilterMode | undefined;
    /**
     * Final uv = offset + (input_uv * tiling)
     * Offset for texture positioning.
     */
    offset?: Vector2 | undefined;
    /** Tiling multiplier for texture repetition. */
    tiling?: Vector2 | undefined;
}
export interface AvatarTexture {
    userId: string;
    /** default = TextureWrapMode.Clamp */
    wrapMode?: TextureWrapMode | undefined;
    /** default = FilterMode.Bilinear */
    filterMode?: TextureFilterMode | undefined;
}
export interface VideoTexture {
    videoPlayerEntity: number;
    /** default = TextureWrapMode.Clamp */
    wrapMode?: TextureWrapMode | undefined;
    /** default = FilterMode.Bilinear */
    filterMode?: TextureFilterMode | undefined;
}
export interface TextureUnion {
    tex?: {
        $case: "texture";
        texture: Texture;
    } | {
        $case: "avatarTexture";
        avatarTexture: AvatarTexture;
    } | {
        $case: "videoTexture";
        videoTexture: VideoTexture;
    } | undefined;
}
export declare namespace Texture {
    function encode(message: Texture, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): Texture;
    function fromJSON(object: any): Texture;
    function toJSON(message: Texture): unknown;
    function create<I extends Exact<DeepPartial<Texture>, I>>(base?: I): Texture;
    function fromPartial<I extends Exact<DeepPartial<Texture>, I>>(object: I): Texture;
}
export declare namespace AvatarTexture {
    function encode(message: AvatarTexture, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): AvatarTexture;
    function fromJSON(object: any): AvatarTexture;
    function toJSON(message: AvatarTexture): unknown;
    function create<I extends Exact<DeepPartial<AvatarTexture>, I>>(base?: I): AvatarTexture;
    function fromPartial<I extends Exact<DeepPartial<AvatarTexture>, I>>(object: I): AvatarTexture;
}
export declare namespace VideoTexture {
    function encode(message: VideoTexture, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): VideoTexture;
    function fromJSON(object: any): VideoTexture;
    function toJSON(message: VideoTexture): unknown;
    function create<I extends Exact<DeepPartial<VideoTexture>, I>>(base?: I): VideoTexture;
    function fromPartial<I extends Exact<DeepPartial<VideoTexture>, I>>(object: I): VideoTexture;
}
export declare namespace TextureUnion {
    function encode(message: TextureUnion, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): TextureUnion;
    function fromJSON(object: any): TextureUnion;
    function toJSON(message: TextureUnion): unknown;
    function create<I extends Exact<DeepPartial<TextureUnion>, I>>(base?: I): TextureUnion;
    function fromPartial<I extends Exact<DeepPartial<TextureUnion>, I>>(object: I): TextureUnion;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]>;
} & {
    $case: T["$case"];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
