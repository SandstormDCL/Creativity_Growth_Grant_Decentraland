"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PortableExperiencesServiceDefinition = exports.ExitResponse = exports.ExitRequest = exports.GetPortableExperiencesLoadedResponse = exports.GetPortableExperiencesLoadedRequest = exports.PxRequest = exports.SpawnResponse = exports.SpawnRequest = exports.KillResponse = exports.KillRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "decentraland.kernel.apis";
function createBaseKillRequest() {
    return { pid: "" };
}
var KillRequest;
(function (KillRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pid !== "") {
            writer.uint32(10).string(message.pid);
        }
        return writer;
    }
    KillRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKillRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    KillRequest.decode = decode;
    function fromJSON(object) {
        return { pid: isSet(object.pid) ? String(object.pid) : "" };
    }
    KillRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.pid !== undefined && (obj.pid = message.pid);
        return obj;
    }
    KillRequest.toJSON = toJSON;
    function create(base) {
        return KillRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    KillRequest.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseKillRequest();
        message.pid = (_a = object.pid) !== null && _a !== void 0 ? _a : "";
        return message;
    }
    KillRequest.fromPartial = fromPartial;
})(KillRequest || (exports.KillRequest = KillRequest = {}));
function createBaseKillResponse() {
    return { status: false };
}
var KillResponse;
(function (KillResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.status === true) {
            writer.uint32(8).bool(message.status);
        }
        return writer;
    }
    KillResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKillResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.status = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    KillResponse.decode = decode;
    function fromJSON(object) {
        return { status: isSet(object.status) ? Boolean(object.status) : false };
    }
    KillResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.status !== undefined && (obj.status = message.status);
        return obj;
    }
    KillResponse.toJSON = toJSON;
    function create(base) {
        return KillResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    KillResponse.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseKillResponse();
        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : false;
        return message;
    }
    KillResponse.fromPartial = fromPartial;
})(KillResponse || (exports.KillResponse = KillResponse = {}));
function createBaseSpawnRequest() {
    return { pid: undefined, ens: undefined };
}
var SpawnRequest;
(function (SpawnRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pid !== undefined) {
            writer.uint32(10).string(message.pid);
        }
        if (message.ens !== undefined) {
            writer.uint32(18).string(message.ens);
        }
        return writer;
    }
    SpawnRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpawnRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pid = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.ens = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    SpawnRequest.decode = decode;
    function fromJSON(object) {
        return {
            pid: isSet(object.pid) ? String(object.pid) : undefined,
            ens: isSet(object.ens) ? String(object.ens) : undefined,
        };
    }
    SpawnRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.pid !== undefined && (obj.pid = message.pid);
        message.ens !== undefined && (obj.ens = message.ens);
        return obj;
    }
    SpawnRequest.toJSON = toJSON;
    function create(base) {
        return SpawnRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    SpawnRequest.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBaseSpawnRequest();
        message.pid = (_a = object.pid) !== null && _a !== void 0 ? _a : undefined;
        message.ens = (_b = object.ens) !== null && _b !== void 0 ? _b : undefined;
        return message;
    }
    SpawnRequest.fromPartial = fromPartial;
})(SpawnRequest || (exports.SpawnRequest = SpawnRequest = {}));
function createBaseSpawnResponse() {
    return { pid: "", parentCid: "", name: "", ens: undefined };
}
var SpawnResponse;
(function (SpawnResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pid !== "") {
            writer.uint32(10).string(message.pid);
        }
        if (message.parentCid !== "") {
            writer.uint32(18).string(message.parentCid);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.ens !== undefined) {
            writer.uint32(34).string(message.ens);
        }
        return writer;
    }
    SpawnResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpawnResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pid = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.parentCid = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.ens = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    SpawnResponse.decode = decode;
    function fromJSON(object) {
        return {
            pid: isSet(object.pid) ? String(object.pid) : "",
            parentCid: isSet(object.parentCid) ? String(object.parentCid) : "",
            name: isSet(object.name) ? String(object.name) : "",
            ens: isSet(object.ens) ? String(object.ens) : undefined,
        };
    }
    SpawnResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.pid !== undefined && (obj.pid = message.pid);
        message.parentCid !== undefined && (obj.parentCid = message.parentCid);
        message.name !== undefined && (obj.name = message.name);
        message.ens !== undefined && (obj.ens = message.ens);
        return obj;
    }
    SpawnResponse.toJSON = toJSON;
    function create(base) {
        return SpawnResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    SpawnResponse.create = create;
    function fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseSpawnResponse();
        message.pid = (_a = object.pid) !== null && _a !== void 0 ? _a : "";
        message.parentCid = (_b = object.parentCid) !== null && _b !== void 0 ? _b : "";
        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : "";
        message.ens = (_d = object.ens) !== null && _d !== void 0 ? _d : undefined;
        return message;
    }
    SpawnResponse.fromPartial = fromPartial;
})(SpawnResponse || (exports.SpawnResponse = SpawnResponse = {}));
function createBasePxRequest() {
    return { pid: "" };
}
var PxRequest;
(function (PxRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pid !== "") {
            writer.uint32(10).string(message.pid);
        }
        return writer;
    }
    PxRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePxRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    PxRequest.decode = decode;
    function fromJSON(object) {
        return { pid: isSet(object.pid) ? String(object.pid) : "" };
    }
    PxRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.pid !== undefined && (obj.pid = message.pid);
        return obj;
    }
    PxRequest.toJSON = toJSON;
    function create(base) {
        return PxRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    PxRequest.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBasePxRequest();
        message.pid = (_a = object.pid) !== null && _a !== void 0 ? _a : "";
        return message;
    }
    PxRequest.fromPartial = fromPartial;
})(PxRequest || (exports.PxRequest = PxRequest = {}));
function createBaseGetPortableExperiencesLoadedRequest() {
    return {};
}
var GetPortableExperiencesLoadedRequest;
(function (GetPortableExperiencesLoadedRequest) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    GetPortableExperiencesLoadedRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPortableExperiencesLoadedRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    GetPortableExperiencesLoadedRequest.decode = decode;
    function fromJSON(_) {
        return {};
    }
    GetPortableExperiencesLoadedRequest.fromJSON = fromJSON;
    function toJSON(_) {
        const obj = {};
        return obj;
    }
    GetPortableExperiencesLoadedRequest.toJSON = toJSON;
    function create(base) {
        return GetPortableExperiencesLoadedRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    GetPortableExperiencesLoadedRequest.create = create;
    function fromPartial(_) {
        const message = createBaseGetPortableExperiencesLoadedRequest();
        return message;
    }
    GetPortableExperiencesLoadedRequest.fromPartial = fromPartial;
})(GetPortableExperiencesLoadedRequest || (exports.GetPortableExperiencesLoadedRequest = GetPortableExperiencesLoadedRequest = {}));
function createBaseGetPortableExperiencesLoadedResponse() {
    return { loaded: [] };
}
var GetPortableExperiencesLoadedResponse;
(function (GetPortableExperiencesLoadedResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.loaded) {
            SpawnResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    }
    GetPortableExperiencesLoadedResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPortableExperiencesLoadedResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.loaded.push(SpawnResponse.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    GetPortableExperiencesLoadedResponse.decode = decode;
    function fromJSON(object) {
        return { loaded: Array.isArray(object === null || object === void 0 ? void 0 : object.loaded) ? object.loaded.map((e) => SpawnResponse.fromJSON(e)) : [] };
    }
    GetPortableExperiencesLoadedResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        if (message.loaded) {
            obj.loaded = message.loaded.map((e) => e ? SpawnResponse.toJSON(e) : undefined);
        }
        else {
            obj.loaded = [];
        }
        return obj;
    }
    GetPortableExperiencesLoadedResponse.toJSON = toJSON;
    function create(base) {
        return GetPortableExperiencesLoadedResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    GetPortableExperiencesLoadedResponse.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseGetPortableExperiencesLoadedResponse();
        message.loaded = ((_a = object.loaded) === null || _a === void 0 ? void 0 : _a.map((e) => SpawnResponse.fromPartial(e))) || [];
        return message;
    }
    GetPortableExperiencesLoadedResponse.fromPartial = fromPartial;
})(GetPortableExperiencesLoadedResponse || (exports.GetPortableExperiencesLoadedResponse = GetPortableExperiencesLoadedResponse = {}));
function createBaseExitRequest() {
    return {};
}
var ExitRequest;
(function (ExitRequest) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    ExitRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExitRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    ExitRequest.decode = decode;
    function fromJSON(_) {
        return {};
    }
    ExitRequest.fromJSON = fromJSON;
    function toJSON(_) {
        const obj = {};
        return obj;
    }
    ExitRequest.toJSON = toJSON;
    function create(base) {
        return ExitRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    ExitRequest.create = create;
    function fromPartial(_) {
        const message = createBaseExitRequest();
        return message;
    }
    ExitRequest.fromPartial = fromPartial;
})(ExitRequest || (exports.ExitRequest = ExitRequest = {}));
function createBaseExitResponse() {
    return { status: false };
}
var ExitResponse;
(function (ExitResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.status === true) {
            writer.uint32(8).bool(message.status);
        }
        return writer;
    }
    ExitResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExitResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.status = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    ExitResponse.decode = decode;
    function fromJSON(object) {
        return { status: isSet(object.status) ? Boolean(object.status) : false };
    }
    ExitResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.status !== undefined && (obj.status = message.status);
        return obj;
    }
    ExitResponse.toJSON = toJSON;
    function create(base) {
        return ExitResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    ExitResponse.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseExitResponse();
        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : false;
        return message;
    }
    ExitResponse.fromPartial = fromPartial;
})(ExitResponse || (exports.ExitResponse = ExitResponse = {}));
exports.PortableExperiencesServiceDefinition = {
    name: "PortableExperiencesService",
    fullName: "decentraland.kernel.apis.PortableExperiencesService",
    methods: {
        /**
         * Spawns a new portable experience that is detached from the current scene.
         * Spawned portable experiences can only be controlled by 1) the user (from the UI)
         * and 2) from the parent scene. If the parent scene gets unloaded i.e. by distance,
         * once the player re-loads the parent it will inherit the children portable experiences
         * to gain control over them.
         */
        spawn: {
            name: "Spawn",
            requestType: SpawnRequest,
            requestStream: false,
            responseType: SpawnResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Kill a child portable experience, this method only works if the child was
         * spawned by the same process trying to kill it.
         */
        kill: {
            name: "Kill",
            requestType: KillRequest,
            requestStream: false,
            responseType: KillResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Kill the current scene if the current scene is a portable experience. Other
         * kind of scenes are not allowed to finish their programs like portable experiences.
         */
        exit: {
            name: "Exit",
            requestType: ExitRequest,
            requestStream: false,
            responseType: ExitResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Gets a list of running portable experiences for the current user. Be mindful
         * about the performance penalty of calling this function all frames.
         */
        getPortableExperiencesLoaded: {
            name: "GetPortableExperiencesLoaded",
            requestType: GetPortableExperiencesLoadedRequest,
            requestStream: false,
            responseType: GetPortableExperiencesLoadedResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=portable_experiences.gen.js.map