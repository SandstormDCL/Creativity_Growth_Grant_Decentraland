import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "decentraland.kernel.apis";
export interface KillRequest {
    pid: string;
}
export interface KillResponse {
    status: boolean;
}
export interface SpawnRequest {
    pid?: string | undefined;
    ens?: string | undefined;
}
export interface SpawnResponse {
    pid: string;
    parentCid: string;
    name: string;
    ens?: string | undefined;
}
export interface PxRequest {
    pid: string;
}
export interface GetPortableExperiencesLoadedRequest {
}
export interface GetPortableExperiencesLoadedResponse {
    loaded: SpawnResponse[];
}
export interface ExitRequest {
}
export interface ExitResponse {
    status: boolean;
}
export declare namespace KillRequest {
    function encode(message: KillRequest, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): KillRequest;
    function fromJSON(object: any): KillRequest;
    function toJSON(message: KillRequest): unknown;
    function create<I extends Exact<DeepPartial<KillRequest>, I>>(base?: I): KillRequest;
    function fromPartial<I extends Exact<DeepPartial<KillRequest>, I>>(object: I): KillRequest;
}
export declare namespace KillResponse {
    function encode(message: KillResponse, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): KillResponse;
    function fromJSON(object: any): KillResponse;
    function toJSON(message: KillResponse): unknown;
    function create<I extends Exact<DeepPartial<KillResponse>, I>>(base?: I): KillResponse;
    function fromPartial<I extends Exact<DeepPartial<KillResponse>, I>>(object: I): KillResponse;
}
export declare namespace SpawnRequest {
    function encode(message: SpawnRequest, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): SpawnRequest;
    function fromJSON(object: any): SpawnRequest;
    function toJSON(message: SpawnRequest): unknown;
    function create<I extends Exact<DeepPartial<SpawnRequest>, I>>(base?: I): SpawnRequest;
    function fromPartial<I extends Exact<DeepPartial<SpawnRequest>, I>>(object: I): SpawnRequest;
}
export declare namespace SpawnResponse {
    function encode(message: SpawnResponse, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): SpawnResponse;
    function fromJSON(object: any): SpawnResponse;
    function toJSON(message: SpawnResponse): unknown;
    function create<I extends Exact<DeepPartial<SpawnResponse>, I>>(base?: I): SpawnResponse;
    function fromPartial<I extends Exact<DeepPartial<SpawnResponse>, I>>(object: I): SpawnResponse;
}
export declare namespace PxRequest {
    function encode(message: PxRequest, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): PxRequest;
    function fromJSON(object: any): PxRequest;
    function toJSON(message: PxRequest): unknown;
    function create<I extends Exact<DeepPartial<PxRequest>, I>>(base?: I): PxRequest;
    function fromPartial<I extends Exact<DeepPartial<PxRequest>, I>>(object: I): PxRequest;
}
export declare namespace GetPortableExperiencesLoadedRequest {
    function encode(_: GetPortableExperiencesLoadedRequest, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): GetPortableExperiencesLoadedRequest;
    function fromJSON(_: any): GetPortableExperiencesLoadedRequest;
    function toJSON(_: GetPortableExperiencesLoadedRequest): unknown;
    function create<I extends Exact<DeepPartial<GetPortableExperiencesLoadedRequest>, I>>(base?: I): GetPortableExperiencesLoadedRequest;
    function fromPartial<I extends Exact<DeepPartial<GetPortableExperiencesLoadedRequest>, I>>(_: I): GetPortableExperiencesLoadedRequest;
}
export declare namespace GetPortableExperiencesLoadedResponse {
    function encode(message: GetPortableExperiencesLoadedResponse, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): GetPortableExperiencesLoadedResponse;
    function fromJSON(object: any): GetPortableExperiencesLoadedResponse;
    function toJSON(message: GetPortableExperiencesLoadedResponse): unknown;
    function create<I extends Exact<DeepPartial<GetPortableExperiencesLoadedResponse>, I>>(base?: I): GetPortableExperiencesLoadedResponse;
    function fromPartial<I extends Exact<DeepPartial<GetPortableExperiencesLoadedResponse>, I>>(object: I): GetPortableExperiencesLoadedResponse;
}
export declare namespace ExitRequest {
    function encode(_: ExitRequest, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): ExitRequest;
    function fromJSON(_: any): ExitRequest;
    function toJSON(_: ExitRequest): unknown;
    function create<I extends Exact<DeepPartial<ExitRequest>, I>>(base?: I): ExitRequest;
    function fromPartial<I extends Exact<DeepPartial<ExitRequest>, I>>(_: I): ExitRequest;
}
export declare namespace ExitResponse {
    function encode(message: ExitResponse, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): ExitResponse;
    function fromJSON(object: any): ExitResponse;
    function toJSON(message: ExitResponse): unknown;
    function create<I extends Exact<DeepPartial<ExitResponse>, I>>(base?: I): ExitResponse;
    function fromPartial<I extends Exact<DeepPartial<ExitResponse>, I>>(object: I): ExitResponse;
}
export type PortableExperiencesServiceDefinition = typeof PortableExperiencesServiceDefinition;
export declare const PortableExperiencesServiceDefinition: {
    readonly name: "PortableExperiencesService";
    readonly fullName: "decentraland.kernel.apis.PortableExperiencesService";
    readonly methods: {
        /**
         * Spawns a new portable experience that is detached from the current scene.
         * Spawned portable experiences can only be controlled by 1) the user (from the UI)
         * and 2) from the parent scene. If the parent scene gets unloaded i.e. by distance,
         * once the player re-loads the parent it will inherit the children portable experiences
         * to gain control over them.
         */
        readonly spawn: {
            readonly name: "Spawn";
            readonly requestType: typeof SpawnRequest;
            readonly requestStream: false;
            readonly responseType: typeof SpawnResponse;
            readonly responseStream: false;
            readonly options: {};
        };
        /**
         * Kill a child portable experience, this method only works if the child was
         * spawned by the same process trying to kill it.
         */
        readonly kill: {
            readonly name: "Kill";
            readonly requestType: typeof KillRequest;
            readonly requestStream: false;
            readonly responseType: typeof KillResponse;
            readonly responseStream: false;
            readonly options: {};
        };
        /**
         * Kill the current scene if the current scene is a portable experience. Other
         * kind of scenes are not allowed to finish their programs like portable experiences.
         */
        readonly exit: {
            readonly name: "Exit";
            readonly requestType: typeof ExitRequest;
            readonly requestStream: false;
            readonly responseType: typeof ExitResponse;
            readonly responseStream: false;
            readonly options: {};
        };
        /**
         * Gets a list of running portable experiences for the current user. Be mindful
         * about the performance penalty of calling this function all frames.
         */
        readonly getPortableExperiencesLoaded: {
            readonly name: "GetPortableExperiencesLoaded";
            readonly requestType: typeof GetPortableExperiencesLoadedRequest;
            readonly requestStream: false;
            readonly responseType: typeof GetPortableExperiencesLoadedResponse;
            readonly responseStream: false;
            readonly options: {};
        };
    };
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]>;
} & {
    $case: T["$case"];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
