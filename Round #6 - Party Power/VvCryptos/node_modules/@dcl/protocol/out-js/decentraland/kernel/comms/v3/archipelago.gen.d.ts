import _m0 from "protobufjs/minimal";
import { Position } from "../../../common/vectors.gen";
export declare const protobufPackage = "decentraland.kernel.comms.v3";
export declare enum KickedReason {
    KR_NEW_SESSION = 0,
    UNRECOGNIZED = -1
}
export declare function kickedReasonFromJSON(object: any): KickedReason;
export declare function kickedReasonToJSON(object: KickedReason): string;
/** Server->Client messsages */
export interface ChallengeResponseMessage {
    challengeToSign: string;
    alreadyConnected: boolean;
}
export interface WelcomeMessage {
    peerId: string;
}
export interface IslandChangedMessage {
    islandId: string;
    connStr: string;
    fromIslandId?: string | undefined;
    peers: {
        [key: string]: Position;
    };
}
export interface IslandChangedMessage_PeersEntry {
    key: string;
    value: Position | undefined;
}
export interface LeftIslandMessage {
    islandId: string;
    peerId: string;
}
export interface JoinIslandMessage {
    islandId: string;
    peerId: string;
}
export interface KickedMessage {
    reason: KickedReason;
}
export interface ServerPacket {
    message?: {
        $case: "challengeResponse";
        challengeResponse: ChallengeResponseMessage;
    } | {
        $case: "welcome";
        welcome: WelcomeMessage;
    } | {
        $case: "islandChanged";
        islandChanged: IslandChangedMessage;
    } | {
        $case: "leftIsland";
        leftIsland: LeftIslandMessage;
    } | {
        $case: "joinIsland";
        joinIsland: JoinIslandMessage;
    } | {
        $case: "kicked";
        kicked: KickedMessage;
    } | undefined;
}
/** Client->Server messsages */
export interface ChallengeRequestMessage {
    address: string;
}
export interface SignedChallengeMessage {
    authChainJson: string;
}
export interface Heartbeat {
    position: Position | undefined;
    desiredRoom?: string | undefined;
}
export interface ClientPacket {
    message?: {
        $case: "challengeRequest";
        challengeRequest: ChallengeRequestMessage;
    } | {
        $case: "signedChallenge";
        signedChallenge: SignedChallengeMessage;
    } | {
        $case: "heartbeat";
        heartbeat: Heartbeat;
    } | undefined;
}
/** Others */
export interface IslandData {
    id: string;
    peers: string[];
    maxPeers: number;
    center: Position | undefined;
    radius: number;
}
export interface IslandStatusMessage {
    data: IslandData[];
}
export declare namespace ChallengeResponseMessage {
    function encode(message: ChallengeResponseMessage, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): ChallengeResponseMessage;
    function fromJSON(object: any): ChallengeResponseMessage;
    function toJSON(message: ChallengeResponseMessage): unknown;
    function create<I extends Exact<DeepPartial<ChallengeResponseMessage>, I>>(base?: I): ChallengeResponseMessage;
    function fromPartial<I extends Exact<DeepPartial<ChallengeResponseMessage>, I>>(object: I): ChallengeResponseMessage;
}
export declare namespace WelcomeMessage {
    function encode(message: WelcomeMessage, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): WelcomeMessage;
    function fromJSON(object: any): WelcomeMessage;
    function toJSON(message: WelcomeMessage): unknown;
    function create<I extends Exact<DeepPartial<WelcomeMessage>, I>>(base?: I): WelcomeMessage;
    function fromPartial<I extends Exact<DeepPartial<WelcomeMessage>, I>>(object: I): WelcomeMessage;
}
export declare namespace IslandChangedMessage {
    function encode(message: IslandChangedMessage, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): IslandChangedMessage;
    function fromJSON(object: any): IslandChangedMessage;
    function toJSON(message: IslandChangedMessage): unknown;
    function create<I extends Exact<DeepPartial<IslandChangedMessage>, I>>(base?: I): IslandChangedMessage;
    function fromPartial<I extends Exact<DeepPartial<IslandChangedMessage>, I>>(object: I): IslandChangedMessage;
}
export declare namespace IslandChangedMessage_PeersEntry {
    function encode(message: IslandChangedMessage_PeersEntry, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): IslandChangedMessage_PeersEntry;
    function fromJSON(object: any): IslandChangedMessage_PeersEntry;
    function toJSON(message: IslandChangedMessage_PeersEntry): unknown;
    function create<I extends Exact<DeepPartial<IslandChangedMessage_PeersEntry>, I>>(base?: I): IslandChangedMessage_PeersEntry;
    function fromPartial<I extends Exact<DeepPartial<IslandChangedMessage_PeersEntry>, I>>(object: I): IslandChangedMessage_PeersEntry;
}
export declare namespace LeftIslandMessage {
    function encode(message: LeftIslandMessage, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): LeftIslandMessage;
    function fromJSON(object: any): LeftIslandMessage;
    function toJSON(message: LeftIslandMessage): unknown;
    function create<I extends Exact<DeepPartial<LeftIslandMessage>, I>>(base?: I): LeftIslandMessage;
    function fromPartial<I extends Exact<DeepPartial<LeftIslandMessage>, I>>(object: I): LeftIslandMessage;
}
export declare namespace JoinIslandMessage {
    function encode(message: JoinIslandMessage, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): JoinIslandMessage;
    function fromJSON(object: any): JoinIslandMessage;
    function toJSON(message: JoinIslandMessage): unknown;
    function create<I extends Exact<DeepPartial<JoinIslandMessage>, I>>(base?: I): JoinIslandMessage;
    function fromPartial<I extends Exact<DeepPartial<JoinIslandMessage>, I>>(object: I): JoinIslandMessage;
}
export declare namespace KickedMessage {
    function encode(message: KickedMessage, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): KickedMessage;
    function fromJSON(object: any): KickedMessage;
    function toJSON(message: KickedMessage): unknown;
    function create<I extends Exact<DeepPartial<KickedMessage>, I>>(base?: I): KickedMessage;
    function fromPartial<I extends Exact<DeepPartial<KickedMessage>, I>>(object: I): KickedMessage;
}
export declare namespace ServerPacket {
    function encode(message: ServerPacket, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): ServerPacket;
    function fromJSON(object: any): ServerPacket;
    function toJSON(message: ServerPacket): unknown;
    function create<I extends Exact<DeepPartial<ServerPacket>, I>>(base?: I): ServerPacket;
    function fromPartial<I extends Exact<DeepPartial<ServerPacket>, I>>(object: I): ServerPacket;
}
export declare namespace ChallengeRequestMessage {
    function encode(message: ChallengeRequestMessage, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): ChallengeRequestMessage;
    function fromJSON(object: any): ChallengeRequestMessage;
    function toJSON(message: ChallengeRequestMessage): unknown;
    function create<I extends Exact<DeepPartial<ChallengeRequestMessage>, I>>(base?: I): ChallengeRequestMessage;
    function fromPartial<I extends Exact<DeepPartial<ChallengeRequestMessage>, I>>(object: I): ChallengeRequestMessage;
}
export declare namespace SignedChallengeMessage {
    function encode(message: SignedChallengeMessage, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): SignedChallengeMessage;
    function fromJSON(object: any): SignedChallengeMessage;
    function toJSON(message: SignedChallengeMessage): unknown;
    function create<I extends Exact<DeepPartial<SignedChallengeMessage>, I>>(base?: I): SignedChallengeMessage;
    function fromPartial<I extends Exact<DeepPartial<SignedChallengeMessage>, I>>(object: I): SignedChallengeMessage;
}
export declare namespace Heartbeat {
    function encode(message: Heartbeat, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): Heartbeat;
    function fromJSON(object: any): Heartbeat;
    function toJSON(message: Heartbeat): unknown;
    function create<I extends Exact<DeepPartial<Heartbeat>, I>>(base?: I): Heartbeat;
    function fromPartial<I extends Exact<DeepPartial<Heartbeat>, I>>(object: I): Heartbeat;
}
export declare namespace ClientPacket {
    function encode(message: ClientPacket, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): ClientPacket;
    function fromJSON(object: any): ClientPacket;
    function toJSON(message: ClientPacket): unknown;
    function create<I extends Exact<DeepPartial<ClientPacket>, I>>(base?: I): ClientPacket;
    function fromPartial<I extends Exact<DeepPartial<ClientPacket>, I>>(object: I): ClientPacket;
}
export declare namespace IslandData {
    function encode(message: IslandData, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): IslandData;
    function fromJSON(object: any): IslandData;
    function toJSON(message: IslandData): unknown;
    function create<I extends Exact<DeepPartial<IslandData>, I>>(base?: I): IslandData;
    function fromPartial<I extends Exact<DeepPartial<IslandData>, I>>(object: I): IslandData;
}
export declare namespace IslandStatusMessage {
    function encode(message: IslandStatusMessage, writer?: _m0.Writer): _m0.Writer;
    function decode(input: _m0.Reader | Uint8Array, length?: number): IslandStatusMessage;
    function fromJSON(object: any): IslandStatusMessage;
    function toJSON(message: IslandStatusMessage): unknown;
    function create<I extends Exact<DeepPartial<IslandStatusMessage>, I>>(base?: I): IslandStatusMessage;
    function fromPartial<I extends Exact<DeepPartial<IslandStatusMessage>, I>>(object: I): IslandStatusMessage;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]>;
} & {
    $case: T["$case"];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
