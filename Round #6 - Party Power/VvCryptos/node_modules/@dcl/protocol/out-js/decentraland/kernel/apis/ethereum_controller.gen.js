"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumControllerServiceDefinition = exports.GetUserAccountResponse = exports.GetUserAccountRequest = exports.SendAsyncResponse = exports.SendAsyncRequest = exports.ConvertMessageToObjectResponse_DictEntry = exports.ConvertMessageToObjectResponse = exports.ConvertMessageToObjectRequest = exports.SignMessageResponse = exports.SignMessageRequest_MessageEntry = exports.SignMessageRequest = exports.RequirePaymentResponse = exports.RequirePaymentRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "decentraland.kernel.apis";
function createBaseRequirePaymentRequest() {
    return { toAddress: "", amount: 0, currency: "" };
}
var RequirePaymentRequest;
(function (RequirePaymentRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.toAddress !== "") {
            writer.uint32(10).string(message.toAddress);
        }
        if (message.amount !== 0) {
            writer.uint32(21).float(message.amount);
        }
        if (message.currency !== "") {
            writer.uint32(26).string(message.currency);
        }
        return writer;
    }
    RequirePaymentRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequirePaymentRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.toAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 21) {
                        break;
                    }
                    message.amount = reader.float();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.currency = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    RequirePaymentRequest.decode = decode;
    function fromJSON(object) {
        return {
            toAddress: isSet(object.toAddress) ? String(object.toAddress) : "",
            amount: isSet(object.amount) ? Number(object.amount) : 0,
            currency: isSet(object.currency) ? String(object.currency) : "",
        };
    }
    RequirePaymentRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.toAddress !== undefined && (obj.toAddress = message.toAddress);
        message.amount !== undefined && (obj.amount = message.amount);
        message.currency !== undefined && (obj.currency = message.currency);
        return obj;
    }
    RequirePaymentRequest.toJSON = toJSON;
    function create(base) {
        return RequirePaymentRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    RequirePaymentRequest.create = create;
    function fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseRequirePaymentRequest();
        message.toAddress = (_a = object.toAddress) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : 0;
        message.currency = (_c = object.currency) !== null && _c !== void 0 ? _c : "";
        return message;
    }
    RequirePaymentRequest.fromPartial = fromPartial;
})(RequirePaymentRequest || (exports.RequirePaymentRequest = RequirePaymentRequest = {}));
function createBaseRequirePaymentResponse() {
    return { jsonAnyResponse: "" };
}
var RequirePaymentResponse;
(function (RequirePaymentResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.jsonAnyResponse !== "") {
            writer.uint32(10).string(message.jsonAnyResponse);
        }
        return writer;
    }
    RequirePaymentResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequirePaymentResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.jsonAnyResponse = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    RequirePaymentResponse.decode = decode;
    function fromJSON(object) {
        return { jsonAnyResponse: isSet(object.jsonAnyResponse) ? String(object.jsonAnyResponse) : "" };
    }
    RequirePaymentResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.jsonAnyResponse !== undefined && (obj.jsonAnyResponse = message.jsonAnyResponse);
        return obj;
    }
    RequirePaymentResponse.toJSON = toJSON;
    function create(base) {
        return RequirePaymentResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    RequirePaymentResponse.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseRequirePaymentResponse();
        message.jsonAnyResponse = (_a = object.jsonAnyResponse) !== null && _a !== void 0 ? _a : "";
        return message;
    }
    RequirePaymentResponse.fromPartial = fromPartial;
})(RequirePaymentResponse || (exports.RequirePaymentResponse = RequirePaymentResponse = {}));
function createBaseSignMessageRequest() {
    return { message: {} };
}
var SignMessageRequest;
(function (SignMessageRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.message).forEach(([key, value]) => {
            SignMessageRequest_MessageEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    }
    SignMessageRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignMessageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = SignMessageRequest_MessageEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.message[entry1.key] = entry1.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    SignMessageRequest.decode = decode;
    function fromJSON(object) {
        return {
            message: isObject(object.message)
                ? Object.entries(object.message).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    }
    SignMessageRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        obj.message = {};
        if (message.message) {
            Object.entries(message.message).forEach(([k, v]) => {
                obj.message[k] = v;
            });
        }
        return obj;
    }
    SignMessageRequest.toJSON = toJSON;
    function create(base) {
        return SignMessageRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    SignMessageRequest.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseSignMessageRequest();
        message.message = Object.entries((_a = object.message) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        return message;
    }
    SignMessageRequest.fromPartial = fromPartial;
})(SignMessageRequest || (exports.SignMessageRequest = SignMessageRequest = {}));
function createBaseSignMessageRequest_MessageEntry() {
    return { key: "", value: "" };
}
var SignMessageRequest_MessageEntry;
(function (SignMessageRequest_MessageEntry) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    }
    SignMessageRequest_MessageEntry.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignMessageRequest_MessageEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    SignMessageRequest_MessageEntry.decode = decode;
    function fromJSON(object) {
        return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
    }
    SignMessageRequest_MessageEntry.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    }
    SignMessageRequest_MessageEntry.toJSON = toJSON;
    function create(base) {
        return SignMessageRequest_MessageEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    SignMessageRequest_MessageEntry.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBaseSignMessageRequest_MessageEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    }
    SignMessageRequest_MessageEntry.fromPartial = fromPartial;
})(SignMessageRequest_MessageEntry || (exports.SignMessageRequest_MessageEntry = SignMessageRequest_MessageEntry = {}));
function createBaseSignMessageResponse() {
    return { message: "", hexEncodedMessage: "", signature: "" };
}
var SignMessageResponse;
(function (SignMessageResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        if (message.hexEncodedMessage !== "") {
            writer.uint32(18).string(message.hexEncodedMessage);
        }
        if (message.signature !== "") {
            writer.uint32(26).string(message.signature);
        }
        return writer;
    }
    SignMessageResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignMessageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.hexEncodedMessage = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.signature = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    SignMessageResponse.decode = decode;
    function fromJSON(object) {
        return {
            message: isSet(object.message) ? String(object.message) : "",
            hexEncodedMessage: isSet(object.hexEncodedMessage) ? String(object.hexEncodedMessage) : "",
            signature: isSet(object.signature) ? String(object.signature) : "",
        };
    }
    SignMessageResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.message !== undefined && (obj.message = message.message);
        message.hexEncodedMessage !== undefined && (obj.hexEncodedMessage = message.hexEncodedMessage);
        message.signature !== undefined && (obj.signature = message.signature);
        return obj;
    }
    SignMessageResponse.toJSON = toJSON;
    function create(base) {
        return SignMessageResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    SignMessageResponse.create = create;
    function fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSignMessageResponse();
        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : "";
        message.hexEncodedMessage = (_b = object.hexEncodedMessage) !== null && _b !== void 0 ? _b : "";
        message.signature = (_c = object.signature) !== null && _c !== void 0 ? _c : "";
        return message;
    }
    SignMessageResponse.fromPartial = fromPartial;
})(SignMessageResponse || (exports.SignMessageResponse = SignMessageResponse = {}));
function createBaseConvertMessageToObjectRequest() {
    return { message: "" };
}
var ConvertMessageToObjectRequest;
(function (ConvertMessageToObjectRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        return writer;
    }
    ConvertMessageToObjectRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConvertMessageToObjectRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    ConvertMessageToObjectRequest.decode = decode;
    function fromJSON(object) {
        return { message: isSet(object.message) ? String(object.message) : "" };
    }
    ConvertMessageToObjectRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.message !== undefined && (obj.message = message.message);
        return obj;
    }
    ConvertMessageToObjectRequest.toJSON = toJSON;
    function create(base) {
        return ConvertMessageToObjectRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    ConvertMessageToObjectRequest.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseConvertMessageToObjectRequest();
        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : "";
        return message;
    }
    ConvertMessageToObjectRequest.fromPartial = fromPartial;
})(ConvertMessageToObjectRequest || (exports.ConvertMessageToObjectRequest = ConvertMessageToObjectRequest = {}));
function createBaseConvertMessageToObjectResponse() {
    return { dict: {} };
}
var ConvertMessageToObjectResponse;
(function (ConvertMessageToObjectResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.dict).forEach(([key, value]) => {
            ConvertMessageToObjectResponse_DictEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    }
    ConvertMessageToObjectResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConvertMessageToObjectResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = ConvertMessageToObjectResponse_DictEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.dict[entry1.key] = entry1.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    ConvertMessageToObjectResponse.decode = decode;
    function fromJSON(object) {
        return {
            dict: isObject(object.dict)
                ? Object.entries(object.dict).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    }
    ConvertMessageToObjectResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        obj.dict = {};
        if (message.dict) {
            Object.entries(message.dict).forEach(([k, v]) => {
                obj.dict[k] = v;
            });
        }
        return obj;
    }
    ConvertMessageToObjectResponse.toJSON = toJSON;
    function create(base) {
        return ConvertMessageToObjectResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    ConvertMessageToObjectResponse.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseConvertMessageToObjectResponse();
        message.dict = Object.entries((_a = object.dict) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        return message;
    }
    ConvertMessageToObjectResponse.fromPartial = fromPartial;
})(ConvertMessageToObjectResponse || (exports.ConvertMessageToObjectResponse = ConvertMessageToObjectResponse = {}));
function createBaseConvertMessageToObjectResponse_DictEntry() {
    return { key: "", value: "" };
}
var ConvertMessageToObjectResponse_DictEntry;
(function (ConvertMessageToObjectResponse_DictEntry) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    }
    ConvertMessageToObjectResponse_DictEntry.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConvertMessageToObjectResponse_DictEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    ConvertMessageToObjectResponse_DictEntry.decode = decode;
    function fromJSON(object) {
        return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
    }
    ConvertMessageToObjectResponse_DictEntry.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    }
    ConvertMessageToObjectResponse_DictEntry.toJSON = toJSON;
    function create(base) {
        return ConvertMessageToObjectResponse_DictEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    ConvertMessageToObjectResponse_DictEntry.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBaseConvertMessageToObjectResponse_DictEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    }
    ConvertMessageToObjectResponse_DictEntry.fromPartial = fromPartial;
})(ConvertMessageToObjectResponse_DictEntry || (exports.ConvertMessageToObjectResponse_DictEntry = ConvertMessageToObjectResponse_DictEntry = {}));
function createBaseSendAsyncRequest() {
    return { id: 0, method: "", jsonParams: "" };
}
var SendAsyncRequest;
(function (SendAsyncRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== 0) {
            writer.uint32(8).int32(message.id);
        }
        if (message.method !== "") {
            writer.uint32(18).string(message.method);
        }
        if (message.jsonParams !== "") {
            writer.uint32(26).string(message.jsonParams);
        }
        return writer;
    }
    SendAsyncRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendAsyncRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.method = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.jsonParams = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    SendAsyncRequest.decode = decode;
    function fromJSON(object) {
        return {
            id: isSet(object.id) ? Number(object.id) : 0,
            method: isSet(object.method) ? String(object.method) : "",
            jsonParams: isSet(object.jsonParams) ? String(object.jsonParams) : "",
        };
    }
    SendAsyncRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = Math.round(message.id));
        message.method !== undefined && (obj.method = message.method);
        message.jsonParams !== undefined && (obj.jsonParams = message.jsonParams);
        return obj;
    }
    SendAsyncRequest.toJSON = toJSON;
    function create(base) {
        return SendAsyncRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    SendAsyncRequest.create = create;
    function fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSendAsyncRequest();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : 0;
        message.method = (_b = object.method) !== null && _b !== void 0 ? _b : "";
        message.jsonParams = (_c = object.jsonParams) !== null && _c !== void 0 ? _c : "";
        return message;
    }
    SendAsyncRequest.fromPartial = fromPartial;
})(SendAsyncRequest || (exports.SendAsyncRequest = SendAsyncRequest = {}));
function createBaseSendAsyncResponse() {
    return { jsonAnyResponse: "" };
}
var SendAsyncResponse;
(function (SendAsyncResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.jsonAnyResponse !== "") {
            writer.uint32(10).string(message.jsonAnyResponse);
        }
        return writer;
    }
    SendAsyncResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendAsyncResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.jsonAnyResponse = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    SendAsyncResponse.decode = decode;
    function fromJSON(object) {
        return { jsonAnyResponse: isSet(object.jsonAnyResponse) ? String(object.jsonAnyResponse) : "" };
    }
    SendAsyncResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.jsonAnyResponse !== undefined && (obj.jsonAnyResponse = message.jsonAnyResponse);
        return obj;
    }
    SendAsyncResponse.toJSON = toJSON;
    function create(base) {
        return SendAsyncResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    SendAsyncResponse.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseSendAsyncResponse();
        message.jsonAnyResponse = (_a = object.jsonAnyResponse) !== null && _a !== void 0 ? _a : "";
        return message;
    }
    SendAsyncResponse.fromPartial = fromPartial;
})(SendAsyncResponse || (exports.SendAsyncResponse = SendAsyncResponse = {}));
function createBaseGetUserAccountRequest() {
    return {};
}
var GetUserAccountRequest;
(function (GetUserAccountRequest) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    GetUserAccountRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetUserAccountRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    GetUserAccountRequest.decode = decode;
    function fromJSON(_) {
        return {};
    }
    GetUserAccountRequest.fromJSON = fromJSON;
    function toJSON(_) {
        const obj = {};
        return obj;
    }
    GetUserAccountRequest.toJSON = toJSON;
    function create(base) {
        return GetUserAccountRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    GetUserAccountRequest.create = create;
    function fromPartial(_) {
        const message = createBaseGetUserAccountRequest();
        return message;
    }
    GetUserAccountRequest.fromPartial = fromPartial;
})(GetUserAccountRequest || (exports.GetUserAccountRequest = GetUserAccountRequest = {}));
function createBaseGetUserAccountResponse() {
    return { address: undefined };
}
var GetUserAccountResponse;
(function (GetUserAccountResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== undefined) {
            writer.uint32(10).string(message.address);
        }
        return writer;
    }
    GetUserAccountResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetUserAccountResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    GetUserAccountResponse.decode = decode;
    function fromJSON(object) {
        return { address: isSet(object.address) ? String(object.address) : undefined };
    }
    GetUserAccountResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        return obj;
    }
    GetUserAccountResponse.toJSON = toJSON;
    function create(base) {
        return GetUserAccountResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    GetUserAccountResponse.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseGetUserAccountResponse();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : undefined;
        return message;
    }
    GetUserAccountResponse.fromPartial = fromPartial;
})(GetUserAccountResponse || (exports.GetUserAccountResponse = GetUserAccountResponse = {}));
exports.EthereumControllerServiceDefinition = {
    name: "EthereumControllerService",
    fullName: "decentraland.kernel.apis.EthereumControllerService",
    methods: {
        /**
         * @deprecated, only available for SDK6 compatibility. This was a low level API that can
         * be replaced by any ethereum library on top of the provider
         */
        requirePayment: {
            name: "RequirePayment",
            requestType: RequirePaymentRequest,
            requestStream: false,
            responseType: RequirePaymentResponse,
            responseStream: false,
            options: {},
        },
        /**
         * @deprecated, only available for SDK6 compatibility. This was a low level API that can
         * be replaced by any ethereum library on top of the provider
         */
        signMessage: {
            name: "SignMessage",
            requestType: SignMessageRequest,
            requestStream: false,
            responseType: SignMessageResponse,
            responseStream: false,
            options: {},
        },
        /**
         * @deprecated, only available for SDK6 compatibility. This was a low level API that can
         * be replaced by any ethereum library on top of the provider
         */
        convertMessageToObject: {
            name: "ConvertMessageToObject",
            requestType: ConvertMessageToObjectRequest,
            requestStream: false,
            responseType: ConvertMessageToObjectResponse,
            responseStream: false,
            options: {},
        },
        sendAsync: {
            name: "SendAsync",
            requestType: SendAsyncRequest,
            requestStream: false,
            responseType: SendAsyncResponse,
            responseStream: false,
            options: {},
        },
        /**
         * @deprecated, only available for SDK6 compatibility. This was a low level API that can
         * be replaced by any ethereum library on top of the provider
         */
        getUserAccount: {
            name: "GetUserAccount",
            requestType: GetUserAccountRequest,
            requestStream: false,
            responseType: GetUserAccountResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=ethereum_controller.gen.js.map