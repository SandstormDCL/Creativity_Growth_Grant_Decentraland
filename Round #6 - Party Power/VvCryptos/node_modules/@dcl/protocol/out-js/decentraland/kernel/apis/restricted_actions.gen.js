"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestrictedActionsServiceDefinition = exports.TeleportToResponse = exports.MovePlayerToResponse = exports.TriggerEmoteResponse = exports.SuccessResponse = exports.TriggerSceneEmoteRequest = exports.CommsAdapterRequest = exports.UnblockPointerRequest = exports.OpenNftDialogRequest = exports.OpenExternalUrlRequest = exports.ChangeRealmRequest = exports.TriggerEmoteRequest = exports.TeleportToRequest = exports.MovePlayerToRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const vectors_gen_1 = require("../../common/vectors.gen");
exports.protobufPackage = "decentraland.kernel.apis";
function createBaseMovePlayerToRequest() {
    return { newRelativePosition: undefined, cameraTarget: undefined };
}
var MovePlayerToRequest;
(function (MovePlayerToRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.newRelativePosition !== undefined) {
            vectors_gen_1.Vector3.encode(message.newRelativePosition, writer.uint32(10).fork()).ldelim();
        }
        if (message.cameraTarget !== undefined) {
            vectors_gen_1.Vector3.encode(message.cameraTarget, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    }
    MovePlayerToRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMovePlayerToRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.newRelativePosition = vectors_gen_1.Vector3.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.cameraTarget = vectors_gen_1.Vector3.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    MovePlayerToRequest.decode = decode;
    function fromJSON(object) {
        return {
            newRelativePosition: isSet(object.newRelativePosition) ? vectors_gen_1.Vector3.fromJSON(object.newRelativePosition) : undefined,
            cameraTarget: isSet(object.cameraTarget) ? vectors_gen_1.Vector3.fromJSON(object.cameraTarget) : undefined,
        };
    }
    MovePlayerToRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.newRelativePosition !== undefined &&
            (obj.newRelativePosition = message.newRelativePosition ? vectors_gen_1.Vector3.toJSON(message.newRelativePosition) : undefined);
        message.cameraTarget !== undefined &&
            (obj.cameraTarget = message.cameraTarget ? vectors_gen_1.Vector3.toJSON(message.cameraTarget) : undefined);
        return obj;
    }
    MovePlayerToRequest.toJSON = toJSON;
    function create(base) {
        return MovePlayerToRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    MovePlayerToRequest.create = create;
    function fromPartial(object) {
        const message = createBaseMovePlayerToRequest();
        message.newRelativePosition = (object.newRelativePosition !== undefined && object.newRelativePosition !== null)
            ? vectors_gen_1.Vector3.fromPartial(object.newRelativePosition)
            : undefined;
        message.cameraTarget = (object.cameraTarget !== undefined && object.cameraTarget !== null)
            ? vectors_gen_1.Vector3.fromPartial(object.cameraTarget)
            : undefined;
        return message;
    }
    MovePlayerToRequest.fromPartial = fromPartial;
})(MovePlayerToRequest || (exports.MovePlayerToRequest = MovePlayerToRequest = {}));
function createBaseTeleportToRequest() {
    return { worldCoordinates: undefined };
}
var TeleportToRequest;
(function (TeleportToRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.worldCoordinates !== undefined) {
            vectors_gen_1.Vector2.encode(message.worldCoordinates, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    }
    TeleportToRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTeleportToRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.worldCoordinates = vectors_gen_1.Vector2.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    TeleportToRequest.decode = decode;
    function fromJSON(object) {
        return { worldCoordinates: isSet(object.worldCoordinates) ? vectors_gen_1.Vector2.fromJSON(object.worldCoordinates) : undefined };
    }
    TeleportToRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.worldCoordinates !== undefined &&
            (obj.worldCoordinates = message.worldCoordinates ? vectors_gen_1.Vector2.toJSON(message.worldCoordinates) : undefined);
        return obj;
    }
    TeleportToRequest.toJSON = toJSON;
    function create(base) {
        return TeleportToRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    TeleportToRequest.create = create;
    function fromPartial(object) {
        const message = createBaseTeleportToRequest();
        message.worldCoordinates = (object.worldCoordinates !== undefined && object.worldCoordinates !== null)
            ? vectors_gen_1.Vector2.fromPartial(object.worldCoordinates)
            : undefined;
        return message;
    }
    TeleportToRequest.fromPartial = fromPartial;
})(TeleportToRequest || (exports.TeleportToRequest = TeleportToRequest = {}));
function createBaseTriggerEmoteRequest() {
    return { predefinedEmote: "" };
}
var TriggerEmoteRequest;
(function (TriggerEmoteRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.predefinedEmote !== "") {
            writer.uint32(10).string(message.predefinedEmote);
        }
        return writer;
    }
    TriggerEmoteRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTriggerEmoteRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.predefinedEmote = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    TriggerEmoteRequest.decode = decode;
    function fromJSON(object) {
        return { predefinedEmote: isSet(object.predefinedEmote) ? String(object.predefinedEmote) : "" };
    }
    TriggerEmoteRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.predefinedEmote !== undefined && (obj.predefinedEmote = message.predefinedEmote);
        return obj;
    }
    TriggerEmoteRequest.toJSON = toJSON;
    function create(base) {
        return TriggerEmoteRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    TriggerEmoteRequest.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseTriggerEmoteRequest();
        message.predefinedEmote = (_a = object.predefinedEmote) !== null && _a !== void 0 ? _a : "";
        return message;
    }
    TriggerEmoteRequest.fromPartial = fromPartial;
})(TriggerEmoteRequest || (exports.TriggerEmoteRequest = TriggerEmoteRequest = {}));
function createBaseChangeRealmRequest() {
    return { realm: "", message: undefined };
}
var ChangeRealmRequest;
(function (ChangeRealmRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.realm !== "") {
            writer.uint32(10).string(message.realm);
        }
        if (message.message !== undefined) {
            writer.uint32(18).string(message.message);
        }
        return writer;
    }
    ChangeRealmRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChangeRealmRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.realm = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    ChangeRealmRequest.decode = decode;
    function fromJSON(object) {
        return {
            realm: isSet(object.realm) ? String(object.realm) : "",
            message: isSet(object.message) ? String(object.message) : undefined,
        };
    }
    ChangeRealmRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.realm !== undefined && (obj.realm = message.realm);
        message.message !== undefined && (obj.message = message.message);
        return obj;
    }
    ChangeRealmRequest.toJSON = toJSON;
    function create(base) {
        return ChangeRealmRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    ChangeRealmRequest.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBaseChangeRealmRequest();
        message.realm = (_a = object.realm) !== null && _a !== void 0 ? _a : "";
        message.message = (_b = object.message) !== null && _b !== void 0 ? _b : undefined;
        return message;
    }
    ChangeRealmRequest.fromPartial = fromPartial;
})(ChangeRealmRequest || (exports.ChangeRealmRequest = ChangeRealmRequest = {}));
function createBaseOpenExternalUrlRequest() {
    return { url: "" };
}
var OpenExternalUrlRequest;
(function (OpenExternalUrlRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.url !== "") {
            writer.uint32(10).string(message.url);
        }
        return writer;
    }
    OpenExternalUrlRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOpenExternalUrlRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.url = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    OpenExternalUrlRequest.decode = decode;
    function fromJSON(object) {
        return { url: isSet(object.url) ? String(object.url) : "" };
    }
    OpenExternalUrlRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.url !== undefined && (obj.url = message.url);
        return obj;
    }
    OpenExternalUrlRequest.toJSON = toJSON;
    function create(base) {
        return OpenExternalUrlRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    OpenExternalUrlRequest.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseOpenExternalUrlRequest();
        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : "";
        return message;
    }
    OpenExternalUrlRequest.fromPartial = fromPartial;
})(OpenExternalUrlRequest || (exports.OpenExternalUrlRequest = OpenExternalUrlRequest = {}));
function createBaseOpenNftDialogRequest() {
    return { urn: "" };
}
var OpenNftDialogRequest;
(function (OpenNftDialogRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.urn !== "") {
            writer.uint32(10).string(message.urn);
        }
        return writer;
    }
    OpenNftDialogRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOpenNftDialogRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.urn = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    OpenNftDialogRequest.decode = decode;
    function fromJSON(object) {
        return { urn: isSet(object.urn) ? String(object.urn) : "" };
    }
    OpenNftDialogRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.urn !== undefined && (obj.urn = message.urn);
        return obj;
    }
    OpenNftDialogRequest.toJSON = toJSON;
    function create(base) {
        return OpenNftDialogRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    OpenNftDialogRequest.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseOpenNftDialogRequest();
        message.urn = (_a = object.urn) !== null && _a !== void 0 ? _a : "";
        return message;
    }
    OpenNftDialogRequest.fromPartial = fromPartial;
})(OpenNftDialogRequest || (exports.OpenNftDialogRequest = OpenNftDialogRequest = {}));
function createBaseUnblockPointerRequest() {
    return {};
}
var UnblockPointerRequest;
(function (UnblockPointerRequest) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    UnblockPointerRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnblockPointerRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    UnblockPointerRequest.decode = decode;
    function fromJSON(_) {
        return {};
    }
    UnblockPointerRequest.fromJSON = fromJSON;
    function toJSON(_) {
        const obj = {};
        return obj;
    }
    UnblockPointerRequest.toJSON = toJSON;
    function create(base) {
        return UnblockPointerRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    UnblockPointerRequest.create = create;
    function fromPartial(_) {
        const message = createBaseUnblockPointerRequest();
        return message;
    }
    UnblockPointerRequest.fromPartial = fromPartial;
})(UnblockPointerRequest || (exports.UnblockPointerRequest = UnblockPointerRequest = {}));
function createBaseCommsAdapterRequest() {
    return { connectionString: "" };
}
var CommsAdapterRequest;
(function (CommsAdapterRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionString !== "") {
            writer.uint32(10).string(message.connectionString);
        }
        return writer;
    }
    CommsAdapterRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommsAdapterRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.connectionString = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    CommsAdapterRequest.decode = decode;
    function fromJSON(object) {
        return { connectionString: isSet(object.connectionString) ? String(object.connectionString) : "" };
    }
    CommsAdapterRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.connectionString !== undefined && (obj.connectionString = message.connectionString);
        return obj;
    }
    CommsAdapterRequest.toJSON = toJSON;
    function create(base) {
        return CommsAdapterRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    CommsAdapterRequest.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseCommsAdapterRequest();
        message.connectionString = (_a = object.connectionString) !== null && _a !== void 0 ? _a : "";
        return message;
    }
    CommsAdapterRequest.fromPartial = fromPartial;
})(CommsAdapterRequest || (exports.CommsAdapterRequest = CommsAdapterRequest = {}));
function createBaseTriggerSceneEmoteRequest() {
    return { src: "", loop: undefined };
}
var TriggerSceneEmoteRequest;
(function (TriggerSceneEmoteRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.src !== "") {
            writer.uint32(10).string(message.src);
        }
        if (message.loop !== undefined) {
            writer.uint32(16).bool(message.loop);
        }
        return writer;
    }
    TriggerSceneEmoteRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTriggerSceneEmoteRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.src = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.loop = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    TriggerSceneEmoteRequest.decode = decode;
    function fromJSON(object) {
        return {
            src: isSet(object.src) ? String(object.src) : "",
            loop: isSet(object.loop) ? Boolean(object.loop) : undefined,
        };
    }
    TriggerSceneEmoteRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.src !== undefined && (obj.src = message.src);
        message.loop !== undefined && (obj.loop = message.loop);
        return obj;
    }
    TriggerSceneEmoteRequest.toJSON = toJSON;
    function create(base) {
        return TriggerSceneEmoteRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    TriggerSceneEmoteRequest.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBaseTriggerSceneEmoteRequest();
        message.src = (_a = object.src) !== null && _a !== void 0 ? _a : "";
        message.loop = (_b = object.loop) !== null && _b !== void 0 ? _b : undefined;
        return message;
    }
    TriggerSceneEmoteRequest.fromPartial = fromPartial;
})(TriggerSceneEmoteRequest || (exports.TriggerSceneEmoteRequest = TriggerSceneEmoteRequest = {}));
function createBaseSuccessResponse() {
    return { success: false };
}
var SuccessResponse;
(function (SuccessResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.success === true) {
            writer.uint32(8).bool(message.success);
        }
        return writer;
    }
    SuccessResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSuccessResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    SuccessResponse.decode = decode;
    function fromJSON(object) {
        return { success: isSet(object.success) ? Boolean(object.success) : false };
    }
    SuccessResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.success !== undefined && (obj.success = message.success);
        return obj;
    }
    SuccessResponse.toJSON = toJSON;
    function create(base) {
        return SuccessResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    SuccessResponse.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseSuccessResponse();
        message.success = (_a = object.success) !== null && _a !== void 0 ? _a : false;
        return message;
    }
    SuccessResponse.fromPartial = fromPartial;
})(SuccessResponse || (exports.SuccessResponse = SuccessResponse = {}));
function createBaseTriggerEmoteResponse() {
    return {};
}
var TriggerEmoteResponse;
(function (TriggerEmoteResponse) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    TriggerEmoteResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTriggerEmoteResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    TriggerEmoteResponse.decode = decode;
    function fromJSON(_) {
        return {};
    }
    TriggerEmoteResponse.fromJSON = fromJSON;
    function toJSON(_) {
        const obj = {};
        return obj;
    }
    TriggerEmoteResponse.toJSON = toJSON;
    function create(base) {
        return TriggerEmoteResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    TriggerEmoteResponse.create = create;
    function fromPartial(_) {
        const message = createBaseTriggerEmoteResponse();
        return message;
    }
    TriggerEmoteResponse.fromPartial = fromPartial;
})(TriggerEmoteResponse || (exports.TriggerEmoteResponse = TriggerEmoteResponse = {}));
function createBaseMovePlayerToResponse() {
    return {};
}
var MovePlayerToResponse;
(function (MovePlayerToResponse) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    MovePlayerToResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMovePlayerToResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    MovePlayerToResponse.decode = decode;
    function fromJSON(_) {
        return {};
    }
    MovePlayerToResponse.fromJSON = fromJSON;
    function toJSON(_) {
        const obj = {};
        return obj;
    }
    MovePlayerToResponse.toJSON = toJSON;
    function create(base) {
        return MovePlayerToResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    MovePlayerToResponse.create = create;
    function fromPartial(_) {
        const message = createBaseMovePlayerToResponse();
        return message;
    }
    MovePlayerToResponse.fromPartial = fromPartial;
})(MovePlayerToResponse || (exports.MovePlayerToResponse = MovePlayerToResponse = {}));
function createBaseTeleportToResponse() {
    return {};
}
var TeleportToResponse;
(function (TeleportToResponse) {
    function encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    }
    TeleportToResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTeleportToResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    TeleportToResponse.decode = decode;
    function fromJSON(_) {
        return {};
    }
    TeleportToResponse.fromJSON = fromJSON;
    function toJSON(_) {
        const obj = {};
        return obj;
    }
    TeleportToResponse.toJSON = toJSON;
    function create(base) {
        return TeleportToResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    TeleportToResponse.create = create;
    function fromPartial(_) {
        const message = createBaseTeleportToResponse();
        return message;
    }
    TeleportToResponse.fromPartial = fromPartial;
})(TeleportToResponse || (exports.TeleportToResponse = TeleportToResponse = {}));
exports.RestrictedActionsServiceDefinition = {
    name: "RestrictedActionsService",
    fullName: "decentraland.kernel.apis.RestrictedActionsService",
    methods: {
        /** MovePlayerTo will move the player in a position relative to the current scene */
        movePlayerTo: {
            name: "MovePlayerTo",
            requestType: MovePlayerToRequest,
            requestStream: false,
            responseType: MovePlayerToResponse,
            responseStream: false,
            options: {},
        },
        /** TeleportTo will move the user to the specified world LAND parcel coordinates */
        teleportTo: {
            name: "TeleportTo",
            requestType: TeleportToRequest,
            requestStream: false,
            responseType: TeleportToResponse,
            responseStream: false,
            options: {},
        },
        /** TriggerEmote will trigger an emote in this current user */
        triggerEmote: {
            name: "TriggerEmote",
            requestType: TriggerEmoteRequest,
            requestStream: false,
            responseType: TriggerEmoteResponse,
            responseStream: false,
            options: {},
        },
        /** ChangeRealm prompts the user to change to a specific realm */
        changeRealm: {
            name: "ChangeRealm",
            requestType: ChangeRealmRequest,
            requestStream: false,
            responseType: SuccessResponse,
            responseStream: false,
            options: {},
        },
        /** OpenExternalUrl prompts the user to open an external link */
        openExternalUrl: {
            name: "OpenExternalUrl",
            requestType: OpenExternalUrlRequest,
            requestStream: false,
            responseType: SuccessResponse,
            responseStream: false,
            options: {},
        },
        /** OpenNftDialog opens an NFT dialog. */
        openNftDialog: {
            name: "OpenNftDialog",
            requestType: OpenNftDialogRequest,
            requestStream: false,
            responseType: SuccessResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Asks the explorer to connect to other communications adapter, this feature
         * can be used to join private game servers
         */
        setCommunicationsAdapter: {
            name: "SetCommunicationsAdapter",
            requestType: CommsAdapterRequest,
            requestStream: false,
            responseType: SuccessResponse,
            responseStream: false,
            options: {},
        },
        /** TriggerSceneEmote will trigger an scene emote file in this current user */
        triggerSceneEmote: {
            name: "TriggerSceneEmote",
            requestType: TriggerSceneEmoteRequest,
            requestStream: false,
            responseType: SuccessResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=restricted_actions.gen.js.map