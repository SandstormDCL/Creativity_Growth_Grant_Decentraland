"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignedFetchServiceDefinition = exports.GetHeadersResponse_HeadersEntry = exports.GetHeadersResponse = exports.SignedFetchRequest = exports.FlatFetchResponse_HeadersEntry = exports.FlatFetchResponse = exports.FlatFetchInit_HeadersEntry = exports.FlatFetchInit = exports.protobufPackage = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "decentraland.kernel.apis";
function createBaseFlatFetchInit() {
    return { method: undefined, body: undefined, headers: {} };
}
var FlatFetchInit;
(function (FlatFetchInit) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.method !== undefined) {
            writer.uint32(10).string(message.method);
        }
        if (message.body !== undefined) {
            writer.uint32(18).string(message.body);
        }
        Object.entries(message.headers).forEach(([key, value]) => {
            FlatFetchInit_HeadersEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        return writer;
    }
    FlatFetchInit.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlatFetchInit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.method = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.body = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = FlatFetchInit_HeadersEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.headers[entry3.key] = entry3.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    FlatFetchInit.decode = decode;
    function fromJSON(object) {
        return {
            method: isSet(object.method) ? String(object.method) : undefined,
            body: isSet(object.body) ? String(object.body) : undefined,
            headers: isObject(object.headers)
                ? Object.entries(object.headers).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    }
    FlatFetchInit.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.method !== undefined && (obj.method = message.method);
        message.body !== undefined && (obj.body = message.body);
        obj.headers = {};
        if (message.headers) {
            Object.entries(message.headers).forEach(([k, v]) => {
                obj.headers[k] = v;
            });
        }
        return obj;
    }
    FlatFetchInit.toJSON = toJSON;
    function create(base) {
        return FlatFetchInit.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    FlatFetchInit.create = create;
    function fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseFlatFetchInit();
        message.method = (_a = object.method) !== null && _a !== void 0 ? _a : undefined;
        message.body = (_b = object.body) !== null && _b !== void 0 ? _b : undefined;
        message.headers = Object.entries((_c = object.headers) !== null && _c !== void 0 ? _c : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        return message;
    }
    FlatFetchInit.fromPartial = fromPartial;
})(FlatFetchInit || (exports.FlatFetchInit = FlatFetchInit = {}));
function createBaseFlatFetchInit_HeadersEntry() {
    return { key: "", value: "" };
}
var FlatFetchInit_HeadersEntry;
(function (FlatFetchInit_HeadersEntry) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    }
    FlatFetchInit_HeadersEntry.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlatFetchInit_HeadersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    FlatFetchInit_HeadersEntry.decode = decode;
    function fromJSON(object) {
        return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
    }
    FlatFetchInit_HeadersEntry.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    }
    FlatFetchInit_HeadersEntry.toJSON = toJSON;
    function create(base) {
        return FlatFetchInit_HeadersEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    FlatFetchInit_HeadersEntry.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBaseFlatFetchInit_HeadersEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    }
    FlatFetchInit_HeadersEntry.fromPartial = fromPartial;
})(FlatFetchInit_HeadersEntry || (exports.FlatFetchInit_HeadersEntry = FlatFetchInit_HeadersEntry = {}));
function createBaseFlatFetchResponse() {
    return { ok: false, status: 0, statusText: "", headers: {}, body: "" };
}
var FlatFetchResponse;
(function (FlatFetchResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ok === true) {
            writer.uint32(8).bool(message.ok);
        }
        if (message.status !== 0) {
            writer.uint32(16).int32(message.status);
        }
        if (message.statusText !== "") {
            writer.uint32(26).string(message.statusText);
        }
        Object.entries(message.headers).forEach(([key, value]) => {
            FlatFetchResponse_HeadersEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();
        });
        if (message.body !== "") {
            writer.uint32(42).string(message.body);
        }
        return writer;
    }
    FlatFetchResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlatFetchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.ok = reader.bool();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.statusText = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = FlatFetchResponse_HeadersEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.headers[entry4.key] = entry4.value;
                    }
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.body = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    FlatFetchResponse.decode = decode;
    function fromJSON(object) {
        return {
            ok: isSet(object.ok) ? Boolean(object.ok) : false,
            status: isSet(object.status) ? Number(object.status) : 0,
            statusText: isSet(object.statusText) ? String(object.statusText) : "",
            headers: isObject(object.headers)
                ? Object.entries(object.headers).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            body: isSet(object.body) ? String(object.body) : "",
        };
    }
    FlatFetchResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.ok !== undefined && (obj.ok = message.ok);
        message.status !== undefined && (obj.status = Math.round(message.status));
        message.statusText !== undefined && (obj.statusText = message.statusText);
        obj.headers = {};
        if (message.headers) {
            Object.entries(message.headers).forEach(([k, v]) => {
                obj.headers[k] = v;
            });
        }
        message.body !== undefined && (obj.body = message.body);
        return obj;
    }
    FlatFetchResponse.toJSON = toJSON;
    function create(base) {
        return FlatFetchResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    FlatFetchResponse.create = create;
    function fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseFlatFetchResponse();
        message.ok = (_a = object.ok) !== null && _a !== void 0 ? _a : false;
        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : 0;
        message.statusText = (_c = object.statusText) !== null && _c !== void 0 ? _c : "";
        message.headers = Object.entries((_d = object.headers) !== null && _d !== void 0 ? _d : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        message.body = (_e = object.body) !== null && _e !== void 0 ? _e : "";
        return message;
    }
    FlatFetchResponse.fromPartial = fromPartial;
})(FlatFetchResponse || (exports.FlatFetchResponse = FlatFetchResponse = {}));
function createBaseFlatFetchResponse_HeadersEntry() {
    return { key: "", value: "" };
}
var FlatFetchResponse_HeadersEntry;
(function (FlatFetchResponse_HeadersEntry) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    }
    FlatFetchResponse_HeadersEntry.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlatFetchResponse_HeadersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    FlatFetchResponse_HeadersEntry.decode = decode;
    function fromJSON(object) {
        return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
    }
    FlatFetchResponse_HeadersEntry.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    }
    FlatFetchResponse_HeadersEntry.toJSON = toJSON;
    function create(base) {
        return FlatFetchResponse_HeadersEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    FlatFetchResponse_HeadersEntry.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBaseFlatFetchResponse_HeadersEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    }
    FlatFetchResponse_HeadersEntry.fromPartial = fromPartial;
})(FlatFetchResponse_HeadersEntry || (exports.FlatFetchResponse_HeadersEntry = FlatFetchResponse_HeadersEntry = {}));
function createBaseSignedFetchRequest() {
    return { url: "", init: undefined };
}
var SignedFetchRequest;
(function (SignedFetchRequest) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.url !== "") {
            writer.uint32(10).string(message.url);
        }
        if (message.init !== undefined) {
            FlatFetchInit.encode(message.init, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    }
    SignedFetchRequest.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedFetchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.url = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.init = FlatFetchInit.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    SignedFetchRequest.decode = decode;
    function fromJSON(object) {
        return {
            url: isSet(object.url) ? String(object.url) : "",
            init: isSet(object.init) ? FlatFetchInit.fromJSON(object.init) : undefined,
        };
    }
    SignedFetchRequest.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.url !== undefined && (obj.url = message.url);
        message.init !== undefined && (obj.init = message.init ? FlatFetchInit.toJSON(message.init) : undefined);
        return obj;
    }
    SignedFetchRequest.toJSON = toJSON;
    function create(base) {
        return SignedFetchRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    SignedFetchRequest.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseSignedFetchRequest();
        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : "";
        message.init = (object.init !== undefined && object.init !== null)
            ? FlatFetchInit.fromPartial(object.init)
            : undefined;
        return message;
    }
    SignedFetchRequest.fromPartial = fromPartial;
})(SignedFetchRequest || (exports.SignedFetchRequest = SignedFetchRequest = {}));
function createBaseGetHeadersResponse() {
    return { headers: {} };
}
var GetHeadersResponse;
(function (GetHeadersResponse) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.headers).forEach(([key, value]) => {
            GetHeadersResponse_HeadersEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    }
    GetHeadersResponse.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetHeadersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = GetHeadersResponse_HeadersEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.headers[entry1.key] = entry1.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    GetHeadersResponse.decode = decode;
    function fromJSON(object) {
        return {
            headers: isObject(object.headers)
                ? Object.entries(object.headers).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    }
    GetHeadersResponse.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        obj.headers = {};
        if (message.headers) {
            Object.entries(message.headers).forEach(([k, v]) => {
                obj.headers[k] = v;
            });
        }
        return obj;
    }
    GetHeadersResponse.toJSON = toJSON;
    function create(base) {
        return GetHeadersResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    GetHeadersResponse.create = create;
    function fromPartial(object) {
        var _a;
        const message = createBaseGetHeadersResponse();
        message.headers = Object.entries((_a = object.headers) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        return message;
    }
    GetHeadersResponse.fromPartial = fromPartial;
})(GetHeadersResponse || (exports.GetHeadersResponse = GetHeadersResponse = {}));
function createBaseGetHeadersResponse_HeadersEntry() {
    return { key: "", value: "" };
}
var GetHeadersResponse_HeadersEntry;
(function (GetHeadersResponse_HeadersEntry) {
    function encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    }
    GetHeadersResponse_HeadersEntry.encode = encode;
    function decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetHeadersResponse_HeadersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    }
    GetHeadersResponse_HeadersEntry.decode = decode;
    function fromJSON(object) {
        return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
    }
    GetHeadersResponse_HeadersEntry.fromJSON = fromJSON;
    function toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    }
    GetHeadersResponse_HeadersEntry.toJSON = toJSON;
    function create(base) {
        return GetHeadersResponse_HeadersEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    }
    GetHeadersResponse_HeadersEntry.create = create;
    function fromPartial(object) {
        var _a, _b;
        const message = createBaseGetHeadersResponse_HeadersEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    }
    GetHeadersResponse_HeadersEntry.fromPartial = fromPartial;
})(GetHeadersResponse_HeadersEntry || (exports.GetHeadersResponse_HeadersEntry = GetHeadersResponse_HeadersEntry = {}));
exports.SignedFetchServiceDefinition = {
    name: "SignedFetchService",
    fullName: "decentraland.kernel.apis.SignedFetchService",
    methods: {
        /**
         * SignedFetch is used to authenticate JSON requests in name of the users,
         * a special scoped signature is generated following the https://adr.decentraland.org/adr/ADR-44
         */
        signedFetch: {
            name: "SignedFetch",
            requestType: SignedFetchRequest,
            requestStream: false,
            responseType: FlatFetchResponse,
            responseStream: false,
            options: {},
        },
        getHeaders: {
            name: "GetHeaders",
            requestType: SignedFetchRequest,
            requestStream: false,
            responseType: GetHeadersResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=signed_fetch.gen.js.map