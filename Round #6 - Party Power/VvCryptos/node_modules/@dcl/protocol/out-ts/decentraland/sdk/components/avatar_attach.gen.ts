/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "decentraland.sdk.components";

/** AvatarAnchorPointType determines the part of the avatar's body that anchors the Entity. */
export enum AvatarAnchorPointType {
  /** AAPT_POSITION - @deprecated consider parenting to `engine.PlayerEntity`, this will attach to player position with an arbitrary offset */
  AAPT_POSITION = 0,
  AAPT_NAME_TAG = 1,
  AAPT_HEAD = 4,
  AAPT_NECK = 5,
  AAPT_SPINE = 6,
  AAPT_SPINE1 = 7,
  AAPT_SPINE2 = 8,
  AAPT_HIP = 9,
  AAPT_LEFT_SHOULDER = 10,
  AAPT_LEFT_ARM = 11,
  AAPT_LEFT_FOREARM = 12,
  AAPT_LEFT_HAND = 2,
  AAPT_LEFT_HAND_INDEX = 13,
  AAPT_RIGHT_SHOULDER = 14,
  AAPT_RIGHT_ARM = 15,
  AAPT_RIGHT_FOREARM = 16,
  AAPT_RIGHT_HAND = 3,
  AAPT_RIGHT_HAND_INDEX = 17,
  AAPT_LEFT_UP_LEG = 18,
  AAPT_LEFT_LEG = 19,
  AAPT_LEFT_FOOT = 20,
  AAPT_LEFT_TOE_BASE = 21,
  AAPT_RIGHT_UP_LEG = 22,
  AAPT_RIGHT_LEG = 23,
  AAPT_RIGHT_FOOT = 24,
  AAPT_RIGHT_TOE_BASE = 25,
  UNRECOGNIZED = -1,
}

export function avatarAnchorPointTypeFromJSON(object: any): AvatarAnchorPointType {
  switch (object) {
    case 0:
    case "AAPT_POSITION":
      return AvatarAnchorPointType.AAPT_POSITION;
    case 1:
    case "AAPT_NAME_TAG":
      return AvatarAnchorPointType.AAPT_NAME_TAG;
    case 4:
    case "AAPT_HEAD":
      return AvatarAnchorPointType.AAPT_HEAD;
    case 5:
    case "AAPT_NECK":
      return AvatarAnchorPointType.AAPT_NECK;
    case 6:
    case "AAPT_SPINE":
      return AvatarAnchorPointType.AAPT_SPINE;
    case 7:
    case "AAPT_SPINE1":
      return AvatarAnchorPointType.AAPT_SPINE1;
    case 8:
    case "AAPT_SPINE2":
      return AvatarAnchorPointType.AAPT_SPINE2;
    case 9:
    case "AAPT_HIP":
      return AvatarAnchorPointType.AAPT_HIP;
    case 10:
    case "AAPT_LEFT_SHOULDER":
      return AvatarAnchorPointType.AAPT_LEFT_SHOULDER;
    case 11:
    case "AAPT_LEFT_ARM":
      return AvatarAnchorPointType.AAPT_LEFT_ARM;
    case 12:
    case "AAPT_LEFT_FOREARM":
      return AvatarAnchorPointType.AAPT_LEFT_FOREARM;
    case 2:
    case "AAPT_LEFT_HAND":
      return AvatarAnchorPointType.AAPT_LEFT_HAND;
    case 13:
    case "AAPT_LEFT_HAND_INDEX":
      return AvatarAnchorPointType.AAPT_LEFT_HAND_INDEX;
    case 14:
    case "AAPT_RIGHT_SHOULDER":
      return AvatarAnchorPointType.AAPT_RIGHT_SHOULDER;
    case 15:
    case "AAPT_RIGHT_ARM":
      return AvatarAnchorPointType.AAPT_RIGHT_ARM;
    case 16:
    case "AAPT_RIGHT_FOREARM":
      return AvatarAnchorPointType.AAPT_RIGHT_FOREARM;
    case 3:
    case "AAPT_RIGHT_HAND":
      return AvatarAnchorPointType.AAPT_RIGHT_HAND;
    case 17:
    case "AAPT_RIGHT_HAND_INDEX":
      return AvatarAnchorPointType.AAPT_RIGHT_HAND_INDEX;
    case 18:
    case "AAPT_LEFT_UP_LEG":
      return AvatarAnchorPointType.AAPT_LEFT_UP_LEG;
    case 19:
    case "AAPT_LEFT_LEG":
      return AvatarAnchorPointType.AAPT_LEFT_LEG;
    case 20:
    case "AAPT_LEFT_FOOT":
      return AvatarAnchorPointType.AAPT_LEFT_FOOT;
    case 21:
    case "AAPT_LEFT_TOE_BASE":
      return AvatarAnchorPointType.AAPT_LEFT_TOE_BASE;
    case 22:
    case "AAPT_RIGHT_UP_LEG":
      return AvatarAnchorPointType.AAPT_RIGHT_UP_LEG;
    case 23:
    case "AAPT_RIGHT_LEG":
      return AvatarAnchorPointType.AAPT_RIGHT_LEG;
    case 24:
    case "AAPT_RIGHT_FOOT":
      return AvatarAnchorPointType.AAPT_RIGHT_FOOT;
    case 25:
    case "AAPT_RIGHT_TOE_BASE":
      return AvatarAnchorPointType.AAPT_RIGHT_TOE_BASE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AvatarAnchorPointType.UNRECOGNIZED;
  }
}

export function avatarAnchorPointTypeToJSON(object: AvatarAnchorPointType): string {
  switch (object) {
    case AvatarAnchorPointType.AAPT_POSITION:
      return "AAPT_POSITION";
    case AvatarAnchorPointType.AAPT_NAME_TAG:
      return "AAPT_NAME_TAG";
    case AvatarAnchorPointType.AAPT_HEAD:
      return "AAPT_HEAD";
    case AvatarAnchorPointType.AAPT_NECK:
      return "AAPT_NECK";
    case AvatarAnchorPointType.AAPT_SPINE:
      return "AAPT_SPINE";
    case AvatarAnchorPointType.AAPT_SPINE1:
      return "AAPT_SPINE1";
    case AvatarAnchorPointType.AAPT_SPINE2:
      return "AAPT_SPINE2";
    case AvatarAnchorPointType.AAPT_HIP:
      return "AAPT_HIP";
    case AvatarAnchorPointType.AAPT_LEFT_SHOULDER:
      return "AAPT_LEFT_SHOULDER";
    case AvatarAnchorPointType.AAPT_LEFT_ARM:
      return "AAPT_LEFT_ARM";
    case AvatarAnchorPointType.AAPT_LEFT_FOREARM:
      return "AAPT_LEFT_FOREARM";
    case AvatarAnchorPointType.AAPT_LEFT_HAND:
      return "AAPT_LEFT_HAND";
    case AvatarAnchorPointType.AAPT_LEFT_HAND_INDEX:
      return "AAPT_LEFT_HAND_INDEX";
    case AvatarAnchorPointType.AAPT_RIGHT_SHOULDER:
      return "AAPT_RIGHT_SHOULDER";
    case AvatarAnchorPointType.AAPT_RIGHT_ARM:
      return "AAPT_RIGHT_ARM";
    case AvatarAnchorPointType.AAPT_RIGHT_FOREARM:
      return "AAPT_RIGHT_FOREARM";
    case AvatarAnchorPointType.AAPT_RIGHT_HAND:
      return "AAPT_RIGHT_HAND";
    case AvatarAnchorPointType.AAPT_RIGHT_HAND_INDEX:
      return "AAPT_RIGHT_HAND_INDEX";
    case AvatarAnchorPointType.AAPT_LEFT_UP_LEG:
      return "AAPT_LEFT_UP_LEG";
    case AvatarAnchorPointType.AAPT_LEFT_LEG:
      return "AAPT_LEFT_LEG";
    case AvatarAnchorPointType.AAPT_LEFT_FOOT:
      return "AAPT_LEFT_FOOT";
    case AvatarAnchorPointType.AAPT_LEFT_TOE_BASE:
      return "AAPT_LEFT_TOE_BASE";
    case AvatarAnchorPointType.AAPT_RIGHT_UP_LEG:
      return "AAPT_RIGHT_UP_LEG";
    case AvatarAnchorPointType.AAPT_RIGHT_LEG:
      return "AAPT_RIGHT_LEG";
    case AvatarAnchorPointType.AAPT_RIGHT_FOOT:
      return "AAPT_RIGHT_FOOT";
    case AvatarAnchorPointType.AAPT_RIGHT_TOE_BASE:
      return "AAPT_RIGHT_TOE_BASE";
    case AvatarAnchorPointType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The AvatarAttach component automatically repositions an Entity to maintain the same position and
 * rotation relative to some part of an avatar, called the "anchor point". The Entity
 * will follow this anchor as it moves.
 *
 * The Entity's own Transform is overridden by this component. To offset position and adjust scale,
 * add a child to the anchored Entity and set a Transform on it instead.
 *
 * AvatarAnchorPointType indicates which part of the avatar the Entity must follow.
 */
export interface PBAvatarAttach {
  /** the user ID of the avatar (default: local user) */
  avatarId?:
    | string
    | undefined;
  /** the anchor point. */
  anchorPointId: AvatarAnchorPointType;
}

function createBasePBAvatarAttach(): PBAvatarAttach {
  return { avatarId: undefined, anchorPointId: 0 };
}

export namespace PBAvatarAttach {
  export function encode(message: PBAvatarAttach, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.avatarId !== undefined) {
      writer.uint32(10).string(message.avatarId);
    }
    if (message.anchorPointId !== 0) {
      writer.uint32(16).int32(message.anchorPointId);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): PBAvatarAttach {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBAvatarAttach();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.avatarId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.anchorPointId = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): PBAvatarAttach {
    return {
      avatarId: isSet(object.avatarId) ? String(object.avatarId) : undefined,
      anchorPointId: isSet(object.anchorPointId) ? avatarAnchorPointTypeFromJSON(object.anchorPointId) : 0,
    };
  }

  export function toJSON(message: PBAvatarAttach): unknown {
    const obj: any = {};
    message.avatarId !== undefined && (obj.avatarId = message.avatarId);
    message.anchorPointId !== undefined && (obj.anchorPointId = avatarAnchorPointTypeToJSON(message.anchorPointId));
    return obj;
  }

  export function create<I extends Exact<DeepPartial<PBAvatarAttach>, I>>(base?: I): PBAvatarAttach {
    return PBAvatarAttach.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<PBAvatarAttach>, I>>(object: I): PBAvatarAttach {
    const message = createBasePBAvatarAttach();
    message.avatarId = object.avatarId ?? undefined;
    message.anchorPointId = object.anchorPointId ?? 0;
    return message;
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
