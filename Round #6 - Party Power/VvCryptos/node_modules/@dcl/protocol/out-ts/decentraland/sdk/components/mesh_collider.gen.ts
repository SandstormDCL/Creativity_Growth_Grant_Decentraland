/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "decentraland.sdk.components";

/** ColliderLayer determines the kind of collision to detect, in OR-able bit flag form. */
export enum ColliderLayer {
  /** CL_NONE - no collisions */
  CL_NONE = 0,
  /** CL_POINTER - collisions with the player's pointer ray (e.g. mouse cursor hovering) */
  CL_POINTER = 1,
  /** CL_PHYSICS - collision affecting your player's physics i.e. walls, floor, moving platfroms */
  CL_PHYSICS = 2,
  CL_RESERVED1 = 4,
  CL_RESERVED2 = 8,
  CL_RESERVED3 = 16,
  CL_RESERVED4 = 32,
  CL_RESERVED5 = 64,
  CL_RESERVED6 = 128,
  CL_CUSTOM1 = 256,
  CL_CUSTOM2 = 512,
  CL_CUSTOM3 = 1024,
  CL_CUSTOM4 = 2048,
  CL_CUSTOM5 = 4096,
  CL_CUSTOM6 = 8192,
  CL_CUSTOM7 = 16384,
  CL_CUSTOM8 = 32768,
  UNRECOGNIZED = -1,
}

export function colliderLayerFromJSON(object: any): ColliderLayer {
  switch (object) {
    case 0:
    case "CL_NONE":
      return ColliderLayer.CL_NONE;
    case 1:
    case "CL_POINTER":
      return ColliderLayer.CL_POINTER;
    case 2:
    case "CL_PHYSICS":
      return ColliderLayer.CL_PHYSICS;
    case 4:
    case "CL_RESERVED1":
      return ColliderLayer.CL_RESERVED1;
    case 8:
    case "CL_RESERVED2":
      return ColliderLayer.CL_RESERVED2;
    case 16:
    case "CL_RESERVED3":
      return ColliderLayer.CL_RESERVED3;
    case 32:
    case "CL_RESERVED4":
      return ColliderLayer.CL_RESERVED4;
    case 64:
    case "CL_RESERVED5":
      return ColliderLayer.CL_RESERVED5;
    case 128:
    case "CL_RESERVED6":
      return ColliderLayer.CL_RESERVED6;
    case 256:
    case "CL_CUSTOM1":
      return ColliderLayer.CL_CUSTOM1;
    case 512:
    case "CL_CUSTOM2":
      return ColliderLayer.CL_CUSTOM2;
    case 1024:
    case "CL_CUSTOM3":
      return ColliderLayer.CL_CUSTOM3;
    case 2048:
    case "CL_CUSTOM4":
      return ColliderLayer.CL_CUSTOM4;
    case 4096:
    case "CL_CUSTOM5":
      return ColliderLayer.CL_CUSTOM5;
    case 8192:
    case "CL_CUSTOM6":
      return ColliderLayer.CL_CUSTOM6;
    case 16384:
    case "CL_CUSTOM7":
      return ColliderLayer.CL_CUSTOM7;
    case 32768:
    case "CL_CUSTOM8":
      return ColliderLayer.CL_CUSTOM8;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ColliderLayer.UNRECOGNIZED;
  }
}

export function colliderLayerToJSON(object: ColliderLayer): string {
  switch (object) {
    case ColliderLayer.CL_NONE:
      return "CL_NONE";
    case ColliderLayer.CL_POINTER:
      return "CL_POINTER";
    case ColliderLayer.CL_PHYSICS:
      return "CL_PHYSICS";
    case ColliderLayer.CL_RESERVED1:
      return "CL_RESERVED1";
    case ColliderLayer.CL_RESERVED2:
      return "CL_RESERVED2";
    case ColliderLayer.CL_RESERVED3:
      return "CL_RESERVED3";
    case ColliderLayer.CL_RESERVED4:
      return "CL_RESERVED4";
    case ColliderLayer.CL_RESERVED5:
      return "CL_RESERVED5";
    case ColliderLayer.CL_RESERVED6:
      return "CL_RESERVED6";
    case ColliderLayer.CL_CUSTOM1:
      return "CL_CUSTOM1";
    case ColliderLayer.CL_CUSTOM2:
      return "CL_CUSTOM2";
    case ColliderLayer.CL_CUSTOM3:
      return "CL_CUSTOM3";
    case ColliderLayer.CL_CUSTOM4:
      return "CL_CUSTOM4";
    case ColliderLayer.CL_CUSTOM5:
      return "CL_CUSTOM5";
    case ColliderLayer.CL_CUSTOM6:
      return "CL_CUSTOM6";
    case ColliderLayer.CL_CUSTOM7:
      return "CL_CUSTOM7";
    case ColliderLayer.CL_CUSTOM8:
      return "CL_CUSTOM8";
    case ColliderLayer.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The MeshCollider component provides basic collision detection between Entities and Avatars. It
 * can behave like a cube, a plane, a sphere or a cylinder.
 *
 * The Entity's Transform affects the MeshCollider, scaling it and rotating it appropriately. If
 * the Transform for the collision mesh must be different than the Transform for rendering the Entity,
 * two different Entities must be used.
 *
 * More complex shapes require the use of a `GltfContainer` component.
 */
export interface PBMeshCollider {
  /** enabled ColliderLayers (default CL_POINTER | CL_PHYSICS) */
  collisionMask?: number | undefined;
  mesh?:
    | { $case: "box"; box: PBMeshCollider_BoxMesh }
    | { $case: "sphere"; sphere: PBMeshCollider_SphereMesh }
    | { $case: "cylinder"; cylinder: PBMeshCollider_CylinderMesh }
    | { $case: "plane"; plane: PBMeshCollider_PlaneMesh }
    | undefined;
}

/** BoxMesh is a prism shape that contains the Entity. */
export interface PBMeshCollider_BoxMesh {
}

/** CylinderMesh is a truncated cone shape that contains the Entity. */
export interface PBMeshCollider_CylinderMesh {
  /** (default 0.5) */
  radiusTop?:
    | number
    | undefined;
  /** (default 0.5) */
  radiusBottom?: number | undefined;
}

/** PlaneMesh is a 2D rectangle described by the Entity's Transform. */
export interface PBMeshCollider_PlaneMesh {
}

/** SphereMesh is a sphere shape that contains the Entity. */
export interface PBMeshCollider_SphereMesh {
}

function createBasePBMeshCollider(): PBMeshCollider {
  return { collisionMask: undefined, mesh: undefined };
}

export namespace PBMeshCollider {
  export function encode(message: PBMeshCollider, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.collisionMask !== undefined) {
      writer.uint32(8).uint32(message.collisionMask);
    }
    switch (message.mesh?.$case) {
      case "box":
        PBMeshCollider_BoxMesh.encode(message.mesh.box, writer.uint32(18).fork()).ldelim();
        break;
      case "sphere":
        PBMeshCollider_SphereMesh.encode(message.mesh.sphere, writer.uint32(26).fork()).ldelim();
        break;
      case "cylinder":
        PBMeshCollider_CylinderMesh.encode(message.mesh.cylinder, writer.uint32(34).fork()).ldelim();
        break;
      case "plane":
        PBMeshCollider_PlaneMesh.encode(message.mesh.plane, writer.uint32(42).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBMeshCollider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.collisionMask = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mesh = { $case: "box", box: PBMeshCollider_BoxMesh.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mesh = { $case: "sphere", sphere: PBMeshCollider_SphereMesh.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mesh = { $case: "cylinder", cylinder: PBMeshCollider_CylinderMesh.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mesh = { $case: "plane", plane: PBMeshCollider_PlaneMesh.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): PBMeshCollider {
    return {
      collisionMask: isSet(object.collisionMask) ? Number(object.collisionMask) : undefined,
      mesh: isSet(object.box)
        ? { $case: "box", box: PBMeshCollider_BoxMesh.fromJSON(object.box) }
        : isSet(object.sphere)
        ? { $case: "sphere", sphere: PBMeshCollider_SphereMesh.fromJSON(object.sphere) }
        : isSet(object.cylinder)
        ? { $case: "cylinder", cylinder: PBMeshCollider_CylinderMesh.fromJSON(object.cylinder) }
        : isSet(object.plane)
        ? { $case: "plane", plane: PBMeshCollider_PlaneMesh.fromJSON(object.plane) }
        : undefined,
    };
  }

  export function toJSON(message: PBMeshCollider): unknown {
    const obj: any = {};
    message.collisionMask !== undefined && (obj.collisionMask = Math.round(message.collisionMask));
    message.mesh?.$case === "box" &&
      (obj.box = message.mesh?.box ? PBMeshCollider_BoxMesh.toJSON(message.mesh?.box) : undefined);
    message.mesh?.$case === "sphere" &&
      (obj.sphere = message.mesh?.sphere ? PBMeshCollider_SphereMesh.toJSON(message.mesh?.sphere) : undefined);
    message.mesh?.$case === "cylinder" &&
      (obj.cylinder = message.mesh?.cylinder ? PBMeshCollider_CylinderMesh.toJSON(message.mesh?.cylinder) : undefined);
    message.mesh?.$case === "plane" &&
      (obj.plane = message.mesh?.plane ? PBMeshCollider_PlaneMesh.toJSON(message.mesh?.plane) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<PBMeshCollider>, I>>(base?: I): PBMeshCollider {
    return PBMeshCollider.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<PBMeshCollider>, I>>(object: I): PBMeshCollider {
    const message = createBasePBMeshCollider();
    message.collisionMask = object.collisionMask ?? undefined;
    if (object.mesh?.$case === "box" && object.mesh?.box !== undefined && object.mesh?.box !== null) {
      message.mesh = { $case: "box", box: PBMeshCollider_BoxMesh.fromPartial(object.mesh.box) };
    }
    if (object.mesh?.$case === "sphere" && object.mesh?.sphere !== undefined && object.mesh?.sphere !== null) {
      message.mesh = { $case: "sphere", sphere: PBMeshCollider_SphereMesh.fromPartial(object.mesh.sphere) };
    }
    if (object.mesh?.$case === "cylinder" && object.mesh?.cylinder !== undefined && object.mesh?.cylinder !== null) {
      message.mesh = { $case: "cylinder", cylinder: PBMeshCollider_CylinderMesh.fromPartial(object.mesh.cylinder) };
    }
    if (object.mesh?.$case === "plane" && object.mesh?.plane !== undefined && object.mesh?.plane !== null) {
      message.mesh = { $case: "plane", plane: PBMeshCollider_PlaneMesh.fromPartial(object.mesh.plane) };
    }
    return message;
  }
}

function createBasePBMeshCollider_BoxMesh(): PBMeshCollider_BoxMesh {
  return {};
}

export namespace PBMeshCollider_BoxMesh {
  export function encode(_: PBMeshCollider_BoxMesh, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_BoxMesh {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBMeshCollider_BoxMesh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): PBMeshCollider_BoxMesh {
    return {};
  }

  export function toJSON(_: PBMeshCollider_BoxMesh): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<PBMeshCollider_BoxMesh>, I>>(base?: I): PBMeshCollider_BoxMesh {
    return PBMeshCollider_BoxMesh.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<PBMeshCollider_BoxMesh>, I>>(_: I): PBMeshCollider_BoxMesh {
    const message = createBasePBMeshCollider_BoxMesh();
    return message;
  }
}

function createBasePBMeshCollider_CylinderMesh(): PBMeshCollider_CylinderMesh {
  return { radiusTop: undefined, radiusBottom: undefined };
}

export namespace PBMeshCollider_CylinderMesh {
  export function encode(message: PBMeshCollider_CylinderMesh, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.radiusTop !== undefined) {
      writer.uint32(13).float(message.radiusTop);
    }
    if (message.radiusBottom !== undefined) {
      writer.uint32(21).float(message.radiusBottom);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_CylinderMesh {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBMeshCollider_CylinderMesh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.radiusTop = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.radiusBottom = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): PBMeshCollider_CylinderMesh {
    return {
      radiusTop: isSet(object.radiusTop) ? Number(object.radiusTop) : undefined,
      radiusBottom: isSet(object.radiusBottom) ? Number(object.radiusBottom) : undefined,
    };
  }

  export function toJSON(message: PBMeshCollider_CylinderMesh): unknown {
    const obj: any = {};
    message.radiusTop !== undefined && (obj.radiusTop = message.radiusTop);
    message.radiusBottom !== undefined && (obj.radiusBottom = message.radiusBottom);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<PBMeshCollider_CylinderMesh>, I>>(
    base?: I,
  ): PBMeshCollider_CylinderMesh {
    return PBMeshCollider_CylinderMesh.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<PBMeshCollider_CylinderMesh>, I>>(
    object: I,
  ): PBMeshCollider_CylinderMesh {
    const message = createBasePBMeshCollider_CylinderMesh();
    message.radiusTop = object.radiusTop ?? undefined;
    message.radiusBottom = object.radiusBottom ?? undefined;
    return message;
  }
}

function createBasePBMeshCollider_PlaneMesh(): PBMeshCollider_PlaneMesh {
  return {};
}

export namespace PBMeshCollider_PlaneMesh {
  export function encode(_: PBMeshCollider_PlaneMesh, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_PlaneMesh {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBMeshCollider_PlaneMesh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): PBMeshCollider_PlaneMesh {
    return {};
  }

  export function toJSON(_: PBMeshCollider_PlaneMesh): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<PBMeshCollider_PlaneMesh>, I>>(
    base?: I,
  ): PBMeshCollider_PlaneMesh {
    return PBMeshCollider_PlaneMesh.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<PBMeshCollider_PlaneMesh>, I>>(
    _: I,
  ): PBMeshCollider_PlaneMesh {
    const message = createBasePBMeshCollider_PlaneMesh();
    return message;
  }
}

function createBasePBMeshCollider_SphereMesh(): PBMeshCollider_SphereMesh {
  return {};
}

export namespace PBMeshCollider_SphereMesh {
  export function encode(_: PBMeshCollider_SphereMesh, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): PBMeshCollider_SphereMesh {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBMeshCollider_SphereMesh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): PBMeshCollider_SphereMesh {
    return {};
  }

  export function toJSON(_: PBMeshCollider_SphereMesh): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<PBMeshCollider_SphereMesh>, I>>(
    base?: I,
  ): PBMeshCollider_SphereMesh {
    return PBMeshCollider_SphereMesh.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<PBMeshCollider_SphereMesh>, I>>(
    _: I,
  ): PBMeshCollider_SphereMesh {
    const message = createBasePBMeshCollider_SphereMesh();
    return message;
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
