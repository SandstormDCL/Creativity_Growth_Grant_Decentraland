/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Quaternion, Vector3 } from "../../common/vectors.gen";

export const protobufPackage = "decentraland.sdk.components";

/**
 * Implementation guidelines for these easing functions can be found
 * at https://github.com/ai/easings.net/blob/6fcd5f852a470bf1a7890e8178afa0f471d5f2ec/src/easings/easingsFunctions.ts
 */
export enum EasingFunction {
  /** EF_LINEAR - default */
  EF_LINEAR = 0,
  EF_EASEINQUAD = 1,
  EF_EASEOUTQUAD = 2,
  EF_EASEQUAD = 3,
  EF_EASEINSINE = 4,
  EF_EASEOUTSINE = 5,
  EF_EASESINE = 6,
  EF_EASEINEXPO = 7,
  EF_EASEOUTEXPO = 8,
  EF_EASEEXPO = 9,
  EF_EASEINELASTIC = 10,
  EF_EASEOUTELASTIC = 11,
  EF_EASEELASTIC = 12,
  EF_EASEINBOUNCE = 13,
  EF_EASEOUTBOUNCE = 14,
  EF_EASEBOUNCE = 15,
  EF_EASEINCUBIC = 16,
  EF_EASEOUTCUBIC = 17,
  EF_EASECUBIC = 18,
  EF_EASEINQUART = 19,
  EF_EASEOUTQUART = 20,
  EF_EASEQUART = 21,
  EF_EASEINQUINT = 22,
  EF_EASEOUTQUINT = 23,
  EF_EASEQUINT = 24,
  EF_EASEINCIRC = 25,
  EF_EASEOUTCIRC = 26,
  EF_EASECIRC = 27,
  EF_EASEINBACK = 28,
  EF_EASEOUTBACK = 29,
  EF_EASEBACK = 30,
  UNRECOGNIZED = -1,
}

export function easingFunctionFromJSON(object: any): EasingFunction {
  switch (object) {
    case 0:
    case "EF_LINEAR":
      return EasingFunction.EF_LINEAR;
    case 1:
    case "EF_EASEINQUAD":
      return EasingFunction.EF_EASEINQUAD;
    case 2:
    case "EF_EASEOUTQUAD":
      return EasingFunction.EF_EASEOUTQUAD;
    case 3:
    case "EF_EASEQUAD":
      return EasingFunction.EF_EASEQUAD;
    case 4:
    case "EF_EASEINSINE":
      return EasingFunction.EF_EASEINSINE;
    case 5:
    case "EF_EASEOUTSINE":
      return EasingFunction.EF_EASEOUTSINE;
    case 6:
    case "EF_EASESINE":
      return EasingFunction.EF_EASESINE;
    case 7:
    case "EF_EASEINEXPO":
      return EasingFunction.EF_EASEINEXPO;
    case 8:
    case "EF_EASEOUTEXPO":
      return EasingFunction.EF_EASEOUTEXPO;
    case 9:
    case "EF_EASEEXPO":
      return EasingFunction.EF_EASEEXPO;
    case 10:
    case "EF_EASEINELASTIC":
      return EasingFunction.EF_EASEINELASTIC;
    case 11:
    case "EF_EASEOUTELASTIC":
      return EasingFunction.EF_EASEOUTELASTIC;
    case 12:
    case "EF_EASEELASTIC":
      return EasingFunction.EF_EASEELASTIC;
    case 13:
    case "EF_EASEINBOUNCE":
      return EasingFunction.EF_EASEINBOUNCE;
    case 14:
    case "EF_EASEOUTBOUNCE":
      return EasingFunction.EF_EASEOUTBOUNCE;
    case 15:
    case "EF_EASEBOUNCE":
      return EasingFunction.EF_EASEBOUNCE;
    case 16:
    case "EF_EASEINCUBIC":
      return EasingFunction.EF_EASEINCUBIC;
    case 17:
    case "EF_EASEOUTCUBIC":
      return EasingFunction.EF_EASEOUTCUBIC;
    case 18:
    case "EF_EASECUBIC":
      return EasingFunction.EF_EASECUBIC;
    case 19:
    case "EF_EASEINQUART":
      return EasingFunction.EF_EASEINQUART;
    case 20:
    case "EF_EASEOUTQUART":
      return EasingFunction.EF_EASEOUTQUART;
    case 21:
    case "EF_EASEQUART":
      return EasingFunction.EF_EASEQUART;
    case 22:
    case "EF_EASEINQUINT":
      return EasingFunction.EF_EASEINQUINT;
    case 23:
    case "EF_EASEOUTQUINT":
      return EasingFunction.EF_EASEOUTQUINT;
    case 24:
    case "EF_EASEQUINT":
      return EasingFunction.EF_EASEQUINT;
    case 25:
    case "EF_EASEINCIRC":
      return EasingFunction.EF_EASEINCIRC;
    case 26:
    case "EF_EASEOUTCIRC":
      return EasingFunction.EF_EASEOUTCIRC;
    case 27:
    case "EF_EASECIRC":
      return EasingFunction.EF_EASECIRC;
    case 28:
    case "EF_EASEINBACK":
      return EasingFunction.EF_EASEINBACK;
    case 29:
    case "EF_EASEOUTBACK":
      return EasingFunction.EF_EASEOUTBACK;
    case 30:
    case "EF_EASEBACK":
      return EasingFunction.EF_EASEBACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EasingFunction.UNRECOGNIZED;
  }
}

export function easingFunctionToJSON(object: EasingFunction): string {
  switch (object) {
    case EasingFunction.EF_LINEAR:
      return "EF_LINEAR";
    case EasingFunction.EF_EASEINQUAD:
      return "EF_EASEINQUAD";
    case EasingFunction.EF_EASEOUTQUAD:
      return "EF_EASEOUTQUAD";
    case EasingFunction.EF_EASEQUAD:
      return "EF_EASEQUAD";
    case EasingFunction.EF_EASEINSINE:
      return "EF_EASEINSINE";
    case EasingFunction.EF_EASEOUTSINE:
      return "EF_EASEOUTSINE";
    case EasingFunction.EF_EASESINE:
      return "EF_EASESINE";
    case EasingFunction.EF_EASEINEXPO:
      return "EF_EASEINEXPO";
    case EasingFunction.EF_EASEOUTEXPO:
      return "EF_EASEOUTEXPO";
    case EasingFunction.EF_EASEEXPO:
      return "EF_EASEEXPO";
    case EasingFunction.EF_EASEINELASTIC:
      return "EF_EASEINELASTIC";
    case EasingFunction.EF_EASEOUTELASTIC:
      return "EF_EASEOUTELASTIC";
    case EasingFunction.EF_EASEELASTIC:
      return "EF_EASEELASTIC";
    case EasingFunction.EF_EASEINBOUNCE:
      return "EF_EASEINBOUNCE";
    case EasingFunction.EF_EASEOUTBOUNCE:
      return "EF_EASEOUTBOUNCE";
    case EasingFunction.EF_EASEBOUNCE:
      return "EF_EASEBOUNCE";
    case EasingFunction.EF_EASEINCUBIC:
      return "EF_EASEINCUBIC";
    case EasingFunction.EF_EASEOUTCUBIC:
      return "EF_EASEOUTCUBIC";
    case EasingFunction.EF_EASECUBIC:
      return "EF_EASECUBIC";
    case EasingFunction.EF_EASEINQUART:
      return "EF_EASEINQUART";
    case EasingFunction.EF_EASEOUTQUART:
      return "EF_EASEOUTQUART";
    case EasingFunction.EF_EASEQUART:
      return "EF_EASEQUART";
    case EasingFunction.EF_EASEINQUINT:
      return "EF_EASEINQUINT";
    case EasingFunction.EF_EASEOUTQUINT:
      return "EF_EASEOUTQUINT";
    case EasingFunction.EF_EASEQUINT:
      return "EF_EASEQUINT";
    case EasingFunction.EF_EASEINCIRC:
      return "EF_EASEINCIRC";
    case EasingFunction.EF_EASEOUTCIRC:
      return "EF_EASEOUTCIRC";
    case EasingFunction.EF_EASECIRC:
      return "EF_EASECIRC";
    case EasingFunction.EF_EASEINBACK:
      return "EF_EASEINBACK";
    case EasingFunction.EF_EASEOUTBACK:
      return "EF_EASEOUTBACK";
    case EasingFunction.EF_EASEBACK:
      return "EF_EASEBACK";
    case EasingFunction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PBTween {
  /** in milliseconds */
  duration: number;
  easingFunction: EasingFunction;
  mode?:
    | { $case: "move"; move: Move }
    | { $case: "rotate"; rotate: Rotate }
    | { $case: "scale"; scale: Scale }
    | undefined;
  /** default true (pause or running) */
  playing?:
    | boolean
    | undefined;
  /** between 0 and 1 */
  currentTime?: number | undefined;
}

export interface Move {
  start: Vector3 | undefined;
  end: Vector3 | undefined;
  faceDirection?: boolean | undefined;
}

export interface Rotate {
  start: Quaternion | undefined;
  end: Quaternion | undefined;
}

export interface Scale {
  start: Vector3 | undefined;
  end: Vector3 | undefined;
}

function createBasePBTween(): PBTween {
  return { duration: 0, easingFunction: 0, mode: undefined, playing: undefined, currentTime: undefined };
}

export namespace PBTween {
  export function encode(message: PBTween, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.duration !== 0) {
      writer.uint32(13).float(message.duration);
    }
    if (message.easingFunction !== 0) {
      writer.uint32(16).int32(message.easingFunction);
    }
    switch (message.mode?.$case) {
      case "move":
        Move.encode(message.mode.move, writer.uint32(26).fork()).ldelim();
        break;
      case "rotate":
        Rotate.encode(message.mode.rotate, writer.uint32(34).fork()).ldelim();
        break;
      case "scale":
        Scale.encode(message.mode.scale, writer.uint32(42).fork()).ldelim();
        break;
    }
    if (message.playing !== undefined) {
      writer.uint32(48).bool(message.playing);
    }
    if (message.currentTime !== undefined) {
      writer.uint32(61).float(message.currentTime);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): PBTween {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBTween();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.easingFunction = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mode = { $case: "move", move: Move.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mode = { $case: "rotate", rotate: Rotate.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mode = { $case: "scale", scale: Scale.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.playing = reader.bool();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.currentTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): PBTween {
    return {
      duration: isSet(object.duration) ? Number(object.duration) : 0,
      easingFunction: isSet(object.easingFunction) ? easingFunctionFromJSON(object.easingFunction) : 0,
      mode: isSet(object.move)
        ? { $case: "move", move: Move.fromJSON(object.move) }
        : isSet(object.rotate)
        ? { $case: "rotate", rotate: Rotate.fromJSON(object.rotate) }
        : isSet(object.scale)
        ? { $case: "scale", scale: Scale.fromJSON(object.scale) }
        : undefined,
      playing: isSet(object.playing) ? Boolean(object.playing) : undefined,
      currentTime: isSet(object.currentTime) ? Number(object.currentTime) : undefined,
    };
  }

  export function toJSON(message: PBTween): unknown {
    const obj: any = {};
    message.duration !== undefined && (obj.duration = message.duration);
    message.easingFunction !== undefined && (obj.easingFunction = easingFunctionToJSON(message.easingFunction));
    message.mode?.$case === "move" && (obj.move = message.mode?.move ? Move.toJSON(message.mode?.move) : undefined);
    message.mode?.$case === "rotate" &&
      (obj.rotate = message.mode?.rotate ? Rotate.toJSON(message.mode?.rotate) : undefined);
    message.mode?.$case === "scale" &&
      (obj.scale = message.mode?.scale ? Scale.toJSON(message.mode?.scale) : undefined);
    message.playing !== undefined && (obj.playing = message.playing);
    message.currentTime !== undefined && (obj.currentTime = message.currentTime);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<PBTween>, I>>(base?: I): PBTween {
    return PBTween.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<PBTween>, I>>(object: I): PBTween {
    const message = createBasePBTween();
    message.duration = object.duration ?? 0;
    message.easingFunction = object.easingFunction ?? 0;
    if (object.mode?.$case === "move" && object.mode?.move !== undefined && object.mode?.move !== null) {
      message.mode = { $case: "move", move: Move.fromPartial(object.mode.move) };
    }
    if (object.mode?.$case === "rotate" && object.mode?.rotate !== undefined && object.mode?.rotate !== null) {
      message.mode = { $case: "rotate", rotate: Rotate.fromPartial(object.mode.rotate) };
    }
    if (object.mode?.$case === "scale" && object.mode?.scale !== undefined && object.mode?.scale !== null) {
      message.mode = { $case: "scale", scale: Scale.fromPartial(object.mode.scale) };
    }
    message.playing = object.playing ?? undefined;
    message.currentTime = object.currentTime ?? undefined;
    return message;
  }
}

function createBaseMove(): Move {
  return { start: undefined, end: undefined, faceDirection: undefined };
}

export namespace Move {
  export function encode(message: Move, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.start !== undefined) {
      Vector3.encode(message.start, writer.uint32(10).fork()).ldelim();
    }
    if (message.end !== undefined) {
      Vector3.encode(message.end, writer.uint32(18).fork()).ldelim();
    }
    if (message.faceDirection !== undefined) {
      writer.uint32(24).bool(message.faceDirection);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Move {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.start = Vector3.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.end = Vector3.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.faceDirection = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Move {
    return {
      start: isSet(object.start) ? Vector3.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? Vector3.fromJSON(object.end) : undefined,
      faceDirection: isSet(object.faceDirection) ? Boolean(object.faceDirection) : undefined,
    };
  }

  export function toJSON(message: Move): unknown {
    const obj: any = {};
    message.start !== undefined && (obj.start = message.start ? Vector3.toJSON(message.start) : undefined);
    message.end !== undefined && (obj.end = message.end ? Vector3.toJSON(message.end) : undefined);
    message.faceDirection !== undefined && (obj.faceDirection = message.faceDirection);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Move>, I>>(base?: I): Move {
    return Move.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Move>, I>>(object: I): Move {
    const message = createBaseMove();
    message.start = (object.start !== undefined && object.start !== null)
      ? Vector3.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? Vector3.fromPartial(object.end) : undefined;
    message.faceDirection = object.faceDirection ?? undefined;
    return message;
  }
}

function createBaseRotate(): Rotate {
  return { start: undefined, end: undefined };
}

export namespace Rotate {
  export function encode(message: Rotate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.start !== undefined) {
      Quaternion.encode(message.start, writer.uint32(10).fork()).ldelim();
    }
    if (message.end !== undefined) {
      Quaternion.encode(message.end, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Rotate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.start = Quaternion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.end = Quaternion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Rotate {
    return {
      start: isSet(object.start) ? Quaternion.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? Quaternion.fromJSON(object.end) : undefined,
    };
  }

  export function toJSON(message: Rotate): unknown {
    const obj: any = {};
    message.start !== undefined && (obj.start = message.start ? Quaternion.toJSON(message.start) : undefined);
    message.end !== undefined && (obj.end = message.end ? Quaternion.toJSON(message.end) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Rotate>, I>>(base?: I): Rotate {
    return Rotate.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Rotate>, I>>(object: I): Rotate {
    const message = createBaseRotate();
    message.start = (object.start !== undefined && object.start !== null)
      ? Quaternion.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? Quaternion.fromPartial(object.end) : undefined;
    return message;
  }
}

function createBaseScale(): Scale {
  return { start: undefined, end: undefined };
}

export namespace Scale {
  export function encode(message: Scale, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.start !== undefined) {
      Vector3.encode(message.start, writer.uint32(10).fork()).ldelim();
    }
    if (message.end !== undefined) {
      Vector3.encode(message.end, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Scale {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScale();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.start = Vector3.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.end = Vector3.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Scale {
    return {
      start: isSet(object.start) ? Vector3.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? Vector3.fromJSON(object.end) : undefined,
    };
  }

  export function toJSON(message: Scale): unknown {
    const obj: any = {};
    message.start !== undefined && (obj.start = message.start ? Vector3.toJSON(message.start) : undefined);
    message.end !== undefined && (obj.end = message.end ? Vector3.toJSON(message.end) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Scale>, I>>(base?: I): Scale {
    return Scale.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Scale>, I>>(object: I): Scale {
    const message = createBaseScale();
    message.start = (object.start !== undefined && object.start !== null)
      ? Vector3.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? Vector3.fromPartial(object.end) : undefined;
    return message;
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
