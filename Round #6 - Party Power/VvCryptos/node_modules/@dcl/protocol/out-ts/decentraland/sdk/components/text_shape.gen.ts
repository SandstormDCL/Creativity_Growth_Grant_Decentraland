/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Color3, Color4 } from "../../common/colors.gen";
import {
  Font,
  fontFromJSON,
  fontToJSON,
  TextAlignMode,
  textAlignModeFromJSON,
  textAlignModeToJSON,
} from "./common/texts.gen";

export const protobufPackage = "decentraland.sdk.components";

/**
 * The TextShape component renders customizable floating text.
 *
 * The position and rotation of the text are defined by the Entity's Transform, while its size
 * can either scale with the Transform or be fixed by a font size.
 *
 * Several options can be configured, including color, padding, line spacing and drop shadows.
 */
export interface PBTextShape {
  /** the content */
  text: string;
  /** the font (default F_SANS_SERIF) */
  font?:
    | Font
    | undefined;
  /** the font size (default 10) */
  fontSize?:
    | number
    | undefined;
  /** override `font_size` to automatically fit in `width`/`height` */
  fontAutoSize?:
    | boolean
    | undefined;
  /** X and Y alignment (default TAM_CENTER_CENTER) */
  textAlign?:
    | TextAlignMode
    | undefined;
  /** available horizontal space (default 1) */
  width?:
    | number
    | undefined;
  /** available vertical space (default 1) */
  height?:
    | number
    | undefined;
  /** distance from text to top border (default 0) */
  paddingTop?:
    | number
    | undefined;
  /** distance from text to right border (default 0) */
  paddingRight?:
    | number
    | undefined;
  /** distance from text to bottom border (default 0) */
  paddingBottom?:
    | number
    | undefined;
  /** distance from text to left border (default 0) */
  paddingLeft?:
    | number
    | undefined;
  /** extra distance between lines (default 0) */
  lineSpacing?:
    | number
    | undefined;
  /** maximum number of lines to display */
  lineCount?:
    | number
    | undefined;
  /** wrap text when the border is reached (default false) */
  textWrapping?:
    | boolean
    | undefined;
  /** blurriness of the drop shadow (default 0) */
  shadowBlur?:
    | number
    | undefined;
  /** horizontal length of the shadow (default 0) */
  shadowOffsetX?:
    | number
    | undefined;
  /** vertical length of the shadow (default 0) */
  shadowOffsetY?:
    | number
    | undefined;
  /** width of the stroke outlining each letter (default 0) */
  outlineWidth?:
    | number
    | undefined;
  /** drop shadow color (default [1.0, 1.0, 1.0]) */
  shadowColor?:
    | Color3
    | undefined;
  /** outline stroke color (default [1.0, 1.0, 1.0]) */
  outlineColor?:
    | Color3
    | undefined;
  /** text color (default [1.0, 1.0, 1.0]) */
  textColor?: Color4 | undefined;
}

function createBasePBTextShape(): PBTextShape {
  return {
    text: "",
    font: undefined,
    fontSize: undefined,
    fontAutoSize: undefined,
    textAlign: undefined,
    width: undefined,
    height: undefined,
    paddingTop: undefined,
    paddingRight: undefined,
    paddingBottom: undefined,
    paddingLeft: undefined,
    lineSpacing: undefined,
    lineCount: undefined,
    textWrapping: undefined,
    shadowBlur: undefined,
    shadowOffsetX: undefined,
    shadowOffsetY: undefined,
    outlineWidth: undefined,
    shadowColor: undefined,
    outlineColor: undefined,
    textColor: undefined,
  };
}

export namespace PBTextShape {
  export function encode(message: PBTextShape, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.font !== undefined) {
      writer.uint32(16).int32(message.font);
    }
    if (message.fontSize !== undefined) {
      writer.uint32(29).float(message.fontSize);
    }
    if (message.fontAutoSize !== undefined) {
      writer.uint32(32).bool(message.fontAutoSize);
    }
    if (message.textAlign !== undefined) {
      writer.uint32(40).int32(message.textAlign);
    }
    if (message.width !== undefined) {
      writer.uint32(53).float(message.width);
    }
    if (message.height !== undefined) {
      writer.uint32(61).float(message.height);
    }
    if (message.paddingTop !== undefined) {
      writer.uint32(69).float(message.paddingTop);
    }
    if (message.paddingRight !== undefined) {
      writer.uint32(77).float(message.paddingRight);
    }
    if (message.paddingBottom !== undefined) {
      writer.uint32(85).float(message.paddingBottom);
    }
    if (message.paddingLeft !== undefined) {
      writer.uint32(93).float(message.paddingLeft);
    }
    if (message.lineSpacing !== undefined) {
      writer.uint32(101).float(message.lineSpacing);
    }
    if (message.lineCount !== undefined) {
      writer.uint32(104).int32(message.lineCount);
    }
    if (message.textWrapping !== undefined) {
      writer.uint32(112).bool(message.textWrapping);
    }
    if (message.shadowBlur !== undefined) {
      writer.uint32(125).float(message.shadowBlur);
    }
    if (message.shadowOffsetX !== undefined) {
      writer.uint32(133).float(message.shadowOffsetX);
    }
    if (message.shadowOffsetY !== undefined) {
      writer.uint32(141).float(message.shadowOffsetY);
    }
    if (message.outlineWidth !== undefined) {
      writer.uint32(149).float(message.outlineWidth);
    }
    if (message.shadowColor !== undefined) {
      Color3.encode(message.shadowColor, writer.uint32(154).fork()).ldelim();
    }
    if (message.outlineColor !== undefined) {
      Color3.encode(message.outlineColor, writer.uint32(162).fork()).ldelim();
    }
    if (message.textColor !== undefined) {
      Color4.encode(message.textColor, writer.uint32(170).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): PBTextShape {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBTextShape();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.font = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.fontSize = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fontAutoSize = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.textAlign = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.width = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.height = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.paddingTop = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.paddingRight = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.paddingBottom = reader.float();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.paddingLeft = reader.float();
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.lineSpacing = reader.float();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.lineCount = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.textWrapping = reader.bool();
          continue;
        case 15:
          if (tag !== 125) {
            break;
          }

          message.shadowBlur = reader.float();
          continue;
        case 16:
          if (tag !== 133) {
            break;
          }

          message.shadowOffsetX = reader.float();
          continue;
        case 17:
          if (tag !== 141) {
            break;
          }

          message.shadowOffsetY = reader.float();
          continue;
        case 18:
          if (tag !== 149) {
            break;
          }

          message.outlineWidth = reader.float();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.shadowColor = Color3.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.outlineColor = Color3.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.textColor = Color4.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): PBTextShape {
    return {
      text: isSet(object.text) ? String(object.text) : "",
      font: isSet(object.font) ? fontFromJSON(object.font) : undefined,
      fontSize: isSet(object.fontSize) ? Number(object.fontSize) : undefined,
      fontAutoSize: isSet(object.fontAutoSize) ? Boolean(object.fontAutoSize) : undefined,
      textAlign: isSet(object.textAlign) ? textAlignModeFromJSON(object.textAlign) : undefined,
      width: isSet(object.width) ? Number(object.width) : undefined,
      height: isSet(object.height) ? Number(object.height) : undefined,
      paddingTop: isSet(object.paddingTop) ? Number(object.paddingTop) : undefined,
      paddingRight: isSet(object.paddingRight) ? Number(object.paddingRight) : undefined,
      paddingBottom: isSet(object.paddingBottom) ? Number(object.paddingBottom) : undefined,
      paddingLeft: isSet(object.paddingLeft) ? Number(object.paddingLeft) : undefined,
      lineSpacing: isSet(object.lineSpacing) ? Number(object.lineSpacing) : undefined,
      lineCount: isSet(object.lineCount) ? Number(object.lineCount) : undefined,
      textWrapping: isSet(object.textWrapping) ? Boolean(object.textWrapping) : undefined,
      shadowBlur: isSet(object.shadowBlur) ? Number(object.shadowBlur) : undefined,
      shadowOffsetX: isSet(object.shadowOffsetX) ? Number(object.shadowOffsetX) : undefined,
      shadowOffsetY: isSet(object.shadowOffsetY) ? Number(object.shadowOffsetY) : undefined,
      outlineWidth: isSet(object.outlineWidth) ? Number(object.outlineWidth) : undefined,
      shadowColor: isSet(object.shadowColor) ? Color3.fromJSON(object.shadowColor) : undefined,
      outlineColor: isSet(object.outlineColor) ? Color3.fromJSON(object.outlineColor) : undefined,
      textColor: isSet(object.textColor) ? Color4.fromJSON(object.textColor) : undefined,
    };
  }

  export function toJSON(message: PBTextShape): unknown {
    const obj: any = {};
    message.text !== undefined && (obj.text = message.text);
    message.font !== undefined && (obj.font = message.font !== undefined ? fontToJSON(message.font) : undefined);
    message.fontSize !== undefined && (obj.fontSize = message.fontSize);
    message.fontAutoSize !== undefined && (obj.fontAutoSize = message.fontAutoSize);
    message.textAlign !== undefined &&
      (obj.textAlign = message.textAlign !== undefined ? textAlignModeToJSON(message.textAlign) : undefined);
    message.width !== undefined && (obj.width = message.width);
    message.height !== undefined && (obj.height = message.height);
    message.paddingTop !== undefined && (obj.paddingTop = message.paddingTop);
    message.paddingRight !== undefined && (obj.paddingRight = message.paddingRight);
    message.paddingBottom !== undefined && (obj.paddingBottom = message.paddingBottom);
    message.paddingLeft !== undefined && (obj.paddingLeft = message.paddingLeft);
    message.lineSpacing !== undefined && (obj.lineSpacing = message.lineSpacing);
    message.lineCount !== undefined && (obj.lineCount = Math.round(message.lineCount));
    message.textWrapping !== undefined && (obj.textWrapping = message.textWrapping);
    message.shadowBlur !== undefined && (obj.shadowBlur = message.shadowBlur);
    message.shadowOffsetX !== undefined && (obj.shadowOffsetX = message.shadowOffsetX);
    message.shadowOffsetY !== undefined && (obj.shadowOffsetY = message.shadowOffsetY);
    message.outlineWidth !== undefined && (obj.outlineWidth = message.outlineWidth);
    message.shadowColor !== undefined &&
      (obj.shadowColor = message.shadowColor ? Color3.toJSON(message.shadowColor) : undefined);
    message.outlineColor !== undefined &&
      (obj.outlineColor = message.outlineColor ? Color3.toJSON(message.outlineColor) : undefined);
    message.textColor !== undefined &&
      (obj.textColor = message.textColor ? Color4.toJSON(message.textColor) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<PBTextShape>, I>>(base?: I): PBTextShape {
    return PBTextShape.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<PBTextShape>, I>>(object: I): PBTextShape {
    const message = createBasePBTextShape();
    message.text = object.text ?? "";
    message.font = object.font ?? undefined;
    message.fontSize = object.fontSize ?? undefined;
    message.fontAutoSize = object.fontAutoSize ?? undefined;
    message.textAlign = object.textAlign ?? undefined;
    message.width = object.width ?? undefined;
    message.height = object.height ?? undefined;
    message.paddingTop = object.paddingTop ?? undefined;
    message.paddingRight = object.paddingRight ?? undefined;
    message.paddingBottom = object.paddingBottom ?? undefined;
    message.paddingLeft = object.paddingLeft ?? undefined;
    message.lineSpacing = object.lineSpacing ?? undefined;
    message.lineCount = object.lineCount ?? undefined;
    message.textWrapping = object.textWrapping ?? undefined;
    message.shadowBlur = object.shadowBlur ?? undefined;
    message.shadowOffsetX = object.shadowOffsetX ?? undefined;
    message.shadowOffsetY = object.shadowOffsetY ?? undefined;
    message.outlineWidth = object.outlineWidth ?? undefined;
    message.shadowColor = (object.shadowColor !== undefined && object.shadowColor !== null)
      ? Color3.fromPartial(object.shadowColor)
      : undefined;
    message.outlineColor = (object.outlineColor !== undefined && object.outlineColor !== null)
      ? Color3.fromPartial(object.outlineColor)
      : undefined;
    message.textColor = (object.textColor !== undefined && object.textColor !== null)
      ? Color4.fromPartial(object.textColor)
      : undefined;
    return message;
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
