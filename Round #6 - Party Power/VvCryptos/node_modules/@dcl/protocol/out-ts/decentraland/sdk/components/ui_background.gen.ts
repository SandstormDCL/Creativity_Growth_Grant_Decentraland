/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { BorderRect } from "../../common/border_rect.gen";
import { Color4 } from "../../common/colors.gen";
import { TextureUnion } from "../../common/texture.gen";

export const protobufPackage = "decentraland.sdk.components";

export enum BackgroundTextureMode {
  /**
   * NINE_SLICES - https://docs.unity3d.com/Manual/UIE-USS-SupportedProperties.html (Slicing section)
   * https://forum.unity.com/threads/how-does-slicing-in-ui-tookkit-works.1235863/
   * https://docs.unity3d.com/Manual/9SliceSprites.html
   * https://developer.mozilla.org/en-US/docs/Web/CSS/border-image-slice
   */
  NINE_SLICES = 0,
  /**
   * CENTER - CENTER enables the texture to be rendered centered in relation to the
   * element. If the element is smaller than the texture then the background
   * should use the element as stencil to cut off the out-of-bounds area
   */
  CENTER = 1,
  /**
   * STRETCH - STRETCH enables the texture to cover all the area of the container,
   * adopting its aspect ratio.
   */
  STRETCH = 2,
  UNRECOGNIZED = -1,
}

export function backgroundTextureModeFromJSON(object: any): BackgroundTextureMode {
  switch (object) {
    case 0:
    case "NINE_SLICES":
      return BackgroundTextureMode.NINE_SLICES;
    case 1:
    case "CENTER":
      return BackgroundTextureMode.CENTER;
    case 2:
    case "STRETCH":
      return BackgroundTextureMode.STRETCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackgroundTextureMode.UNRECOGNIZED;
  }
}

export function backgroundTextureModeToJSON(object: BackgroundTextureMode): string {
  switch (object) {
    case BackgroundTextureMode.NINE_SLICES:
      return "NINE_SLICES";
    case BackgroundTextureMode.CENTER:
      return "CENTER";
    case BackgroundTextureMode.STRETCH:
      return "STRETCH";
    case BackgroundTextureMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PBUiBackground {
  /** default=(1.0, 1.0, 1.0, 1.0), pixel = color * sample2D(texture, uv) */
  color?: Color4 | undefined;
  texture?: TextureUnion | undefined;
  textureMode: BackgroundTextureMode;
  /** default=(1/3, 1/3, 1/3, 1/3) */
  textureSlices?:
    | BorderRect
    | undefined;
  /** default=[0,0,0,1,1,0,1,0]: starting from bottom-left vertex clock-wise */
  uvs: number[];
}

function createBasePBUiBackground(): PBUiBackground {
  return { color: undefined, texture: undefined, textureMode: 0, textureSlices: undefined, uvs: [] };
}

export namespace PBUiBackground {
  export function encode(message: PBUiBackground, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.color !== undefined) {
      Color4.encode(message.color, writer.uint32(10).fork()).ldelim();
    }
    if (message.texture !== undefined) {
      TextureUnion.encode(message.texture, writer.uint32(18).fork()).ldelim();
    }
    if (message.textureMode !== 0) {
      writer.uint32(24).int32(message.textureMode);
    }
    if (message.textureSlices !== undefined) {
      BorderRect.encode(message.textureSlices, writer.uint32(34).fork()).ldelim();
    }
    writer.uint32(42).fork();
    for (const v of message.uvs) {
      writer.float(v);
    }
    writer.ldelim();
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): PBUiBackground {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBUiBackground();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.color = Color4.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.texture = TextureUnion.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.textureMode = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.textureSlices = BorderRect.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag === 45) {
            message.uvs.push(reader.float());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.uvs.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): PBUiBackground {
    return {
      color: isSet(object.color) ? Color4.fromJSON(object.color) : undefined,
      texture: isSet(object.texture) ? TextureUnion.fromJSON(object.texture) : undefined,
      textureMode: isSet(object.textureMode) ? backgroundTextureModeFromJSON(object.textureMode) : 0,
      textureSlices: isSet(object.textureSlices) ? BorderRect.fromJSON(object.textureSlices) : undefined,
      uvs: Array.isArray(object?.uvs) ? object.uvs.map((e: any) => Number(e)) : [],
    };
  }

  export function toJSON(message: PBUiBackground): unknown {
    const obj: any = {};
    message.color !== undefined && (obj.color = message.color ? Color4.toJSON(message.color) : undefined);
    message.texture !== undefined && (obj.texture = message.texture ? TextureUnion.toJSON(message.texture) : undefined);
    message.textureMode !== undefined && (obj.textureMode = backgroundTextureModeToJSON(message.textureMode));
    message.textureSlices !== undefined &&
      (obj.textureSlices = message.textureSlices ? BorderRect.toJSON(message.textureSlices) : undefined);
    if (message.uvs) {
      obj.uvs = message.uvs.map((e) => e);
    } else {
      obj.uvs = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<PBUiBackground>, I>>(base?: I): PBUiBackground {
    return PBUiBackground.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<PBUiBackground>, I>>(object: I): PBUiBackground {
    const message = createBasePBUiBackground();
    message.color = (object.color !== undefined && object.color !== null)
      ? Color4.fromPartial(object.color)
      : undefined;
    message.texture = (object.texture !== undefined && object.texture !== null)
      ? TextureUnion.fromPartial(object.texture)
      : undefined;
    message.textureMode = object.textureMode ?? 0;
    message.textureSlices = (object.textureSlices !== undefined && object.textureSlices !== null)
      ? BorderRect.fromPartial(object.textureSlices)
      : undefined;
    message.uvs = object.uvs?.map((e) => e) || [];
    return message;
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
