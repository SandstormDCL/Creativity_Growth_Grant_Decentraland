/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "decentraland.kernel.apis";

export interface KillRequest {
  pid: string;
}

export interface KillResponse {
  status: boolean;
}

export interface SpawnRequest {
  pid?: string | undefined;
  ens?: string | undefined;
}

export interface SpawnResponse {
  pid: string;
  parentCid: string;
  name: string;
  ens?: string | undefined;
}

export interface PxRequest {
  pid: string;
}

export interface GetPortableExperiencesLoadedRequest {
}

export interface GetPortableExperiencesLoadedResponse {
  loaded: SpawnResponse[];
}

export interface ExitRequest {
}

export interface ExitResponse {
  status: boolean;
}

function createBaseKillRequest(): KillRequest {
  return { pid: "" };
}

export namespace KillRequest {
  export function encode(message: KillRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== "") {
      writer.uint32(10).string(message.pid);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): KillRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKillRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): KillRequest {
    return { pid: isSet(object.pid) ? String(object.pid) : "" };
  }

  export function toJSON(message: KillRequest): unknown {
    const obj: any = {};
    message.pid !== undefined && (obj.pid = message.pid);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<KillRequest>, I>>(base?: I): KillRequest {
    return KillRequest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<KillRequest>, I>>(object: I): KillRequest {
    const message = createBaseKillRequest();
    message.pid = object.pid ?? "";
    return message;
  }
}

function createBaseKillResponse(): KillResponse {
  return { status: false };
}

export namespace KillResponse {
  export function encode(message: KillResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status === true) {
      writer.uint32(8).bool(message.status);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): KillResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKillResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): KillResponse {
    return { status: isSet(object.status) ? Boolean(object.status) : false };
  }

  export function toJSON(message: KillResponse): unknown {
    const obj: any = {};
    message.status !== undefined && (obj.status = message.status);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<KillResponse>, I>>(base?: I): KillResponse {
    return KillResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<KillResponse>, I>>(object: I): KillResponse {
    const message = createBaseKillResponse();
    message.status = object.status ?? false;
    return message;
  }
}

function createBaseSpawnRequest(): SpawnRequest {
  return { pid: undefined, ens: undefined };
}

export namespace SpawnRequest {
  export function encode(message: SpawnRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== undefined) {
      writer.uint32(10).string(message.pid);
    }
    if (message.ens !== undefined) {
      writer.uint32(18).string(message.ens);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): SpawnRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpawnRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ens = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): SpawnRequest {
    return {
      pid: isSet(object.pid) ? String(object.pid) : undefined,
      ens: isSet(object.ens) ? String(object.ens) : undefined,
    };
  }

  export function toJSON(message: SpawnRequest): unknown {
    const obj: any = {};
    message.pid !== undefined && (obj.pid = message.pid);
    message.ens !== undefined && (obj.ens = message.ens);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<SpawnRequest>, I>>(base?: I): SpawnRequest {
    return SpawnRequest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<SpawnRequest>, I>>(object: I): SpawnRequest {
    const message = createBaseSpawnRequest();
    message.pid = object.pid ?? undefined;
    message.ens = object.ens ?? undefined;
    return message;
  }
}

function createBaseSpawnResponse(): SpawnResponse {
  return { pid: "", parentCid: "", name: "", ens: undefined };
}

export namespace SpawnResponse {
  export function encode(message: SpawnResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== "") {
      writer.uint32(10).string(message.pid);
    }
    if (message.parentCid !== "") {
      writer.uint32(18).string(message.parentCid);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.ens !== undefined) {
      writer.uint32(34).string(message.ens);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): SpawnResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpawnResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parentCid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ens = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): SpawnResponse {
    return {
      pid: isSet(object.pid) ? String(object.pid) : "",
      parentCid: isSet(object.parentCid) ? String(object.parentCid) : "",
      name: isSet(object.name) ? String(object.name) : "",
      ens: isSet(object.ens) ? String(object.ens) : undefined,
    };
  }

  export function toJSON(message: SpawnResponse): unknown {
    const obj: any = {};
    message.pid !== undefined && (obj.pid = message.pid);
    message.parentCid !== undefined && (obj.parentCid = message.parentCid);
    message.name !== undefined && (obj.name = message.name);
    message.ens !== undefined && (obj.ens = message.ens);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<SpawnResponse>, I>>(base?: I): SpawnResponse {
    return SpawnResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<SpawnResponse>, I>>(object: I): SpawnResponse {
    const message = createBaseSpawnResponse();
    message.pid = object.pid ?? "";
    message.parentCid = object.parentCid ?? "";
    message.name = object.name ?? "";
    message.ens = object.ens ?? undefined;
    return message;
  }
}

function createBasePxRequest(): PxRequest {
  return { pid: "" };
}

export namespace PxRequest {
  export function encode(message: PxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pid !== "") {
      writer.uint32(10).string(message.pid);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): PxRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): PxRequest {
    return { pid: isSet(object.pid) ? String(object.pid) : "" };
  }

  export function toJSON(message: PxRequest): unknown {
    const obj: any = {};
    message.pid !== undefined && (obj.pid = message.pid);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<PxRequest>, I>>(base?: I): PxRequest {
    return PxRequest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<PxRequest>, I>>(object: I): PxRequest {
    const message = createBasePxRequest();
    message.pid = object.pid ?? "";
    return message;
  }
}

function createBaseGetPortableExperiencesLoadedRequest(): GetPortableExperiencesLoadedRequest {
  return {};
}

export namespace GetPortableExperiencesLoadedRequest {
  export function encode(_: GetPortableExperiencesLoadedRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): GetPortableExperiencesLoadedRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortableExperiencesLoadedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): GetPortableExperiencesLoadedRequest {
    return {};
  }

  export function toJSON(_: GetPortableExperiencesLoadedRequest): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<GetPortableExperiencesLoadedRequest>, I>>(
    base?: I,
  ): GetPortableExperiencesLoadedRequest {
    return GetPortableExperiencesLoadedRequest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<GetPortableExperiencesLoadedRequest>, I>>(
    _: I,
  ): GetPortableExperiencesLoadedRequest {
    const message = createBaseGetPortableExperiencesLoadedRequest();
    return message;
  }
}

function createBaseGetPortableExperiencesLoadedResponse(): GetPortableExperiencesLoadedResponse {
  return { loaded: [] };
}

export namespace GetPortableExperiencesLoadedResponse {
  export function encode(
    message: GetPortableExperiencesLoadedResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.loaded) {
      SpawnResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): GetPortableExperiencesLoadedResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortableExperiencesLoadedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.loaded.push(SpawnResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): GetPortableExperiencesLoadedResponse {
    return { loaded: Array.isArray(object?.loaded) ? object.loaded.map((e: any) => SpawnResponse.fromJSON(e)) : [] };
  }

  export function toJSON(message: GetPortableExperiencesLoadedResponse): unknown {
    const obj: any = {};
    if (message.loaded) {
      obj.loaded = message.loaded.map((e) => e ? SpawnResponse.toJSON(e) : undefined);
    } else {
      obj.loaded = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<GetPortableExperiencesLoadedResponse>, I>>(
    base?: I,
  ): GetPortableExperiencesLoadedResponse {
    return GetPortableExperiencesLoadedResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<GetPortableExperiencesLoadedResponse>, I>>(
    object: I,
  ): GetPortableExperiencesLoadedResponse {
    const message = createBaseGetPortableExperiencesLoadedResponse();
    message.loaded = object.loaded?.map((e) => SpawnResponse.fromPartial(e)) || [];
    return message;
  }
}

function createBaseExitRequest(): ExitRequest {
  return {};
}

export namespace ExitRequest {
  export function encode(_: ExitRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): ExitRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): ExitRequest {
    return {};
  }

  export function toJSON(_: ExitRequest): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<ExitRequest>, I>>(base?: I): ExitRequest {
    return ExitRequest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<ExitRequest>, I>>(_: I): ExitRequest {
    const message = createBaseExitRequest();
    return message;
  }
}

function createBaseExitResponse(): ExitResponse {
  return { status: false };
}

export namespace ExitResponse {
  export function encode(message: ExitResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status === true) {
      writer.uint32(8).bool(message.status);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): ExitResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): ExitResponse {
    return { status: isSet(object.status) ? Boolean(object.status) : false };
  }

  export function toJSON(message: ExitResponse): unknown {
    const obj: any = {};
    message.status !== undefined && (obj.status = message.status);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<ExitResponse>, I>>(base?: I): ExitResponse {
    return ExitResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<ExitResponse>, I>>(object: I): ExitResponse {
    const message = createBaseExitResponse();
    message.status = object.status ?? false;
    return message;
  }
}

export type PortableExperiencesServiceDefinition = typeof PortableExperiencesServiceDefinition;
export const PortableExperiencesServiceDefinition = {
  name: "PortableExperiencesService",
  fullName: "decentraland.kernel.apis.PortableExperiencesService",
  methods: {
    /**
     * Spawns a new portable experience that is detached from the current scene.
     * Spawned portable experiences can only be controlled by 1) the user (from the UI)
     * and 2) from the parent scene. If the parent scene gets unloaded i.e. by distance,
     * once the player re-loads the parent it will inherit the children portable experiences
     * to gain control over them.
     */
    spawn: {
      name: "Spawn",
      requestType: SpawnRequest,
      requestStream: false,
      responseType: SpawnResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Kill a child portable experience, this method only works if the child was
     * spawned by the same process trying to kill it.
     */
    kill: {
      name: "Kill",
      requestType: KillRequest,
      requestStream: false,
      responseType: KillResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Kill the current scene if the current scene is a portable experience. Other
     * kind of scenes are not allowed to finish their programs like portable experiences.
     */
    exit: {
      name: "Exit",
      requestType: ExitRequest,
      requestStream: false,
      responseType: ExitResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Gets a list of running portable experiences for the current user. Be mindful
     * about the performance penalty of calling this function all frames.
     */
    getPortableExperiencesLoaded: {
      name: "GetPortableExperiencesLoaded",
      requestType: GetPortableExperiencesLoadedRequest,
      requestStream: false,
      responseType: GetPortableExperiencesLoadedResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
