/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Vector2, Vector3 } from "../../common/vectors.gen";

export const protobufPackage = "decentraland.kernel.apis";

export interface TakeAndCompareScreenshotRequest {
  /**
   * the source path in the scene where the screenshot is stored,
   *  the snapshot taken is compared with the stored one
   */
  srcStoredSnapshot: string;
  /** the camera position where is set before and while taking the screenshot, relative to base scene */
  cameraPosition:
    | Vector3
    | undefined;
  /** the camera position where is target to before and while taking the screenshot, relative to base scene */
  cameraTarget:
    | Vector3
    | undefined;
  /** width x height screenshot size */
  screenshotSize: Vector2 | undefined;
  comparisonMethod?: {
    $case: "greyPixelDiff";
    greyPixelDiff: TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff;
  } | undefined;
  snapshotMode: TakeAndCompareScreenshotRequest_SnapshotMode;
}

export enum TakeAndCompareScreenshotRequest_SnapshotMode {
  /** SM_3D_AND_UI - only visible 3d scene and ui scene */
  SM_3D_AND_UI = 0,
  /** SM_3D_ONLY - only visible 3d scene */
  SM_3D_ONLY = 1,
  /** SM_UI_ONLY - only visible ui scene */
  SM_UI_ONLY = 2,
  UNRECOGNIZED = -1,
}

export function takeAndCompareScreenshotRequest_SnapshotModeFromJSON(
  object: any,
): TakeAndCompareScreenshotRequest_SnapshotMode {
  switch (object) {
    case 0:
    case "SM_3D_AND_UI":
      return TakeAndCompareScreenshotRequest_SnapshotMode.SM_3D_AND_UI;
    case 1:
    case "SM_3D_ONLY":
      return TakeAndCompareScreenshotRequest_SnapshotMode.SM_3D_ONLY;
    case 2:
    case "SM_UI_ONLY":
      return TakeAndCompareScreenshotRequest_SnapshotMode.SM_UI_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TakeAndCompareScreenshotRequest_SnapshotMode.UNRECOGNIZED;
  }
}

export function takeAndCompareScreenshotRequest_SnapshotModeToJSON(
  object: TakeAndCompareScreenshotRequest_SnapshotMode,
): string {
  switch (object) {
    case TakeAndCompareScreenshotRequest_SnapshotMode.SM_3D_AND_UI:
      return "SM_3D_AND_UI";
    case TakeAndCompareScreenshotRequest_SnapshotMode.SM_3D_ONLY:
      return "SM_3D_ONLY";
    case TakeAndCompareScreenshotRequest_SnapshotMode.SM_UI_ONLY:
      return "SM_UI_ONLY";
    case TakeAndCompareScreenshotRequest_SnapshotMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff {
}

export interface TakeAndCompareScreenshotResponse {
  storedSnapshotFound: boolean;
  comparisonMethodResult?: {
    $case: "greyPixelDiff";
    greyPixelDiff: TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult;
  } | undefined;
}

export interface TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult {
  similarity: number;
}

export interface TestResult {
  name: string;
  ok: boolean;
  error?: string | undefined;
  stack?:
    | string
    | undefined;
  /** how many ADR-148 ticks were spent running this test */
  totalFrames: number;
  /** total time in seconds spent running this test */
  totalTime: number;
}

export interface TestResultResponse {
}

export interface TestPlan {
  tests: TestPlan_TestPlanEntry[];
}

export interface TestPlan_TestPlanEntry {
  name: string;
}

export interface TestPlanResponse {
}

export interface SetCameraTransformTestCommand {
  position: SetCameraTransformTestCommand_Vector3 | undefined;
  rotation: SetCameraTransformTestCommand_Quaternion | undefined;
}

export interface SetCameraTransformTestCommand_Vector3 {
  x: number;
  y: number;
  z: number;
}

export interface SetCameraTransformTestCommand_Quaternion {
  x: number;
  y: number;
  z: number;
  w: number;
}

export interface SetCameraTransformTestCommandResponse {
}

function createBaseTakeAndCompareScreenshotRequest(): TakeAndCompareScreenshotRequest {
  return {
    srcStoredSnapshot: "",
    cameraPosition: undefined,
    cameraTarget: undefined,
    screenshotSize: undefined,
    comparisonMethod: undefined,
    snapshotMode: 0,
  };
}

export namespace TakeAndCompareScreenshotRequest {
  export function encode(
    message: TakeAndCompareScreenshotRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.srcStoredSnapshot !== "") {
      writer.uint32(10).string(message.srcStoredSnapshot);
    }
    if (message.cameraPosition !== undefined) {
      Vector3.encode(message.cameraPosition, writer.uint32(18).fork()).ldelim();
    }
    if (message.cameraTarget !== undefined) {
      Vector3.encode(message.cameraTarget, writer.uint32(26).fork()).ldelim();
    }
    if (message.screenshotSize !== undefined) {
      Vector2.encode(message.screenshotSize, writer.uint32(34).fork()).ldelim();
    }
    switch (message.comparisonMethod?.$case) {
      case "greyPixelDiff":
        TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff.encode(
          message.comparisonMethod.greyPixelDiff,
          writer.uint32(42).fork(),
        ).ldelim();
        break;
    }
    if (message.snapshotMode !== 0) {
      writer.uint32(48).int32(message.snapshotMode);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TakeAndCompareScreenshotRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeAndCompareScreenshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.srcStoredSnapshot = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cameraPosition = Vector3.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cameraTarget = Vector3.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.screenshotSize = Vector2.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comparisonMethod = {
            $case: "greyPixelDiff",
            greyPixelDiff: TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.snapshotMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): TakeAndCompareScreenshotRequest {
    return {
      srcStoredSnapshot: isSet(object.srcStoredSnapshot) ? String(object.srcStoredSnapshot) : "",
      cameraPosition: isSet(object.cameraPosition) ? Vector3.fromJSON(object.cameraPosition) : undefined,
      cameraTarget: isSet(object.cameraTarget) ? Vector3.fromJSON(object.cameraTarget) : undefined,
      screenshotSize: isSet(object.screenshotSize) ? Vector2.fromJSON(object.screenshotSize) : undefined,
      comparisonMethod: isSet(object.greyPixelDiff)
        ? {
          $case: "greyPixelDiff",
          greyPixelDiff: TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff.fromJSON(object.greyPixelDiff),
        }
        : undefined,
      snapshotMode: isSet(object.snapshotMode)
        ? takeAndCompareScreenshotRequest_SnapshotModeFromJSON(object.snapshotMode)
        : 0,
    };
  }

  export function toJSON(message: TakeAndCompareScreenshotRequest): unknown {
    const obj: any = {};
    message.srcStoredSnapshot !== undefined && (obj.srcStoredSnapshot = message.srcStoredSnapshot);
    message.cameraPosition !== undefined &&
      (obj.cameraPosition = message.cameraPosition ? Vector3.toJSON(message.cameraPosition) : undefined);
    message.cameraTarget !== undefined &&
      (obj.cameraTarget = message.cameraTarget ? Vector3.toJSON(message.cameraTarget) : undefined);
    message.screenshotSize !== undefined &&
      (obj.screenshotSize = message.screenshotSize ? Vector2.toJSON(message.screenshotSize) : undefined);
    message.comparisonMethod?.$case === "greyPixelDiff" &&
      (obj.greyPixelDiff = message.comparisonMethod?.greyPixelDiff
        ? TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff.toJSON(message.comparisonMethod?.greyPixelDiff)
        : undefined);
    message.snapshotMode !== undefined &&
      (obj.snapshotMode = takeAndCompareScreenshotRequest_SnapshotModeToJSON(message.snapshotMode));
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TakeAndCompareScreenshotRequest>, I>>(
    base?: I,
  ): TakeAndCompareScreenshotRequest {
    return TakeAndCompareScreenshotRequest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TakeAndCompareScreenshotRequest>, I>>(
    object: I,
  ): TakeAndCompareScreenshotRequest {
    const message = createBaseTakeAndCompareScreenshotRequest();
    message.srcStoredSnapshot = object.srcStoredSnapshot ?? "";
    message.cameraPosition = (object.cameraPosition !== undefined && object.cameraPosition !== null)
      ? Vector3.fromPartial(object.cameraPosition)
      : undefined;
    message.cameraTarget = (object.cameraTarget !== undefined && object.cameraTarget !== null)
      ? Vector3.fromPartial(object.cameraTarget)
      : undefined;
    message.screenshotSize = (object.screenshotSize !== undefined && object.screenshotSize !== null)
      ? Vector2.fromPartial(object.screenshotSize)
      : undefined;
    if (
      object.comparisonMethod?.$case === "greyPixelDiff" &&
      object.comparisonMethod?.greyPixelDiff !== undefined &&
      object.comparisonMethod?.greyPixelDiff !== null
    ) {
      message.comparisonMethod = {
        $case: "greyPixelDiff",
        greyPixelDiff: TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff.fromPartial(
          object.comparisonMethod.greyPixelDiff,
        ),
      };
    }
    message.snapshotMode = object.snapshotMode ?? 0;
    return message;
  }
}

function createBaseTakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff(): TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff {
  return {};
}

export namespace TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff {
  export function encode(
    _: TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  }

  export function decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff {
    return {};
  }

  export function toJSON(_: TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<
    I extends Exact<DeepPartial<TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff>, I>,
  >(base?: I): TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff {
    return TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff.fromPartial(base ?? {});
  }

  export function fromPartial<
    I extends Exact<DeepPartial<TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff>, I>,
  >(_: I): TakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff {
    const message = createBaseTakeAndCompareScreenshotRequest_ComparisonMethodGreyPixelDiff();
    return message;
  }
}

function createBaseTakeAndCompareScreenshotResponse(): TakeAndCompareScreenshotResponse {
  return { storedSnapshotFound: false, comparisonMethodResult: undefined };
}

export namespace TakeAndCompareScreenshotResponse {
  export function encode(
    message: TakeAndCompareScreenshotResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.storedSnapshotFound === true) {
      writer.uint32(8).bool(message.storedSnapshotFound);
    }
    switch (message.comparisonMethodResult?.$case) {
      case "greyPixelDiff":
        TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult.encode(
          message.comparisonMethodResult.greyPixelDiff,
          writer.uint32(18).fork(),
        ).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TakeAndCompareScreenshotResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeAndCompareScreenshotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.storedSnapshotFound = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comparisonMethodResult = {
            $case: "greyPixelDiff",
            greyPixelDiff: TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): TakeAndCompareScreenshotResponse {
    return {
      storedSnapshotFound: isSet(object.storedSnapshotFound) ? Boolean(object.storedSnapshotFound) : false,
      comparisonMethodResult: isSet(object.greyPixelDiff)
        ? {
          $case: "greyPixelDiff",
          greyPixelDiff: TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult.fromJSON(
            object.greyPixelDiff,
          ),
        }
        : undefined,
    };
  }

  export function toJSON(message: TakeAndCompareScreenshotResponse): unknown {
    const obj: any = {};
    message.storedSnapshotFound !== undefined && (obj.storedSnapshotFound = message.storedSnapshotFound);
    message.comparisonMethodResult?.$case === "greyPixelDiff" &&
      (obj.greyPixelDiff = message.comparisonMethodResult?.greyPixelDiff
        ? TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult.toJSON(
          message.comparisonMethodResult?.greyPixelDiff,
        )
        : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TakeAndCompareScreenshotResponse>, I>>(
    base?: I,
  ): TakeAndCompareScreenshotResponse {
    return TakeAndCompareScreenshotResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TakeAndCompareScreenshotResponse>, I>>(
    object: I,
  ): TakeAndCompareScreenshotResponse {
    const message = createBaseTakeAndCompareScreenshotResponse();
    message.storedSnapshotFound = object.storedSnapshotFound ?? false;
    if (
      object.comparisonMethodResult?.$case === "greyPixelDiff" &&
      object.comparisonMethodResult?.greyPixelDiff !== undefined &&
      object.comparisonMethodResult?.greyPixelDiff !== null
    ) {
      message.comparisonMethodResult = {
        $case: "greyPixelDiff",
        greyPixelDiff: TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult.fromPartial(
          object.comparisonMethodResult.greyPixelDiff,
        ),
      };
    }
    return message;
  }
}

function createBaseTakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult(): TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult {
  return { similarity: 0 };
}

export namespace TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult {
  export function encode(
    message: TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.similarity !== 0) {
      writer.uint32(13).float(message.similarity);
    }
    return writer;
  }

  export function decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.similarity = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult {
    return { similarity: isSet(object.similarity) ? Number(object.similarity) : 0 };
  }

  export function toJSON(message: TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult): unknown {
    const obj: any = {};
    message.similarity !== undefined && (obj.similarity = message.similarity);
    return obj;
  }

  export function create<
    I extends Exact<DeepPartial<TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult>, I>,
  >(base?: I): TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult {
    return TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult.fromPartial(base ?? {});
  }

  export function fromPartial<
    I extends Exact<DeepPartial<TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult>, I>,
  >(object: I): TakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult {
    const message = createBaseTakeAndCompareScreenshotResponse_ComparisonMethodGreyPixelDiffResult();
    message.similarity = object.similarity ?? 0;
    return message;
  }
}

function createBaseTestResult(): TestResult {
  return { name: "", ok: false, error: undefined, stack: undefined, totalFrames: 0, totalTime: 0 };
}

export namespace TestResult {
  export function encode(message: TestResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ok === true) {
      writer.uint32(16).bool(message.ok);
    }
    if (message.error !== undefined) {
      writer.uint32(26).string(message.error);
    }
    if (message.stack !== undefined) {
      writer.uint32(34).string(message.stack);
    }
    if (message.totalFrames !== 0) {
      writer.uint32(40).uint32(message.totalFrames);
    }
    if (message.totalTime !== 0) {
      writer.uint32(53).float(message.totalTime);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TestResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ok = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stack = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalFrames = reader.uint32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.totalTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): TestResult {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      ok: isSet(object.ok) ? Boolean(object.ok) : false,
      error: isSet(object.error) ? String(object.error) : undefined,
      stack: isSet(object.stack) ? String(object.stack) : undefined,
      totalFrames: isSet(object.totalFrames) ? Number(object.totalFrames) : 0,
      totalTime: isSet(object.totalTime) ? Number(object.totalTime) : 0,
    };
  }

  export function toJSON(message: TestResult): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.ok !== undefined && (obj.ok = message.ok);
    message.error !== undefined && (obj.error = message.error);
    message.stack !== undefined && (obj.stack = message.stack);
    message.totalFrames !== undefined && (obj.totalFrames = Math.round(message.totalFrames));
    message.totalTime !== undefined && (obj.totalTime = message.totalTime);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TestResult>, I>>(base?: I): TestResult {
    return TestResult.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TestResult>, I>>(object: I): TestResult {
    const message = createBaseTestResult();
    message.name = object.name ?? "";
    message.ok = object.ok ?? false;
    message.error = object.error ?? undefined;
    message.stack = object.stack ?? undefined;
    message.totalFrames = object.totalFrames ?? 0;
    message.totalTime = object.totalTime ?? 0;
    return message;
  }
}

function createBaseTestResultResponse(): TestResultResponse {
  return {};
}

export namespace TestResultResponse {
  export function encode(_: TestResultResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TestResultResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): TestResultResponse {
    return {};
  }

  export function toJSON(_: TestResultResponse): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TestResultResponse>, I>>(base?: I): TestResultResponse {
    return TestResultResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TestResultResponse>, I>>(_: I): TestResultResponse {
    const message = createBaseTestResultResponse();
    return message;
  }
}

function createBaseTestPlan(): TestPlan {
  return { tests: [] };
}

export namespace TestPlan {
  export function encode(message: TestPlan, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tests) {
      TestPlan_TestPlanEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TestPlan {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestPlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tests.push(TestPlan_TestPlanEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): TestPlan {
    return {
      tests: Array.isArray(object?.tests) ? object.tests.map((e: any) => TestPlan_TestPlanEntry.fromJSON(e)) : [],
    };
  }

  export function toJSON(message: TestPlan): unknown {
    const obj: any = {};
    if (message.tests) {
      obj.tests = message.tests.map((e) => e ? TestPlan_TestPlanEntry.toJSON(e) : undefined);
    } else {
      obj.tests = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TestPlan>, I>>(base?: I): TestPlan {
    return TestPlan.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TestPlan>, I>>(object: I): TestPlan {
    const message = createBaseTestPlan();
    message.tests = object.tests?.map((e) => TestPlan_TestPlanEntry.fromPartial(e)) || [];
    return message;
  }
}

function createBaseTestPlan_TestPlanEntry(): TestPlan_TestPlanEntry {
  return { name: "" };
}

export namespace TestPlan_TestPlanEntry {
  export function encode(message: TestPlan_TestPlanEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TestPlan_TestPlanEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestPlan_TestPlanEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): TestPlan_TestPlanEntry {
    return { name: isSet(object.name) ? String(object.name) : "" };
  }

  export function toJSON(message: TestPlan_TestPlanEntry): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TestPlan_TestPlanEntry>, I>>(base?: I): TestPlan_TestPlanEntry {
    return TestPlan_TestPlanEntry.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TestPlan_TestPlanEntry>, I>>(
    object: I,
  ): TestPlan_TestPlanEntry {
    const message = createBaseTestPlan_TestPlanEntry();
    message.name = object.name ?? "";
    return message;
  }
}

function createBaseTestPlanResponse(): TestPlanResponse {
  return {};
}

export namespace TestPlanResponse {
  export function encode(_: TestPlanResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TestPlanResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestPlanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): TestPlanResponse {
    return {};
  }

  export function toJSON(_: TestPlanResponse): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TestPlanResponse>, I>>(base?: I): TestPlanResponse {
    return TestPlanResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TestPlanResponse>, I>>(_: I): TestPlanResponse {
    const message = createBaseTestPlanResponse();
    return message;
  }
}

function createBaseSetCameraTransformTestCommand(): SetCameraTransformTestCommand {
  return { position: undefined, rotation: undefined };
}

export namespace SetCameraTransformTestCommand {
  export function encode(message: SetCameraTransformTestCommand, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      SetCameraTransformTestCommand_Vector3.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    if (message.rotation !== undefined) {
      SetCameraTransformTestCommand_Quaternion.encode(message.rotation, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): SetCameraTransformTestCommand {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCameraTransformTestCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.position = SetCameraTransformTestCommand_Vector3.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rotation = SetCameraTransformTestCommand_Quaternion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): SetCameraTransformTestCommand {
    return {
      position: isSet(object.position) ? SetCameraTransformTestCommand_Vector3.fromJSON(object.position) : undefined,
      rotation: isSet(object.rotation) ? SetCameraTransformTestCommand_Quaternion.fromJSON(object.rotation) : undefined,
    };
  }

  export function toJSON(message: SetCameraTransformTestCommand): unknown {
    const obj: any = {};
    message.position !== undefined &&
      (obj.position = message.position ? SetCameraTransformTestCommand_Vector3.toJSON(message.position) : undefined);
    message.rotation !== undefined &&
      (obj.rotation = message.rotation ? SetCameraTransformTestCommand_Quaternion.toJSON(message.rotation) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<SetCameraTransformTestCommand>, I>>(
    base?: I,
  ): SetCameraTransformTestCommand {
    return SetCameraTransformTestCommand.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<SetCameraTransformTestCommand>, I>>(
    object: I,
  ): SetCameraTransformTestCommand {
    const message = createBaseSetCameraTransformTestCommand();
    message.position = (object.position !== undefined && object.position !== null)
      ? SetCameraTransformTestCommand_Vector3.fromPartial(object.position)
      : undefined;
    message.rotation = (object.rotation !== undefined && object.rotation !== null)
      ? SetCameraTransformTestCommand_Quaternion.fromPartial(object.rotation)
      : undefined;
    return message;
  }
}

function createBaseSetCameraTransformTestCommand_Vector3(): SetCameraTransformTestCommand_Vector3 {
  return { x: 0, y: 0, z: 0 };
}

export namespace SetCameraTransformTestCommand_Vector3 {
  export function encode(
    message: SetCameraTransformTestCommand_Vector3,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): SetCameraTransformTestCommand_Vector3 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCameraTransformTestCommand_Vector3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): SetCameraTransformTestCommand_Vector3 {
    return {
      x: isSet(object.x) ? Number(object.x) : 0,
      y: isSet(object.y) ? Number(object.y) : 0,
      z: isSet(object.z) ? Number(object.z) : 0,
    };
  }

  export function toJSON(message: SetCameraTransformTestCommand_Vector3): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.z !== undefined && (obj.z = message.z);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<SetCameraTransformTestCommand_Vector3>, I>>(
    base?: I,
  ): SetCameraTransformTestCommand_Vector3 {
    return SetCameraTransformTestCommand_Vector3.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<SetCameraTransformTestCommand_Vector3>, I>>(
    object: I,
  ): SetCameraTransformTestCommand_Vector3 {
    const message = createBaseSetCameraTransformTestCommand_Vector3();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  }
}

function createBaseSetCameraTransformTestCommand_Quaternion(): SetCameraTransformTestCommand_Quaternion {
  return { x: 0, y: 0, z: 0, w: 0 };
}

export namespace SetCameraTransformTestCommand_Quaternion {
  export function encode(
    message: SetCameraTransformTestCommand_Quaternion,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    if (message.w !== 0) {
      writer.uint32(37).float(message.w);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): SetCameraTransformTestCommand_Quaternion {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCameraTransformTestCommand_Quaternion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.w = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): SetCameraTransformTestCommand_Quaternion {
    return {
      x: isSet(object.x) ? Number(object.x) : 0,
      y: isSet(object.y) ? Number(object.y) : 0,
      z: isSet(object.z) ? Number(object.z) : 0,
      w: isSet(object.w) ? Number(object.w) : 0,
    };
  }

  export function toJSON(message: SetCameraTransformTestCommand_Quaternion): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = message.x);
    message.y !== undefined && (obj.y = message.y);
    message.z !== undefined && (obj.z = message.z);
    message.w !== undefined && (obj.w = message.w);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<SetCameraTransformTestCommand_Quaternion>, I>>(
    base?: I,
  ): SetCameraTransformTestCommand_Quaternion {
    return SetCameraTransformTestCommand_Quaternion.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<SetCameraTransformTestCommand_Quaternion>, I>>(
    object: I,
  ): SetCameraTransformTestCommand_Quaternion {
    const message = createBaseSetCameraTransformTestCommand_Quaternion();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.w = object.w ?? 0;
    return message;
  }
}

function createBaseSetCameraTransformTestCommandResponse(): SetCameraTransformTestCommandResponse {
  return {};
}

export namespace SetCameraTransformTestCommandResponse {
  export function encode(
    _: SetCameraTransformTestCommandResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): SetCameraTransformTestCommandResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCameraTransformTestCommandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): SetCameraTransformTestCommandResponse {
    return {};
  }

  export function toJSON(_: SetCameraTransformTestCommandResponse): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<SetCameraTransformTestCommandResponse>, I>>(
    base?: I,
  ): SetCameraTransformTestCommandResponse {
    return SetCameraTransformTestCommandResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<SetCameraTransformTestCommandResponse>, I>>(
    _: I,
  ): SetCameraTransformTestCommandResponse {
    const message = createBaseSetCameraTransformTestCommandResponse();
    return message;
  }
}

export type TestingServiceDefinition = typeof TestingServiceDefinition;
export const TestingServiceDefinition = {
  name: "TestingService",
  fullName: "decentraland.kernel.apis.TestingService",
  methods: {
    /** sends a test result to the test runner */
    logTestResult: {
      name: "LogTestResult",
      requestType: TestResult,
      requestStream: false,
      responseType: TestResultResponse,
      responseStream: false,
      options: {},
    },
    /** send a list of all planned tests to the test runner */
    plan: {
      name: "Plan",
      requestType: TestPlan,
      requestStream: false,
      responseType: TestPlanResponse,
      responseStream: false,
      options: {},
    },
    /** sets the camera position and rotation in the engine */
    setCameraTransform: {
      name: "SetCameraTransform",
      requestType: SetCameraTransformTestCommand,
      requestStream: false,
      responseType: SetCameraTransformTestCommandResponse,
      responseStream: false,
      options: {},
    },
    /**
     * @internal
     * take a screenshot and compare it with a stored one
     *  it hides the explorer hud and ui, primary player and players of avatar scenes
     */
    takeAndCompareScreenshot: {
      name: "TakeAndCompareScreenshot",
      requestType: TakeAndCompareScreenshotRequest,
      requestStream: false,
      responseType: TakeAndCompareScreenshotResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
