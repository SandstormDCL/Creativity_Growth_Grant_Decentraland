/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "decentraland.social.friendships";

/** This message is a response that is sent from the server to the client */
export interface FriendshipEventResponse {
  body?:
    | { $case: "request"; request: RequestResponse }
    | { $case: "accept"; accept: AcceptResponse }
    | { $case: "reject"; reject: RejectResponse }
    | { $case: "delete"; delete: DeleteResponse }
    | { $case: "cancel"; cancel: CancelResponse }
    | undefined;
}

export interface FriendshipEventResponses {
  responses: FriendshipEventResponse[];
}

export interface FriendshipEventPayload {
  body?:
    | { $case: "request"; request: RequestPayload }
    | { $case: "accept"; accept: AcceptPayload }
    | { $case: "reject"; reject: RejectPayload }
    | { $case: "delete"; delete: DeletePayload }
    | { $case: "cancel"; cancel: CancelPayload }
    | undefined;
}

export interface User {
  address: string;
}

export interface Users {
  users: User[];
}

export interface RequestResponse {
  user: User | undefined;
  createdAt: number;
  message?: string | undefined;
}

export interface RequestPayload {
  user: User | undefined;
  message?: string | undefined;
}

export interface Requests {
  /** Total amount of friendship requests */
  total: number;
  items: RequestResponse[];
}

export interface RequestEvents {
  /** Requests the authed user have sent to users */
  outgoing:
    | Requests
    | undefined;
  /** Requests the authed user have received from users */
  incoming: Requests | undefined;
}

export interface AcceptResponse {
  user: User | undefined;
}

export interface AcceptPayload {
  user: User | undefined;
}

export interface RejectResponse {
  user: User | undefined;
}

export interface RejectPayload {
  user: User | undefined;
}

export interface DeleteResponse {
  user: User | undefined;
}

export interface DeletePayload {
  user: User | undefined;
}

export interface CancelResponse {
  user: User | undefined;
}

export interface CancelPayload {
  user: User | undefined;
}

export interface UpdateFriendshipPayload {
  event:
    | FriendshipEventPayload
    | undefined;
  /** For internal use only, subject to change. */
  authToken?: Payload | undefined;
}

export interface MutualFriendsPayload {
  user:
    | User
    | undefined;
  /** For internal use only, subject to change. */
  authToken?: Payload | undefined;
}

export interface Payload {
  /** For internal use only, subject to change. */
  synapseToken?: string | undefined;
}

export interface BadRequestError {
  message: string;
}

export interface UnauthorizedError {
  message: string;
}

export interface ForbiddenError {
  message: string;
}

export interface TooManyRequestsError {
  message: string;
}

export interface InternalServerError {
  message: string;
}

export interface UsersResponse {
  response?:
    | { $case: "users"; users: Users }
    | { $case: "internalServerError"; internalServerError: InternalServerError }
    | { $case: "unauthorizedError"; unauthorizedError: UnauthorizedError }
    | { $case: "forbiddenError"; forbiddenError: ForbiddenError }
    | { $case: "tooManyRequestsError"; tooManyRequestsError: TooManyRequestsError }
    | { $case: "badRequestError"; badRequestError: BadRequestError }
    | undefined;
}

export interface RequestEventsResponse {
  response?:
    | { $case: "events"; events: RequestEvents }
    | { $case: "internalServerError"; internalServerError: InternalServerError }
    | { $case: "unauthorizedError"; unauthorizedError: UnauthorizedError }
    | { $case: "forbiddenError"; forbiddenError: ForbiddenError }
    | { $case: "tooManyRequestsError"; tooManyRequestsError: TooManyRequestsError }
    | undefined;
}

export interface UpdateFriendshipResponse {
  response?:
    | { $case: "event"; event: FriendshipEventResponse }
    | { $case: "internalServerError"; internalServerError: InternalServerError }
    | { $case: "unauthorizedError"; unauthorizedError: UnauthorizedError }
    | { $case: "forbiddenError"; forbiddenError: ForbiddenError }
    | { $case: "tooManyRequestsError"; tooManyRequestsError: TooManyRequestsError }
    | { $case: "badRequestError"; badRequestError: BadRequestError }
    | undefined;
}

export interface SubscribeFriendshipEventsUpdatesResponse {
  response?:
    | { $case: "events"; events: FriendshipEventResponses }
    | { $case: "internalServerError"; internalServerError: InternalServerError }
    | { $case: "unauthorizedError"; unauthorizedError: UnauthorizedError }
    | { $case: "forbiddenError"; forbiddenError: ForbiddenError }
    | { $case: "tooManyRequestsError"; tooManyRequestsError: TooManyRequestsError }
    | undefined;
}

function createBaseFriendshipEventResponse(): FriendshipEventResponse {
  return { body: undefined };
}

export namespace FriendshipEventResponse {
  export function encode(message: FriendshipEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.body?.$case) {
      case "request":
        RequestResponse.encode(message.body.request, writer.uint32(10).fork()).ldelim();
        break;
      case "accept":
        AcceptResponse.encode(message.body.accept, writer.uint32(18).fork()).ldelim();
        break;
      case "reject":
        RejectResponse.encode(message.body.reject, writer.uint32(34).fork()).ldelim();
        break;
      case "delete":
        DeleteResponse.encode(message.body.delete, writer.uint32(42).fork()).ldelim();
        break;
      case "cancel":
        CancelResponse.encode(message.body.cancel, writer.uint32(50).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): FriendshipEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendshipEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.body = { $case: "request", request: RequestResponse.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.body = { $case: "accept", accept: AcceptResponse.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.body = { $case: "reject", reject: RejectResponse.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.body = { $case: "delete", delete: DeleteResponse.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.body = { $case: "cancel", cancel: CancelResponse.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): FriendshipEventResponse {
    return {
      body: isSet(object.request)
        ? { $case: "request", request: RequestResponse.fromJSON(object.request) }
        : isSet(object.accept)
        ? { $case: "accept", accept: AcceptResponse.fromJSON(object.accept) }
        : isSet(object.reject)
        ? { $case: "reject", reject: RejectResponse.fromJSON(object.reject) }
        : isSet(object.delete)
        ? { $case: "delete", delete: DeleteResponse.fromJSON(object.delete) }
        : isSet(object.cancel)
        ? { $case: "cancel", cancel: CancelResponse.fromJSON(object.cancel) }
        : undefined,
    };
  }

  export function toJSON(message: FriendshipEventResponse): unknown {
    const obj: any = {};
    message.body?.$case === "request" &&
      (obj.request = message.body?.request ? RequestResponse.toJSON(message.body?.request) : undefined);
    message.body?.$case === "accept" &&
      (obj.accept = message.body?.accept ? AcceptResponse.toJSON(message.body?.accept) : undefined);
    message.body?.$case === "reject" &&
      (obj.reject = message.body?.reject ? RejectResponse.toJSON(message.body?.reject) : undefined);
    message.body?.$case === "delete" &&
      (obj.delete = message.body?.delete ? DeleteResponse.toJSON(message.body?.delete) : undefined);
    message.body?.$case === "cancel" &&
      (obj.cancel = message.body?.cancel ? CancelResponse.toJSON(message.body?.cancel) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<FriendshipEventResponse>, I>>(base?: I): FriendshipEventResponse {
    return FriendshipEventResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<FriendshipEventResponse>, I>>(
    object: I,
  ): FriendshipEventResponse {
    const message = createBaseFriendshipEventResponse();
    if (object.body?.$case === "request" && object.body?.request !== undefined && object.body?.request !== null) {
      message.body = { $case: "request", request: RequestResponse.fromPartial(object.body.request) };
    }
    if (object.body?.$case === "accept" && object.body?.accept !== undefined && object.body?.accept !== null) {
      message.body = { $case: "accept", accept: AcceptResponse.fromPartial(object.body.accept) };
    }
    if (object.body?.$case === "reject" && object.body?.reject !== undefined && object.body?.reject !== null) {
      message.body = { $case: "reject", reject: RejectResponse.fromPartial(object.body.reject) };
    }
    if (object.body?.$case === "delete" && object.body?.delete !== undefined && object.body?.delete !== null) {
      message.body = { $case: "delete", delete: DeleteResponse.fromPartial(object.body.delete) };
    }
    if (object.body?.$case === "cancel" && object.body?.cancel !== undefined && object.body?.cancel !== null) {
      message.body = { $case: "cancel", cancel: CancelResponse.fromPartial(object.body.cancel) };
    }
    return message;
  }
}

function createBaseFriendshipEventResponses(): FriendshipEventResponses {
  return { responses: [] };
}

export namespace FriendshipEventResponses {
  export function encode(message: FriendshipEventResponses, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.responses) {
      FriendshipEventResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): FriendshipEventResponses {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendshipEventResponses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.responses.push(FriendshipEventResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): FriendshipEventResponses {
    return {
      responses: Array.isArray(object?.responses)
        ? object.responses.map((e: any) => FriendshipEventResponse.fromJSON(e))
        : [],
    };
  }

  export function toJSON(message: FriendshipEventResponses): unknown {
    const obj: any = {};
    if (message.responses) {
      obj.responses = message.responses.map((e) => e ? FriendshipEventResponse.toJSON(e) : undefined);
    } else {
      obj.responses = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<FriendshipEventResponses>, I>>(
    base?: I,
  ): FriendshipEventResponses {
    return FriendshipEventResponses.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<FriendshipEventResponses>, I>>(
    object: I,
  ): FriendshipEventResponses {
    const message = createBaseFriendshipEventResponses();
    message.responses = object.responses?.map((e) => FriendshipEventResponse.fromPartial(e)) || [];
    return message;
  }
}

function createBaseFriendshipEventPayload(): FriendshipEventPayload {
  return { body: undefined };
}

export namespace FriendshipEventPayload {
  export function encode(message: FriendshipEventPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.body?.$case) {
      case "request":
        RequestPayload.encode(message.body.request, writer.uint32(10).fork()).ldelim();
        break;
      case "accept":
        AcceptPayload.encode(message.body.accept, writer.uint32(18).fork()).ldelim();
        break;
      case "reject":
        RejectPayload.encode(message.body.reject, writer.uint32(34).fork()).ldelim();
        break;
      case "delete":
        DeletePayload.encode(message.body.delete, writer.uint32(42).fork()).ldelim();
        break;
      case "cancel":
        CancelPayload.encode(message.body.cancel, writer.uint32(50).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): FriendshipEventPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendshipEventPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.body = { $case: "request", request: RequestPayload.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.body = { $case: "accept", accept: AcceptPayload.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.body = { $case: "reject", reject: RejectPayload.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.body = { $case: "delete", delete: DeletePayload.decode(reader, reader.uint32()) };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.body = { $case: "cancel", cancel: CancelPayload.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): FriendshipEventPayload {
    return {
      body: isSet(object.request)
        ? { $case: "request", request: RequestPayload.fromJSON(object.request) }
        : isSet(object.accept)
        ? { $case: "accept", accept: AcceptPayload.fromJSON(object.accept) }
        : isSet(object.reject)
        ? { $case: "reject", reject: RejectPayload.fromJSON(object.reject) }
        : isSet(object.delete)
        ? { $case: "delete", delete: DeletePayload.fromJSON(object.delete) }
        : isSet(object.cancel)
        ? { $case: "cancel", cancel: CancelPayload.fromJSON(object.cancel) }
        : undefined,
    };
  }

  export function toJSON(message: FriendshipEventPayload): unknown {
    const obj: any = {};
    message.body?.$case === "request" &&
      (obj.request = message.body?.request ? RequestPayload.toJSON(message.body?.request) : undefined);
    message.body?.$case === "accept" &&
      (obj.accept = message.body?.accept ? AcceptPayload.toJSON(message.body?.accept) : undefined);
    message.body?.$case === "reject" &&
      (obj.reject = message.body?.reject ? RejectPayload.toJSON(message.body?.reject) : undefined);
    message.body?.$case === "delete" &&
      (obj.delete = message.body?.delete ? DeletePayload.toJSON(message.body?.delete) : undefined);
    message.body?.$case === "cancel" &&
      (obj.cancel = message.body?.cancel ? CancelPayload.toJSON(message.body?.cancel) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<FriendshipEventPayload>, I>>(base?: I): FriendshipEventPayload {
    return FriendshipEventPayload.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<FriendshipEventPayload>, I>>(
    object: I,
  ): FriendshipEventPayload {
    const message = createBaseFriendshipEventPayload();
    if (object.body?.$case === "request" && object.body?.request !== undefined && object.body?.request !== null) {
      message.body = { $case: "request", request: RequestPayload.fromPartial(object.body.request) };
    }
    if (object.body?.$case === "accept" && object.body?.accept !== undefined && object.body?.accept !== null) {
      message.body = { $case: "accept", accept: AcceptPayload.fromPartial(object.body.accept) };
    }
    if (object.body?.$case === "reject" && object.body?.reject !== undefined && object.body?.reject !== null) {
      message.body = { $case: "reject", reject: RejectPayload.fromPartial(object.body.reject) };
    }
    if (object.body?.$case === "delete" && object.body?.delete !== undefined && object.body?.delete !== null) {
      message.body = { $case: "delete", delete: DeletePayload.fromPartial(object.body.delete) };
    }
    if (object.body?.$case === "cancel" && object.body?.cancel !== undefined && object.body?.cancel !== null) {
      message.body = { $case: "cancel", cancel: CancelPayload.fromPartial(object.body.cancel) };
    }
    return message;
  }
}

function createBaseUser(): User {
  return { address: "" };
}

export namespace User {
  export function encode(message: User, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): User {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): User {
    return { address: isSet(object.address) ? String(object.address) : "" };
  }

  export function toJSON(message: User): unknown {
    const obj: any = {};
    message.address !== undefined && (obj.address = message.address);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.address = object.address ?? "";
    return message;
  }
}

function createBaseUsers(): Users {
  return { users: [] };
}

export namespace Users {
  export function encode(message: Users, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Users {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Users {
    return { users: Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [] };
  }

  export function toJSON(message: Users): unknown {
    const obj: any = {};
    if (message.users) {
      obj.users = message.users.map((e) => e ? User.toJSON(e) : undefined);
    } else {
      obj.users = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Users>, I>>(base?: I): Users {
    return Users.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Users>, I>>(object: I): Users {
    const message = createBaseUsers();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    return message;
  }
}

function createBaseRequestResponse(): RequestResponse {
  return { user: undefined, createdAt: 0, message: undefined };
}

export namespace RequestResponse {
  export function encode(message: RequestResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.createdAt !== 0) {
      writer.uint32(16).int64(message.createdAt);
    }
    if (message.message !== undefined) {
      writer.uint32(26).string(message.message);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): RequestResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.createdAt = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): RequestResponse {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      createdAt: isSet(object.createdAt) ? Number(object.createdAt) : 0,
      message: isSet(object.message) ? String(object.message) : undefined,
    };
  }

  export function toJSON(message: RequestResponse): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    message.createdAt !== undefined && (obj.createdAt = Math.round(message.createdAt));
    message.message !== undefined && (obj.message = message.message);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<RequestResponse>, I>>(base?: I): RequestResponse {
    return RequestResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<RequestResponse>, I>>(object: I): RequestResponse {
    const message = createBaseRequestResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.createdAt = object.createdAt ?? 0;
    message.message = object.message ?? undefined;
    return message;
  }
}

function createBaseRequestPayload(): RequestPayload {
  return { user: undefined, message: undefined };
}

export namespace RequestPayload {
  export function encode(message: RequestPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.message !== undefined) {
      writer.uint32(26).string(message.message);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): RequestPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): RequestPayload {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      message: isSet(object.message) ? String(object.message) : undefined,
    };
  }

  export function toJSON(message: RequestPayload): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    message.message !== undefined && (obj.message = message.message);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<RequestPayload>, I>>(base?: I): RequestPayload {
    return RequestPayload.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<RequestPayload>, I>>(object: I): RequestPayload {
    const message = createBaseRequestPayload();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.message = object.message ?? undefined;
    return message;
  }
}

function createBaseRequests(): Requests {
  return { total: 0, items: [] };
}

export namespace Requests {
  export function encode(message: Requests, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.total !== 0) {
      writer.uint32(8).int64(message.total);
    }
    for (const v of message.items) {
      RequestResponse.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Requests {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequests();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.total = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.items.push(RequestResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Requests {
    return {
      total: isSet(object.total) ? Number(object.total) : 0,
      items: Array.isArray(object?.items) ? object.items.map((e: any) => RequestResponse.fromJSON(e)) : [],
    };
  }

  export function toJSON(message: Requests): unknown {
    const obj: any = {};
    message.total !== undefined && (obj.total = Math.round(message.total));
    if (message.items) {
      obj.items = message.items.map((e) => e ? RequestResponse.toJSON(e) : undefined);
    } else {
      obj.items = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Requests>, I>>(base?: I): Requests {
    return Requests.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Requests>, I>>(object: I): Requests {
    const message = createBaseRequests();
    message.total = object.total ?? 0;
    message.items = object.items?.map((e) => RequestResponse.fromPartial(e)) || [];
    return message;
  }
}

function createBaseRequestEvents(): RequestEvents {
  return { outgoing: undefined, incoming: undefined };
}

export namespace RequestEvents {
  export function encode(message: RequestEvents, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.outgoing !== undefined) {
      Requests.encode(message.outgoing, writer.uint32(10).fork()).ldelim();
    }
    if (message.incoming !== undefined) {
      Requests.encode(message.incoming, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): RequestEvents {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestEvents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outgoing = Requests.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.incoming = Requests.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): RequestEvents {
    return {
      outgoing: isSet(object.outgoing) ? Requests.fromJSON(object.outgoing) : undefined,
      incoming: isSet(object.incoming) ? Requests.fromJSON(object.incoming) : undefined,
    };
  }

  export function toJSON(message: RequestEvents): unknown {
    const obj: any = {};
    message.outgoing !== undefined && (obj.outgoing = message.outgoing ? Requests.toJSON(message.outgoing) : undefined);
    message.incoming !== undefined && (obj.incoming = message.incoming ? Requests.toJSON(message.incoming) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<RequestEvents>, I>>(base?: I): RequestEvents {
    return RequestEvents.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<RequestEvents>, I>>(object: I): RequestEvents {
    const message = createBaseRequestEvents();
    message.outgoing = (object.outgoing !== undefined && object.outgoing !== null)
      ? Requests.fromPartial(object.outgoing)
      : undefined;
    message.incoming = (object.incoming !== undefined && object.incoming !== null)
      ? Requests.fromPartial(object.incoming)
      : undefined;
    return message;
  }
}

function createBaseAcceptResponse(): AcceptResponse {
  return { user: undefined };
}

export namespace AcceptResponse {
  export function encode(message: AcceptResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): AcceptResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): AcceptResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  }

  export function toJSON(message: AcceptResponse): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<AcceptResponse>, I>>(base?: I): AcceptResponse {
    return AcceptResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<AcceptResponse>, I>>(object: I): AcceptResponse {
    const message = createBaseAcceptResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  }
}

function createBaseAcceptPayload(): AcceptPayload {
  return { user: undefined };
}

export namespace AcceptPayload {
  export function encode(message: AcceptPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): AcceptPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceptPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): AcceptPayload {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  }

  export function toJSON(message: AcceptPayload): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<AcceptPayload>, I>>(base?: I): AcceptPayload {
    return AcceptPayload.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<AcceptPayload>, I>>(object: I): AcceptPayload {
    const message = createBaseAcceptPayload();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  }
}

function createBaseRejectResponse(): RejectResponse {
  return { user: undefined };
}

export namespace RejectResponse {
  export function encode(message: RejectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): RejectResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): RejectResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  }

  export function toJSON(message: RejectResponse): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<RejectResponse>, I>>(base?: I): RejectResponse {
    return RejectResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<RejectResponse>, I>>(object: I): RejectResponse {
    const message = createBaseRejectResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  }
}

function createBaseRejectPayload(): RejectPayload {
  return { user: undefined };
}

export namespace RejectPayload {
  export function encode(message: RejectPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): RejectPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): RejectPayload {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  }

  export function toJSON(message: RejectPayload): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<RejectPayload>, I>>(base?: I): RejectPayload {
    return RejectPayload.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<RejectPayload>, I>>(object: I): RejectPayload {
    const message = createBaseRejectPayload();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  }
}

function createBaseDeleteResponse(): DeleteResponse {
  return { user: undefined };
}

export namespace DeleteResponse {
  export function encode(message: DeleteResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): DeleteResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  }

  export function toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(object: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  }
}

function createBaseDeletePayload(): DeletePayload {
  return { user: undefined };
}

export namespace DeletePayload {
  export function encode(message: DeletePayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): DeletePayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): DeletePayload {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  }

  export function toJSON(message: DeletePayload): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<DeletePayload>, I>>(base?: I): DeletePayload {
    return DeletePayload.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<DeletePayload>, I>>(object: I): DeletePayload {
    const message = createBaseDeletePayload();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  }
}

function createBaseCancelResponse(): CancelResponse {
  return { user: undefined };
}

export namespace CancelResponse {
  export function encode(message: CancelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): CancelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): CancelResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  }

  export function toJSON(message: CancelResponse): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<CancelResponse>, I>>(base?: I): CancelResponse {
    return CancelResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<CancelResponse>, I>>(object: I): CancelResponse {
    const message = createBaseCancelResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  }
}

function createBaseCancelPayload(): CancelPayload {
  return { user: undefined };
}

export namespace CancelPayload {
  export function encode(message: CancelPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): CancelPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): CancelPayload {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  }

  export function toJSON(message: CancelPayload): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<CancelPayload>, I>>(base?: I): CancelPayload {
    return CancelPayload.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<CancelPayload>, I>>(object: I): CancelPayload {
    const message = createBaseCancelPayload();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  }
}

function createBaseUpdateFriendshipPayload(): UpdateFriendshipPayload {
  return { event: undefined, authToken: undefined };
}

export namespace UpdateFriendshipPayload {
  export function encode(message: UpdateFriendshipPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.event !== undefined) {
      FriendshipEventPayload.encode(message.event, writer.uint32(10).fork()).ldelim();
    }
    if (message.authToken !== undefined) {
      Payload.encode(message.authToken, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): UpdateFriendshipPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFriendshipPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.event = FriendshipEventPayload.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.authToken = Payload.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): UpdateFriendshipPayload {
    return {
      event: isSet(object.event) ? FriendshipEventPayload.fromJSON(object.event) : undefined,
      authToken: isSet(object.authToken) ? Payload.fromJSON(object.authToken) : undefined,
    };
  }

  export function toJSON(message: UpdateFriendshipPayload): unknown {
    const obj: any = {};
    message.event !== undefined &&
      (obj.event = message.event ? FriendshipEventPayload.toJSON(message.event) : undefined);
    message.authToken !== undefined &&
      (obj.authToken = message.authToken ? Payload.toJSON(message.authToken) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<UpdateFriendshipPayload>, I>>(base?: I): UpdateFriendshipPayload {
    return UpdateFriendshipPayload.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<UpdateFriendshipPayload>, I>>(
    object: I,
  ): UpdateFriendshipPayload {
    const message = createBaseUpdateFriendshipPayload();
    message.event = (object.event !== undefined && object.event !== null)
      ? FriendshipEventPayload.fromPartial(object.event)
      : undefined;
    message.authToken = (object.authToken !== undefined && object.authToken !== null)
      ? Payload.fromPartial(object.authToken)
      : undefined;
    return message;
  }
}

function createBaseMutualFriendsPayload(): MutualFriendsPayload {
  return { user: undefined, authToken: undefined };
}

export namespace MutualFriendsPayload {
  export function encode(message: MutualFriendsPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.authToken !== undefined) {
      Payload.encode(message.authToken, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): MutualFriendsPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutualFriendsPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.authToken = Payload.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): MutualFriendsPayload {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      authToken: isSet(object.authToken) ? Payload.fromJSON(object.authToken) : undefined,
    };
  }

  export function toJSON(message: MutualFriendsPayload): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    message.authToken !== undefined &&
      (obj.authToken = message.authToken ? Payload.toJSON(message.authToken) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<MutualFriendsPayload>, I>>(base?: I): MutualFriendsPayload {
    return MutualFriendsPayload.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<MutualFriendsPayload>, I>>(object: I): MutualFriendsPayload {
    const message = createBaseMutualFriendsPayload();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.authToken = (object.authToken !== undefined && object.authToken !== null)
      ? Payload.fromPartial(object.authToken)
      : undefined;
    return message;
  }
}

function createBasePayload(): Payload {
  return { synapseToken: undefined };
}

export namespace Payload {
  export function encode(message: Payload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.synapseToken !== undefined) {
      writer.uint32(10).string(message.synapseToken);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Payload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.synapseToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Payload {
    return { synapseToken: isSet(object.synapseToken) ? String(object.synapseToken) : undefined };
  }

  export function toJSON(message: Payload): unknown {
    const obj: any = {};
    message.synapseToken !== undefined && (obj.synapseToken = message.synapseToken);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Payload>, I>>(base?: I): Payload {
    return Payload.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Payload>, I>>(object: I): Payload {
    const message = createBasePayload();
    message.synapseToken = object.synapseToken ?? undefined;
    return message;
  }
}

function createBaseBadRequestError(): BadRequestError {
  return { message: "" };
}

export namespace BadRequestError {
  export function encode(message: BadRequestError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): BadRequestError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadRequestError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): BadRequestError {
    return { message: isSet(object.message) ? String(object.message) : "" };
  }

  export function toJSON(message: BadRequestError): unknown {
    const obj: any = {};
    message.message !== undefined && (obj.message = message.message);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<BadRequestError>, I>>(base?: I): BadRequestError {
    return BadRequestError.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<BadRequestError>, I>>(object: I): BadRequestError {
    const message = createBaseBadRequestError();
    message.message = object.message ?? "";
    return message;
  }
}

function createBaseUnauthorizedError(): UnauthorizedError {
  return { message: "" };
}

export namespace UnauthorizedError {
  export function encode(message: UnauthorizedError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): UnauthorizedError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnauthorizedError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): UnauthorizedError {
    return { message: isSet(object.message) ? String(object.message) : "" };
  }

  export function toJSON(message: UnauthorizedError): unknown {
    const obj: any = {};
    message.message !== undefined && (obj.message = message.message);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<UnauthorizedError>, I>>(base?: I): UnauthorizedError {
    return UnauthorizedError.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<UnauthorizedError>, I>>(object: I): UnauthorizedError {
    const message = createBaseUnauthorizedError();
    message.message = object.message ?? "";
    return message;
  }
}

function createBaseForbiddenError(): ForbiddenError {
  return { message: "" };
}

export namespace ForbiddenError {
  export function encode(message: ForbiddenError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): ForbiddenError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForbiddenError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): ForbiddenError {
    return { message: isSet(object.message) ? String(object.message) : "" };
  }

  export function toJSON(message: ForbiddenError): unknown {
    const obj: any = {};
    message.message !== undefined && (obj.message = message.message);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<ForbiddenError>, I>>(base?: I): ForbiddenError {
    return ForbiddenError.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<ForbiddenError>, I>>(object: I): ForbiddenError {
    const message = createBaseForbiddenError();
    message.message = object.message ?? "";
    return message;
  }
}

function createBaseTooManyRequestsError(): TooManyRequestsError {
  return { message: "" };
}

export namespace TooManyRequestsError {
  export function encode(message: TooManyRequestsError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TooManyRequestsError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTooManyRequestsError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): TooManyRequestsError {
    return { message: isSet(object.message) ? String(object.message) : "" };
  }

  export function toJSON(message: TooManyRequestsError): unknown {
    const obj: any = {};
    message.message !== undefined && (obj.message = message.message);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TooManyRequestsError>, I>>(base?: I): TooManyRequestsError {
    return TooManyRequestsError.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TooManyRequestsError>, I>>(object: I): TooManyRequestsError {
    const message = createBaseTooManyRequestsError();
    message.message = object.message ?? "";
    return message;
  }
}

function createBaseInternalServerError(): InternalServerError {
  return { message: "" };
}

export namespace InternalServerError {
  export function encode(message: InternalServerError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): InternalServerError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalServerError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): InternalServerError {
    return { message: isSet(object.message) ? String(object.message) : "" };
  }

  export function toJSON(message: InternalServerError): unknown {
    const obj: any = {};
    message.message !== undefined && (obj.message = message.message);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<InternalServerError>, I>>(base?: I): InternalServerError {
    return InternalServerError.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<InternalServerError>, I>>(object: I): InternalServerError {
    const message = createBaseInternalServerError();
    message.message = object.message ?? "";
    return message;
  }
}

function createBaseUsersResponse(): UsersResponse {
  return { response: undefined };
}

export namespace UsersResponse {
  export function encode(message: UsersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.response?.$case) {
      case "users":
        Users.encode(message.response.users, writer.uint32(10).fork()).ldelim();
        break;
      case "internalServerError":
        InternalServerError.encode(message.response.internalServerError, writer.uint32(18).fork()).ldelim();
        break;
      case "unauthorizedError":
        UnauthorizedError.encode(message.response.unauthorizedError, writer.uint32(26).fork()).ldelim();
        break;
      case "forbiddenError":
        ForbiddenError.encode(message.response.forbiddenError, writer.uint32(34).fork()).ldelim();
        break;
      case "tooManyRequestsError":
        TooManyRequestsError.encode(message.response.tooManyRequestsError, writer.uint32(42).fork()).ldelim();
        break;
      case "badRequestError":
        BadRequestError.encode(message.response.badRequestError, writer.uint32(50).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): UsersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = { $case: "users", users: Users.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = {
            $case: "internalServerError",
            internalServerError: InternalServerError.decode(reader, reader.uint32()),
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.response = {
            $case: "unauthorizedError",
            unauthorizedError: UnauthorizedError.decode(reader, reader.uint32()),
          };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.response = {
            $case: "forbiddenError",
            forbiddenError: ForbiddenError.decode(reader, reader.uint32()),
          };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.response = {
            $case: "tooManyRequestsError",
            tooManyRequestsError: TooManyRequestsError.decode(reader, reader.uint32()),
          };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.response = {
            $case: "badRequestError",
            badRequestError: BadRequestError.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): UsersResponse {
    return {
      response: isSet(object.users)
        ? { $case: "users", users: Users.fromJSON(object.users) }
        : isSet(object.internalServerError)
        ? {
          $case: "internalServerError",
          internalServerError: InternalServerError.fromJSON(object.internalServerError),
        }
        : isSet(object.unauthorizedError)
        ? { $case: "unauthorizedError", unauthorizedError: UnauthorizedError.fromJSON(object.unauthorizedError) }
        : isSet(object.forbiddenError)
        ? { $case: "forbiddenError", forbiddenError: ForbiddenError.fromJSON(object.forbiddenError) }
        : isSet(object.tooManyRequestsError)
        ? {
          $case: "tooManyRequestsError",
          tooManyRequestsError: TooManyRequestsError.fromJSON(object.tooManyRequestsError),
        }
        : isSet(object.badRequestError)
        ? { $case: "badRequestError", badRequestError: BadRequestError.fromJSON(object.badRequestError) }
        : undefined,
    };
  }

  export function toJSON(message: UsersResponse): unknown {
    const obj: any = {};
    message.response?.$case === "users" &&
      (obj.users = message.response?.users ? Users.toJSON(message.response?.users) : undefined);
    message.response?.$case === "internalServerError" &&
      (obj.internalServerError = message.response?.internalServerError
        ? InternalServerError.toJSON(message.response?.internalServerError)
        : undefined);
    message.response?.$case === "unauthorizedError" &&
      (obj.unauthorizedError = message.response?.unauthorizedError
        ? UnauthorizedError.toJSON(message.response?.unauthorizedError)
        : undefined);
    message.response?.$case === "forbiddenError" &&
      (obj.forbiddenError = message.response?.forbiddenError
        ? ForbiddenError.toJSON(message.response?.forbiddenError)
        : undefined);
    message.response?.$case === "tooManyRequestsError" &&
      (obj.tooManyRequestsError = message.response?.tooManyRequestsError
        ? TooManyRequestsError.toJSON(message.response?.tooManyRequestsError)
        : undefined);
    message.response?.$case === "badRequestError" &&
      (obj.badRequestError = message.response?.badRequestError
        ? BadRequestError.toJSON(message.response?.badRequestError)
        : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<UsersResponse>, I>>(base?: I): UsersResponse {
    return UsersResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<UsersResponse>, I>>(object: I): UsersResponse {
    const message = createBaseUsersResponse();
    if (object.response?.$case === "users" && object.response?.users !== undefined && object.response?.users !== null) {
      message.response = { $case: "users", users: Users.fromPartial(object.response.users) };
    }
    if (
      object.response?.$case === "internalServerError" &&
      object.response?.internalServerError !== undefined &&
      object.response?.internalServerError !== null
    ) {
      message.response = {
        $case: "internalServerError",
        internalServerError: InternalServerError.fromPartial(object.response.internalServerError),
      };
    }
    if (
      object.response?.$case === "unauthorizedError" &&
      object.response?.unauthorizedError !== undefined &&
      object.response?.unauthorizedError !== null
    ) {
      message.response = {
        $case: "unauthorizedError",
        unauthorizedError: UnauthorizedError.fromPartial(object.response.unauthorizedError),
      };
    }
    if (
      object.response?.$case === "forbiddenError" &&
      object.response?.forbiddenError !== undefined &&
      object.response?.forbiddenError !== null
    ) {
      message.response = {
        $case: "forbiddenError",
        forbiddenError: ForbiddenError.fromPartial(object.response.forbiddenError),
      };
    }
    if (
      object.response?.$case === "tooManyRequestsError" &&
      object.response?.tooManyRequestsError !== undefined &&
      object.response?.tooManyRequestsError !== null
    ) {
      message.response = {
        $case: "tooManyRequestsError",
        tooManyRequestsError: TooManyRequestsError.fromPartial(object.response.tooManyRequestsError),
      };
    }
    if (
      object.response?.$case === "badRequestError" &&
      object.response?.badRequestError !== undefined &&
      object.response?.badRequestError !== null
    ) {
      message.response = {
        $case: "badRequestError",
        badRequestError: BadRequestError.fromPartial(object.response.badRequestError),
      };
    }
    return message;
  }
}

function createBaseRequestEventsResponse(): RequestEventsResponse {
  return { response: undefined };
}

export namespace RequestEventsResponse {
  export function encode(message: RequestEventsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.response?.$case) {
      case "events":
        RequestEvents.encode(message.response.events, writer.uint32(10).fork()).ldelim();
        break;
      case "internalServerError":
        InternalServerError.encode(message.response.internalServerError, writer.uint32(18).fork()).ldelim();
        break;
      case "unauthorizedError":
        UnauthorizedError.encode(message.response.unauthorizedError, writer.uint32(26).fork()).ldelim();
        break;
      case "forbiddenError":
        ForbiddenError.encode(message.response.forbiddenError, writer.uint32(34).fork()).ldelim();
        break;
      case "tooManyRequestsError":
        TooManyRequestsError.encode(message.response.tooManyRequestsError, writer.uint32(42).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): RequestEventsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = { $case: "events", events: RequestEvents.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = {
            $case: "internalServerError",
            internalServerError: InternalServerError.decode(reader, reader.uint32()),
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.response = {
            $case: "unauthorizedError",
            unauthorizedError: UnauthorizedError.decode(reader, reader.uint32()),
          };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.response = {
            $case: "forbiddenError",
            forbiddenError: ForbiddenError.decode(reader, reader.uint32()),
          };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.response = {
            $case: "tooManyRequestsError",
            tooManyRequestsError: TooManyRequestsError.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): RequestEventsResponse {
    return {
      response: isSet(object.events)
        ? { $case: "events", events: RequestEvents.fromJSON(object.events) }
        : isSet(object.internalServerError)
        ? {
          $case: "internalServerError",
          internalServerError: InternalServerError.fromJSON(object.internalServerError),
        }
        : isSet(object.unauthorizedError)
        ? { $case: "unauthorizedError", unauthorizedError: UnauthorizedError.fromJSON(object.unauthorizedError) }
        : isSet(object.forbiddenError)
        ? { $case: "forbiddenError", forbiddenError: ForbiddenError.fromJSON(object.forbiddenError) }
        : isSet(object.tooManyRequestsError)
        ? {
          $case: "tooManyRequestsError",
          tooManyRequestsError: TooManyRequestsError.fromJSON(object.tooManyRequestsError),
        }
        : undefined,
    };
  }

  export function toJSON(message: RequestEventsResponse): unknown {
    const obj: any = {};
    message.response?.$case === "events" &&
      (obj.events = message.response?.events ? RequestEvents.toJSON(message.response?.events) : undefined);
    message.response?.$case === "internalServerError" &&
      (obj.internalServerError = message.response?.internalServerError
        ? InternalServerError.toJSON(message.response?.internalServerError)
        : undefined);
    message.response?.$case === "unauthorizedError" &&
      (obj.unauthorizedError = message.response?.unauthorizedError
        ? UnauthorizedError.toJSON(message.response?.unauthorizedError)
        : undefined);
    message.response?.$case === "forbiddenError" &&
      (obj.forbiddenError = message.response?.forbiddenError
        ? ForbiddenError.toJSON(message.response?.forbiddenError)
        : undefined);
    message.response?.$case === "tooManyRequestsError" &&
      (obj.tooManyRequestsError = message.response?.tooManyRequestsError
        ? TooManyRequestsError.toJSON(message.response?.tooManyRequestsError)
        : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<RequestEventsResponse>, I>>(base?: I): RequestEventsResponse {
    return RequestEventsResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<RequestEventsResponse>, I>>(
    object: I,
  ): RequestEventsResponse {
    const message = createBaseRequestEventsResponse();
    if (
      object.response?.$case === "events" && object.response?.events !== undefined && object.response?.events !== null
    ) {
      message.response = { $case: "events", events: RequestEvents.fromPartial(object.response.events) };
    }
    if (
      object.response?.$case === "internalServerError" &&
      object.response?.internalServerError !== undefined &&
      object.response?.internalServerError !== null
    ) {
      message.response = {
        $case: "internalServerError",
        internalServerError: InternalServerError.fromPartial(object.response.internalServerError),
      };
    }
    if (
      object.response?.$case === "unauthorizedError" &&
      object.response?.unauthorizedError !== undefined &&
      object.response?.unauthorizedError !== null
    ) {
      message.response = {
        $case: "unauthorizedError",
        unauthorizedError: UnauthorizedError.fromPartial(object.response.unauthorizedError),
      };
    }
    if (
      object.response?.$case === "forbiddenError" &&
      object.response?.forbiddenError !== undefined &&
      object.response?.forbiddenError !== null
    ) {
      message.response = {
        $case: "forbiddenError",
        forbiddenError: ForbiddenError.fromPartial(object.response.forbiddenError),
      };
    }
    if (
      object.response?.$case === "tooManyRequestsError" &&
      object.response?.tooManyRequestsError !== undefined &&
      object.response?.tooManyRequestsError !== null
    ) {
      message.response = {
        $case: "tooManyRequestsError",
        tooManyRequestsError: TooManyRequestsError.fromPartial(object.response.tooManyRequestsError),
      };
    }
    return message;
  }
}

function createBaseUpdateFriendshipResponse(): UpdateFriendshipResponse {
  return { response: undefined };
}

export namespace UpdateFriendshipResponse {
  export function encode(message: UpdateFriendshipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.response?.$case) {
      case "event":
        FriendshipEventResponse.encode(message.response.event, writer.uint32(10).fork()).ldelim();
        break;
      case "internalServerError":
        InternalServerError.encode(message.response.internalServerError, writer.uint32(18).fork()).ldelim();
        break;
      case "unauthorizedError":
        UnauthorizedError.encode(message.response.unauthorizedError, writer.uint32(26).fork()).ldelim();
        break;
      case "forbiddenError":
        ForbiddenError.encode(message.response.forbiddenError, writer.uint32(34).fork()).ldelim();
        break;
      case "tooManyRequestsError":
        TooManyRequestsError.encode(message.response.tooManyRequestsError, writer.uint32(42).fork()).ldelim();
        break;
      case "badRequestError":
        BadRequestError.encode(message.response.badRequestError, writer.uint32(50).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): UpdateFriendshipResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFriendshipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = { $case: "event", event: FriendshipEventResponse.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = {
            $case: "internalServerError",
            internalServerError: InternalServerError.decode(reader, reader.uint32()),
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.response = {
            $case: "unauthorizedError",
            unauthorizedError: UnauthorizedError.decode(reader, reader.uint32()),
          };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.response = {
            $case: "forbiddenError",
            forbiddenError: ForbiddenError.decode(reader, reader.uint32()),
          };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.response = {
            $case: "tooManyRequestsError",
            tooManyRequestsError: TooManyRequestsError.decode(reader, reader.uint32()),
          };
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.response = {
            $case: "badRequestError",
            badRequestError: BadRequestError.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): UpdateFriendshipResponse {
    return {
      response: isSet(object.event)
        ? { $case: "event", event: FriendshipEventResponse.fromJSON(object.event) }
        : isSet(object.internalServerError)
        ? {
          $case: "internalServerError",
          internalServerError: InternalServerError.fromJSON(object.internalServerError),
        }
        : isSet(object.unauthorizedError)
        ? { $case: "unauthorizedError", unauthorizedError: UnauthorizedError.fromJSON(object.unauthorizedError) }
        : isSet(object.forbiddenError)
        ? { $case: "forbiddenError", forbiddenError: ForbiddenError.fromJSON(object.forbiddenError) }
        : isSet(object.tooManyRequestsError)
        ? {
          $case: "tooManyRequestsError",
          tooManyRequestsError: TooManyRequestsError.fromJSON(object.tooManyRequestsError),
        }
        : isSet(object.badRequestError)
        ? { $case: "badRequestError", badRequestError: BadRequestError.fromJSON(object.badRequestError) }
        : undefined,
    };
  }

  export function toJSON(message: UpdateFriendshipResponse): unknown {
    const obj: any = {};
    message.response?.$case === "event" &&
      (obj.event = message.response?.event ? FriendshipEventResponse.toJSON(message.response?.event) : undefined);
    message.response?.$case === "internalServerError" &&
      (obj.internalServerError = message.response?.internalServerError
        ? InternalServerError.toJSON(message.response?.internalServerError)
        : undefined);
    message.response?.$case === "unauthorizedError" &&
      (obj.unauthorizedError = message.response?.unauthorizedError
        ? UnauthorizedError.toJSON(message.response?.unauthorizedError)
        : undefined);
    message.response?.$case === "forbiddenError" &&
      (obj.forbiddenError = message.response?.forbiddenError
        ? ForbiddenError.toJSON(message.response?.forbiddenError)
        : undefined);
    message.response?.$case === "tooManyRequestsError" &&
      (obj.tooManyRequestsError = message.response?.tooManyRequestsError
        ? TooManyRequestsError.toJSON(message.response?.tooManyRequestsError)
        : undefined);
    message.response?.$case === "badRequestError" &&
      (obj.badRequestError = message.response?.badRequestError
        ? BadRequestError.toJSON(message.response?.badRequestError)
        : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<UpdateFriendshipResponse>, I>>(
    base?: I,
  ): UpdateFriendshipResponse {
    return UpdateFriendshipResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<UpdateFriendshipResponse>, I>>(
    object: I,
  ): UpdateFriendshipResponse {
    const message = createBaseUpdateFriendshipResponse();
    if (object.response?.$case === "event" && object.response?.event !== undefined && object.response?.event !== null) {
      message.response = { $case: "event", event: FriendshipEventResponse.fromPartial(object.response.event) };
    }
    if (
      object.response?.$case === "internalServerError" &&
      object.response?.internalServerError !== undefined &&
      object.response?.internalServerError !== null
    ) {
      message.response = {
        $case: "internalServerError",
        internalServerError: InternalServerError.fromPartial(object.response.internalServerError),
      };
    }
    if (
      object.response?.$case === "unauthorizedError" &&
      object.response?.unauthorizedError !== undefined &&
      object.response?.unauthorizedError !== null
    ) {
      message.response = {
        $case: "unauthorizedError",
        unauthorizedError: UnauthorizedError.fromPartial(object.response.unauthorizedError),
      };
    }
    if (
      object.response?.$case === "forbiddenError" &&
      object.response?.forbiddenError !== undefined &&
      object.response?.forbiddenError !== null
    ) {
      message.response = {
        $case: "forbiddenError",
        forbiddenError: ForbiddenError.fromPartial(object.response.forbiddenError),
      };
    }
    if (
      object.response?.$case === "tooManyRequestsError" &&
      object.response?.tooManyRequestsError !== undefined &&
      object.response?.tooManyRequestsError !== null
    ) {
      message.response = {
        $case: "tooManyRequestsError",
        tooManyRequestsError: TooManyRequestsError.fromPartial(object.response.tooManyRequestsError),
      };
    }
    if (
      object.response?.$case === "badRequestError" &&
      object.response?.badRequestError !== undefined &&
      object.response?.badRequestError !== null
    ) {
      message.response = {
        $case: "badRequestError",
        badRequestError: BadRequestError.fromPartial(object.response.badRequestError),
      };
    }
    return message;
  }
}

function createBaseSubscribeFriendshipEventsUpdatesResponse(): SubscribeFriendshipEventsUpdatesResponse {
  return { response: undefined };
}

export namespace SubscribeFriendshipEventsUpdatesResponse {
  export function encode(
    message: SubscribeFriendshipEventsUpdatesResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    switch (message.response?.$case) {
      case "events":
        FriendshipEventResponses.encode(message.response.events, writer.uint32(10).fork()).ldelim();
        break;
      case "internalServerError":
        InternalServerError.encode(message.response.internalServerError, writer.uint32(18).fork()).ldelim();
        break;
      case "unauthorizedError":
        UnauthorizedError.encode(message.response.unauthorizedError, writer.uint32(26).fork()).ldelim();
        break;
      case "forbiddenError":
        ForbiddenError.encode(message.response.forbiddenError, writer.uint32(34).fork()).ldelim();
        break;
      case "tooManyRequestsError":
        TooManyRequestsError.encode(message.response.tooManyRequestsError, writer.uint32(42).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeFriendshipEventsUpdatesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeFriendshipEventsUpdatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = { $case: "events", events: FriendshipEventResponses.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = {
            $case: "internalServerError",
            internalServerError: InternalServerError.decode(reader, reader.uint32()),
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.response = {
            $case: "unauthorizedError",
            unauthorizedError: UnauthorizedError.decode(reader, reader.uint32()),
          };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.response = {
            $case: "forbiddenError",
            forbiddenError: ForbiddenError.decode(reader, reader.uint32()),
          };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.response = {
            $case: "tooManyRequestsError",
            tooManyRequestsError: TooManyRequestsError.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): SubscribeFriendshipEventsUpdatesResponse {
    return {
      response: isSet(object.events)
        ? { $case: "events", events: FriendshipEventResponses.fromJSON(object.events) }
        : isSet(object.internalServerError)
        ? {
          $case: "internalServerError",
          internalServerError: InternalServerError.fromJSON(object.internalServerError),
        }
        : isSet(object.unauthorizedError)
        ? { $case: "unauthorizedError", unauthorizedError: UnauthorizedError.fromJSON(object.unauthorizedError) }
        : isSet(object.forbiddenError)
        ? { $case: "forbiddenError", forbiddenError: ForbiddenError.fromJSON(object.forbiddenError) }
        : isSet(object.tooManyRequestsError)
        ? {
          $case: "tooManyRequestsError",
          tooManyRequestsError: TooManyRequestsError.fromJSON(object.tooManyRequestsError),
        }
        : undefined,
    };
  }

  export function toJSON(message: SubscribeFriendshipEventsUpdatesResponse): unknown {
    const obj: any = {};
    message.response?.$case === "events" &&
      (obj.events = message.response?.events ? FriendshipEventResponses.toJSON(message.response?.events) : undefined);
    message.response?.$case === "internalServerError" &&
      (obj.internalServerError = message.response?.internalServerError
        ? InternalServerError.toJSON(message.response?.internalServerError)
        : undefined);
    message.response?.$case === "unauthorizedError" &&
      (obj.unauthorizedError = message.response?.unauthorizedError
        ? UnauthorizedError.toJSON(message.response?.unauthorizedError)
        : undefined);
    message.response?.$case === "forbiddenError" &&
      (obj.forbiddenError = message.response?.forbiddenError
        ? ForbiddenError.toJSON(message.response?.forbiddenError)
        : undefined);
    message.response?.$case === "tooManyRequestsError" &&
      (obj.tooManyRequestsError = message.response?.tooManyRequestsError
        ? TooManyRequestsError.toJSON(message.response?.tooManyRequestsError)
        : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<SubscribeFriendshipEventsUpdatesResponse>, I>>(
    base?: I,
  ): SubscribeFriendshipEventsUpdatesResponse {
    return SubscribeFriendshipEventsUpdatesResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<SubscribeFriendshipEventsUpdatesResponse>, I>>(
    object: I,
  ): SubscribeFriendshipEventsUpdatesResponse {
    const message = createBaseSubscribeFriendshipEventsUpdatesResponse();
    if (
      object.response?.$case === "events" && object.response?.events !== undefined && object.response?.events !== null
    ) {
      message.response = { $case: "events", events: FriendshipEventResponses.fromPartial(object.response.events) };
    }
    if (
      object.response?.$case === "internalServerError" &&
      object.response?.internalServerError !== undefined &&
      object.response?.internalServerError !== null
    ) {
      message.response = {
        $case: "internalServerError",
        internalServerError: InternalServerError.fromPartial(object.response.internalServerError),
      };
    }
    if (
      object.response?.$case === "unauthorizedError" &&
      object.response?.unauthorizedError !== undefined &&
      object.response?.unauthorizedError !== null
    ) {
      message.response = {
        $case: "unauthorizedError",
        unauthorizedError: UnauthorizedError.fromPartial(object.response.unauthorizedError),
      };
    }
    if (
      object.response?.$case === "forbiddenError" &&
      object.response?.forbiddenError !== undefined &&
      object.response?.forbiddenError !== null
    ) {
      message.response = {
        $case: "forbiddenError",
        forbiddenError: ForbiddenError.fromPartial(object.response.forbiddenError),
      };
    }
    if (
      object.response?.$case === "tooManyRequestsError" &&
      object.response?.tooManyRequestsError !== undefined &&
      object.response?.tooManyRequestsError !== null
    ) {
      message.response = {
        $case: "tooManyRequestsError",
        tooManyRequestsError: TooManyRequestsError.fromPartial(object.response.tooManyRequestsError),
      };
    }
    return message;
  }
}

export type FriendshipsServiceDefinition = typeof FriendshipsServiceDefinition;
export const FriendshipsServiceDefinition = {
  name: "FriendshipsService",
  fullName: "decentraland.social.friendships.FriendshipsService",
  methods: {
    /** Get the list of friends for the authenticated user */
    getFriends: {
      name: "GetFriends",
      requestType: Payload,
      requestStream: false,
      responseType: UsersResponse,
      responseStream: true,
      options: {},
    },
    /** Get the list of mutual friends between the authenticated user and the one in the parameter */
    getMutualFriends: {
      name: "GetMutualFriends",
      requestType: MutualFriendsPayload,
      requestStream: false,
      responseType: UsersResponse,
      responseStream: true,
      options: {},
    },
    /** Get the list of request events for the authenticated user */
    getRequestEvents: {
      name: "GetRequestEvents",
      requestType: Payload,
      requestStream: false,
      responseType: RequestEventsResponse,
      responseStream: false,
      options: {},
    },
    /** Update friendship status: REQUEST, ACCEPT, REJECT, CANCEL, DELETE */
    updateFriendshipEvent: {
      name: "UpdateFriendshipEvent",
      requestType: UpdateFriendshipPayload,
      requestStream: false,
      responseType: UpdateFriendshipResponse,
      responseStream: false,
      options: {},
    },
    /** Subscribe to updates of friendship status: REQUEST, ACCEPT, REJECT, CANCEL, DELETE */
    subscribeFriendshipEventsUpdates: {
      name: "SubscribeFriendshipEventsUpdates",
      requestType: Payload,
      requestStream: false,
      responseType: SubscribeFriendshipEventsUpdatesResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
