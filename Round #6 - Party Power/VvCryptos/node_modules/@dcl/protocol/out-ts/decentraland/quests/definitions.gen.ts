/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Empty } from "../../google/protobuf/empty.gen";

export const protobufPackage = "decentraland.quests";

/** Errors */
export interface InvalidQuest {
}

export interface NotUUID {
}

export interface InternalServerError {
}

export interface NotFoundQuestInstance {
}

export interface QuestAlreadyStarted {
}

export interface NotOwner {
}

export interface IgnoredEvent {
}

export interface StartQuestRequest {
  questId: string;
}

export interface StartQuestResponse {
  response?:
    | { $case: "accepted"; accepted: StartQuestResponse_Accepted }
    | { $case: "invalidQuest"; invalidQuest: InvalidQuest }
    | { $case: "notUuidError"; notUuidError: NotUUID }
    | { $case: "internalServerError"; internalServerError: InternalServerError }
    | { $case: "questAlreadyStarted"; questAlreadyStarted: QuestAlreadyStarted }
    | undefined;
}

/**
 * There are a few valid reasons to not be accepted:
 *  - Quest is not found
 *  - Quest is deactivated (the owner deleted it)
 *  - User already started the quest
 *  - Internal errors (DB connection failed or something like that)
 */
export interface StartQuestResponse_Accepted {
}

export interface AbortQuestRequest {
  questInstanceId: string;
}

export interface AbortQuestResponse {
  response?:
    | { $case: "accepted"; accepted: AbortQuestResponse_Accepted }
    | { $case: "notFoundQuestInstance"; notFoundQuestInstance: NotFoundQuestInstance }
    | { $case: "notUuidError"; notUuidError: NotUUID }
    | { $case: "notOwner"; notOwner: NotOwner }
    | { $case: "internalServerError"; internalServerError: InternalServerError }
    | undefined;
}

/**
 * There are a few valid reasons to not be accepted:
 *  - Quest instance is not found
 *  - Quest instance is from another user
 *  - Quest instance already aborted
 *  - Internal errors (DB connection failed or something like that)
 */
export interface AbortQuestResponse_Accepted {
}

export interface Event {
  id: string;
  address: string;
  action: Action | undefined;
}

export interface EventRequest {
  action: Action | undefined;
}

export interface EventResponse {
  response?:
    | { $case: "acceptedEventId"; acceptedEventId: string }
    | { $case: "ignoredEvent"; ignoredEvent: IgnoredEvent }
    | { $case: "internalServerError"; internalServerError: InternalServerError }
    | undefined;
}

export interface QuestDefinition {
  steps: Step[];
  connections: Connection[];
}

export interface Connection {
  stepFrom: string;
  stepTo: string;
}

export interface Step {
  id: string;
  description: string;
  tasks: Task[];
}

export interface Action {
  type: string;
  parameters: { [key: string]: string };
}

export interface Action_ParametersEntry {
  key: string;
  value: string;
}

export interface Task {
  id: string;
  description: string;
  actionItems: Action[];
}

export interface StepContent {
  toDos: Task[];
  tasksCompleted: Task[];
}

export interface QuestState {
  currentSteps: { [key: string]: StepContent };
  stepsLeft: number;
  stepsCompleted: string[];
  requiredSteps: string[];
}

export interface QuestState_CurrentStepsEntry {
  key: string;
  value: StepContent | undefined;
}

export interface Quest {
  id: string;
  name: string;
  description: string;
  definition: QuestDefinition | undefined;
  creatorAddress: string;
  imageUrl: string;
  active: boolean;
  createdAt: number;
}

export interface QuestInstance {
  id: string;
  quest: Quest | undefined;
  state: QuestState | undefined;
}

export interface QuestStateUpdate {
  instanceId: string;
  questState: QuestState | undefined;
  eventId: string;
}

export interface UserUpdate {
  message?:
    | { $case: "subscribed"; subscribed: boolean }
    | { $case: "questStateUpdate"; questStateUpdate: QuestStateUpdate }
    | { $case: "newQuestStarted"; newQuestStarted: QuestInstance }
    | { $case: "eventIgnored"; eventIgnored: string }
    | undefined;
  userAddress: string;
}

export interface Quests {
  instances: QuestInstance[];
}

export interface GetAllQuestsResponse {
  response?: { $case: "quests"; quests: Quests } | {
    $case: "internalServerError";
    internalServerError: InternalServerError;
  } | undefined;
}

export interface GetQuestDefinitionRequest {
  questId: string;
}

export interface GetQuestDefinitionResponse {
  response?: { $case: "quest"; quest: Quest } | {
    $case: "internalServerError";
    internalServerError: InternalServerError;
  } | undefined;
}

function createBaseInvalidQuest(): InvalidQuest {
  return {};
}

export namespace InvalidQuest {
  export function encode(_: InvalidQuest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): InvalidQuest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvalidQuest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): InvalidQuest {
    return {};
  }

  export function toJSON(_: InvalidQuest): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<InvalidQuest>, I>>(base?: I): InvalidQuest {
    return InvalidQuest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<InvalidQuest>, I>>(_: I): InvalidQuest {
    const message = createBaseInvalidQuest();
    return message;
  }
}

function createBaseNotUUID(): NotUUID {
  return {};
}

export namespace NotUUID {
  export function encode(_: NotUUID, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): NotUUID {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotUUID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): NotUUID {
    return {};
  }

  export function toJSON(_: NotUUID): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<NotUUID>, I>>(base?: I): NotUUID {
    return NotUUID.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<NotUUID>, I>>(_: I): NotUUID {
    const message = createBaseNotUUID();
    return message;
  }
}

function createBaseInternalServerError(): InternalServerError {
  return {};
}

export namespace InternalServerError {
  export function encode(_: InternalServerError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): InternalServerError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalServerError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): InternalServerError {
    return {};
  }

  export function toJSON(_: InternalServerError): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<InternalServerError>, I>>(base?: I): InternalServerError {
    return InternalServerError.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<InternalServerError>, I>>(_: I): InternalServerError {
    const message = createBaseInternalServerError();
    return message;
  }
}

function createBaseNotFoundQuestInstance(): NotFoundQuestInstance {
  return {};
}

export namespace NotFoundQuestInstance {
  export function encode(_: NotFoundQuestInstance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): NotFoundQuestInstance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotFoundQuestInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): NotFoundQuestInstance {
    return {};
  }

  export function toJSON(_: NotFoundQuestInstance): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<NotFoundQuestInstance>, I>>(base?: I): NotFoundQuestInstance {
    return NotFoundQuestInstance.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<NotFoundQuestInstance>, I>>(_: I): NotFoundQuestInstance {
    const message = createBaseNotFoundQuestInstance();
    return message;
  }
}

function createBaseQuestAlreadyStarted(): QuestAlreadyStarted {
  return {};
}

export namespace QuestAlreadyStarted {
  export function encode(_: QuestAlreadyStarted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): QuestAlreadyStarted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestAlreadyStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): QuestAlreadyStarted {
    return {};
  }

  export function toJSON(_: QuestAlreadyStarted): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<QuestAlreadyStarted>, I>>(base?: I): QuestAlreadyStarted {
    return QuestAlreadyStarted.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<QuestAlreadyStarted>, I>>(_: I): QuestAlreadyStarted {
    const message = createBaseQuestAlreadyStarted();
    return message;
  }
}

function createBaseNotOwner(): NotOwner {
  return {};
}

export namespace NotOwner {
  export function encode(_: NotOwner, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): NotOwner {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): NotOwner {
    return {};
  }

  export function toJSON(_: NotOwner): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<NotOwner>, I>>(base?: I): NotOwner {
    return NotOwner.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<NotOwner>, I>>(_: I): NotOwner {
    const message = createBaseNotOwner();
    return message;
  }
}

function createBaseIgnoredEvent(): IgnoredEvent {
  return {};
}

export namespace IgnoredEvent {
  export function encode(_: IgnoredEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): IgnoredEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIgnoredEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): IgnoredEvent {
    return {};
  }

  export function toJSON(_: IgnoredEvent): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<IgnoredEvent>, I>>(base?: I): IgnoredEvent {
    return IgnoredEvent.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<IgnoredEvent>, I>>(_: I): IgnoredEvent {
    const message = createBaseIgnoredEvent();
    return message;
  }
}

function createBaseStartQuestRequest(): StartQuestRequest {
  return { questId: "" };
}

export namespace StartQuestRequest {
  export function encode(message: StartQuestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.questId !== "") {
      writer.uint32(10).string(message.questId);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): StartQuestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartQuestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.questId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): StartQuestRequest {
    return { questId: isSet(object.questId) ? String(object.questId) : "" };
  }

  export function toJSON(message: StartQuestRequest): unknown {
    const obj: any = {};
    message.questId !== undefined && (obj.questId = message.questId);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<StartQuestRequest>, I>>(base?: I): StartQuestRequest {
    return StartQuestRequest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<StartQuestRequest>, I>>(object: I): StartQuestRequest {
    const message = createBaseStartQuestRequest();
    message.questId = object.questId ?? "";
    return message;
  }
}

function createBaseStartQuestResponse(): StartQuestResponse {
  return { response: undefined };
}

export namespace StartQuestResponse {
  export function encode(message: StartQuestResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.response?.$case) {
      case "accepted":
        StartQuestResponse_Accepted.encode(message.response.accepted, writer.uint32(10).fork()).ldelim();
        break;
      case "invalidQuest":
        InvalidQuest.encode(message.response.invalidQuest, writer.uint32(18).fork()).ldelim();
        break;
      case "notUuidError":
        NotUUID.encode(message.response.notUuidError, writer.uint32(26).fork()).ldelim();
        break;
      case "internalServerError":
        InternalServerError.encode(message.response.internalServerError, writer.uint32(34).fork()).ldelim();
        break;
      case "questAlreadyStarted":
        QuestAlreadyStarted.encode(message.response.questAlreadyStarted, writer.uint32(42).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): StartQuestResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartQuestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = {
            $case: "accepted",
            accepted: StartQuestResponse_Accepted.decode(reader, reader.uint32()),
          };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = { $case: "invalidQuest", invalidQuest: InvalidQuest.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.response = { $case: "notUuidError", notUuidError: NotUUID.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.response = {
            $case: "internalServerError",
            internalServerError: InternalServerError.decode(reader, reader.uint32()),
          };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.response = {
            $case: "questAlreadyStarted",
            questAlreadyStarted: QuestAlreadyStarted.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): StartQuestResponse {
    return {
      response: isSet(object.accepted)
        ? { $case: "accepted", accepted: StartQuestResponse_Accepted.fromJSON(object.accepted) }
        : isSet(object.invalidQuest)
        ? { $case: "invalidQuest", invalidQuest: InvalidQuest.fromJSON(object.invalidQuest) }
        : isSet(object.notUuidError)
        ? { $case: "notUuidError", notUuidError: NotUUID.fromJSON(object.notUuidError) }
        : isSet(object.internalServerError)
        ? {
          $case: "internalServerError",
          internalServerError: InternalServerError.fromJSON(object.internalServerError),
        }
        : isSet(object.questAlreadyStarted)
        ? {
          $case: "questAlreadyStarted",
          questAlreadyStarted: QuestAlreadyStarted.fromJSON(object.questAlreadyStarted),
        }
        : undefined,
    };
  }

  export function toJSON(message: StartQuestResponse): unknown {
    const obj: any = {};
    message.response?.$case === "accepted" &&
      (obj.accepted = message.response?.accepted
        ? StartQuestResponse_Accepted.toJSON(message.response?.accepted)
        : undefined);
    message.response?.$case === "invalidQuest" &&
      (obj.invalidQuest = message.response?.invalidQuest
        ? InvalidQuest.toJSON(message.response?.invalidQuest)
        : undefined);
    message.response?.$case === "notUuidError" &&
      (obj.notUuidError = message.response?.notUuidError ? NotUUID.toJSON(message.response?.notUuidError) : undefined);
    message.response?.$case === "internalServerError" &&
      (obj.internalServerError = message.response?.internalServerError
        ? InternalServerError.toJSON(message.response?.internalServerError)
        : undefined);
    message.response?.$case === "questAlreadyStarted" &&
      (obj.questAlreadyStarted = message.response?.questAlreadyStarted
        ? QuestAlreadyStarted.toJSON(message.response?.questAlreadyStarted)
        : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<StartQuestResponse>, I>>(base?: I): StartQuestResponse {
    return StartQuestResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<StartQuestResponse>, I>>(object: I): StartQuestResponse {
    const message = createBaseStartQuestResponse();
    if (
      object.response?.$case === "accepted" &&
      object.response?.accepted !== undefined &&
      object.response?.accepted !== null
    ) {
      message.response = {
        $case: "accepted",
        accepted: StartQuestResponse_Accepted.fromPartial(object.response.accepted),
      };
    }
    if (
      object.response?.$case === "invalidQuest" &&
      object.response?.invalidQuest !== undefined &&
      object.response?.invalidQuest !== null
    ) {
      message.response = {
        $case: "invalidQuest",
        invalidQuest: InvalidQuest.fromPartial(object.response.invalidQuest),
      };
    }
    if (
      object.response?.$case === "notUuidError" &&
      object.response?.notUuidError !== undefined &&
      object.response?.notUuidError !== null
    ) {
      message.response = { $case: "notUuidError", notUuidError: NotUUID.fromPartial(object.response.notUuidError) };
    }
    if (
      object.response?.$case === "internalServerError" &&
      object.response?.internalServerError !== undefined &&
      object.response?.internalServerError !== null
    ) {
      message.response = {
        $case: "internalServerError",
        internalServerError: InternalServerError.fromPartial(object.response.internalServerError),
      };
    }
    if (
      object.response?.$case === "questAlreadyStarted" &&
      object.response?.questAlreadyStarted !== undefined &&
      object.response?.questAlreadyStarted !== null
    ) {
      message.response = {
        $case: "questAlreadyStarted",
        questAlreadyStarted: QuestAlreadyStarted.fromPartial(object.response.questAlreadyStarted),
      };
    }
    return message;
  }
}

function createBaseStartQuestResponse_Accepted(): StartQuestResponse_Accepted {
  return {};
}

export namespace StartQuestResponse_Accepted {
  export function encode(_: StartQuestResponse_Accepted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): StartQuestResponse_Accepted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartQuestResponse_Accepted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): StartQuestResponse_Accepted {
    return {};
  }

  export function toJSON(_: StartQuestResponse_Accepted): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<StartQuestResponse_Accepted>, I>>(
    base?: I,
  ): StartQuestResponse_Accepted {
    return StartQuestResponse_Accepted.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<StartQuestResponse_Accepted>, I>>(
    _: I,
  ): StartQuestResponse_Accepted {
    const message = createBaseStartQuestResponse_Accepted();
    return message;
  }
}

function createBaseAbortQuestRequest(): AbortQuestRequest {
  return { questInstanceId: "" };
}

export namespace AbortQuestRequest {
  export function encode(message: AbortQuestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.questInstanceId !== "") {
      writer.uint32(10).string(message.questInstanceId);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): AbortQuestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAbortQuestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.questInstanceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): AbortQuestRequest {
    return { questInstanceId: isSet(object.questInstanceId) ? String(object.questInstanceId) : "" };
  }

  export function toJSON(message: AbortQuestRequest): unknown {
    const obj: any = {};
    message.questInstanceId !== undefined && (obj.questInstanceId = message.questInstanceId);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<AbortQuestRequest>, I>>(base?: I): AbortQuestRequest {
    return AbortQuestRequest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<AbortQuestRequest>, I>>(object: I): AbortQuestRequest {
    const message = createBaseAbortQuestRequest();
    message.questInstanceId = object.questInstanceId ?? "";
    return message;
  }
}

function createBaseAbortQuestResponse(): AbortQuestResponse {
  return { response: undefined };
}

export namespace AbortQuestResponse {
  export function encode(message: AbortQuestResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.response?.$case) {
      case "accepted":
        AbortQuestResponse_Accepted.encode(message.response.accepted, writer.uint32(10).fork()).ldelim();
        break;
      case "notFoundQuestInstance":
        NotFoundQuestInstance.encode(message.response.notFoundQuestInstance, writer.uint32(18).fork()).ldelim();
        break;
      case "notUuidError":
        NotUUID.encode(message.response.notUuidError, writer.uint32(26).fork()).ldelim();
        break;
      case "notOwner":
        NotOwner.encode(message.response.notOwner, writer.uint32(34).fork()).ldelim();
        break;
      case "internalServerError":
        InternalServerError.encode(message.response.internalServerError, writer.uint32(42).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): AbortQuestResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAbortQuestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = {
            $case: "accepted",
            accepted: AbortQuestResponse_Accepted.decode(reader, reader.uint32()),
          };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = {
            $case: "notFoundQuestInstance",
            notFoundQuestInstance: NotFoundQuestInstance.decode(reader, reader.uint32()),
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.response = { $case: "notUuidError", notUuidError: NotUUID.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.response = { $case: "notOwner", notOwner: NotOwner.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.response = {
            $case: "internalServerError",
            internalServerError: InternalServerError.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): AbortQuestResponse {
    return {
      response: isSet(object.accepted)
        ? { $case: "accepted", accepted: AbortQuestResponse_Accepted.fromJSON(object.accepted) }
        : isSet(object.notFoundQuestInstance)
        ? {
          $case: "notFoundQuestInstance",
          notFoundQuestInstance: NotFoundQuestInstance.fromJSON(object.notFoundQuestInstance),
        }
        : isSet(object.notUuidError)
        ? { $case: "notUuidError", notUuidError: NotUUID.fromJSON(object.notUuidError) }
        : isSet(object.notOwner)
        ? { $case: "notOwner", notOwner: NotOwner.fromJSON(object.notOwner) }
        : isSet(object.internalServerError)
        ? {
          $case: "internalServerError",
          internalServerError: InternalServerError.fromJSON(object.internalServerError),
        }
        : undefined,
    };
  }

  export function toJSON(message: AbortQuestResponse): unknown {
    const obj: any = {};
    message.response?.$case === "accepted" &&
      (obj.accepted = message.response?.accepted
        ? AbortQuestResponse_Accepted.toJSON(message.response?.accepted)
        : undefined);
    message.response?.$case === "notFoundQuestInstance" &&
      (obj.notFoundQuestInstance = message.response?.notFoundQuestInstance
        ? NotFoundQuestInstance.toJSON(message.response?.notFoundQuestInstance)
        : undefined);
    message.response?.$case === "notUuidError" &&
      (obj.notUuidError = message.response?.notUuidError ? NotUUID.toJSON(message.response?.notUuidError) : undefined);
    message.response?.$case === "notOwner" &&
      (obj.notOwner = message.response?.notOwner ? NotOwner.toJSON(message.response?.notOwner) : undefined);
    message.response?.$case === "internalServerError" &&
      (obj.internalServerError = message.response?.internalServerError
        ? InternalServerError.toJSON(message.response?.internalServerError)
        : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<AbortQuestResponse>, I>>(base?: I): AbortQuestResponse {
    return AbortQuestResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<AbortQuestResponse>, I>>(object: I): AbortQuestResponse {
    const message = createBaseAbortQuestResponse();
    if (
      object.response?.$case === "accepted" &&
      object.response?.accepted !== undefined &&
      object.response?.accepted !== null
    ) {
      message.response = {
        $case: "accepted",
        accepted: AbortQuestResponse_Accepted.fromPartial(object.response.accepted),
      };
    }
    if (
      object.response?.$case === "notFoundQuestInstance" &&
      object.response?.notFoundQuestInstance !== undefined &&
      object.response?.notFoundQuestInstance !== null
    ) {
      message.response = {
        $case: "notFoundQuestInstance",
        notFoundQuestInstance: NotFoundQuestInstance.fromPartial(object.response.notFoundQuestInstance),
      };
    }
    if (
      object.response?.$case === "notUuidError" &&
      object.response?.notUuidError !== undefined &&
      object.response?.notUuidError !== null
    ) {
      message.response = { $case: "notUuidError", notUuidError: NotUUID.fromPartial(object.response.notUuidError) };
    }
    if (
      object.response?.$case === "notOwner" &&
      object.response?.notOwner !== undefined &&
      object.response?.notOwner !== null
    ) {
      message.response = { $case: "notOwner", notOwner: NotOwner.fromPartial(object.response.notOwner) };
    }
    if (
      object.response?.$case === "internalServerError" &&
      object.response?.internalServerError !== undefined &&
      object.response?.internalServerError !== null
    ) {
      message.response = {
        $case: "internalServerError",
        internalServerError: InternalServerError.fromPartial(object.response.internalServerError),
      };
    }
    return message;
  }
}

function createBaseAbortQuestResponse_Accepted(): AbortQuestResponse_Accepted {
  return {};
}

export namespace AbortQuestResponse_Accepted {
  export function encode(_: AbortQuestResponse_Accepted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): AbortQuestResponse_Accepted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAbortQuestResponse_Accepted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(_: any): AbortQuestResponse_Accepted {
    return {};
  }

  export function toJSON(_: AbortQuestResponse_Accepted): unknown {
    const obj: any = {};
    return obj;
  }

  export function create<I extends Exact<DeepPartial<AbortQuestResponse_Accepted>, I>>(
    base?: I,
  ): AbortQuestResponse_Accepted {
    return AbortQuestResponse_Accepted.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<AbortQuestResponse_Accepted>, I>>(
    _: I,
  ): AbortQuestResponse_Accepted {
    const message = createBaseAbortQuestResponse_Accepted();
    return message;
  }
}

function createBaseEvent(): Event {
  return { id: "", address: "", action: undefined };
}

export namespace Event {
  export function encode(message: Event, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.action !== undefined) {
      Action.encode(message.action, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Event {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.action = Action.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Event {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      address: isSet(object.address) ? String(object.address) : "",
      action: isSet(object.action) ? Action.fromJSON(object.action) : undefined,
    };
  }

  export function toJSON(message: Event): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.address !== undefined && (obj.address = message.address);
    message.action !== undefined && (obj.action = message.action ? Action.toJSON(message.action) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.id = object.id ?? "";
    message.address = object.address ?? "";
    message.action = (object.action !== undefined && object.action !== null)
      ? Action.fromPartial(object.action)
      : undefined;
    return message;
  }
}

function createBaseEventRequest(): EventRequest {
  return { action: undefined };
}

export namespace EventRequest {
  export function encode(message: EventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.action !== undefined) {
      Action.encode(message.action, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): EventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.action = Action.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): EventRequest {
    return { action: isSet(object.action) ? Action.fromJSON(object.action) : undefined };
  }

  export function toJSON(message: EventRequest): unknown {
    const obj: any = {};
    message.action !== undefined && (obj.action = message.action ? Action.toJSON(message.action) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<EventRequest>, I>>(base?: I): EventRequest {
    return EventRequest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<EventRequest>, I>>(object: I): EventRequest {
    const message = createBaseEventRequest();
    message.action = (object.action !== undefined && object.action !== null)
      ? Action.fromPartial(object.action)
      : undefined;
    return message;
  }
}

function createBaseEventResponse(): EventResponse {
  return { response: undefined };
}

export namespace EventResponse {
  export function encode(message: EventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.response?.$case) {
      case "acceptedEventId":
        writer.uint32(10).string(message.response.acceptedEventId);
        break;
      case "ignoredEvent":
        IgnoredEvent.encode(message.response.ignoredEvent, writer.uint32(18).fork()).ldelim();
        break;
      case "internalServerError":
        InternalServerError.encode(message.response.internalServerError, writer.uint32(26).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): EventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = { $case: "acceptedEventId", acceptedEventId: reader.string() };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = { $case: "ignoredEvent", ignoredEvent: IgnoredEvent.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.response = {
            $case: "internalServerError",
            internalServerError: InternalServerError.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): EventResponse {
    return {
      response: isSet(object.acceptedEventId)
        ? { $case: "acceptedEventId", acceptedEventId: String(object.acceptedEventId) }
        : isSet(object.ignoredEvent)
        ? { $case: "ignoredEvent", ignoredEvent: IgnoredEvent.fromJSON(object.ignoredEvent) }
        : isSet(object.internalServerError)
        ? {
          $case: "internalServerError",
          internalServerError: InternalServerError.fromJSON(object.internalServerError),
        }
        : undefined,
    };
  }

  export function toJSON(message: EventResponse): unknown {
    const obj: any = {};
    message.response?.$case === "acceptedEventId" && (obj.acceptedEventId = message.response?.acceptedEventId);
    message.response?.$case === "ignoredEvent" &&
      (obj.ignoredEvent = message.response?.ignoredEvent
        ? IgnoredEvent.toJSON(message.response?.ignoredEvent)
        : undefined);
    message.response?.$case === "internalServerError" &&
      (obj.internalServerError = message.response?.internalServerError
        ? InternalServerError.toJSON(message.response?.internalServerError)
        : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<EventResponse>, I>>(base?: I): EventResponse {
    return EventResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<EventResponse>, I>>(object: I): EventResponse {
    const message = createBaseEventResponse();
    if (
      object.response?.$case === "acceptedEventId" &&
      object.response?.acceptedEventId !== undefined &&
      object.response?.acceptedEventId !== null
    ) {
      message.response = { $case: "acceptedEventId", acceptedEventId: object.response.acceptedEventId };
    }
    if (
      object.response?.$case === "ignoredEvent" &&
      object.response?.ignoredEvent !== undefined &&
      object.response?.ignoredEvent !== null
    ) {
      message.response = {
        $case: "ignoredEvent",
        ignoredEvent: IgnoredEvent.fromPartial(object.response.ignoredEvent),
      };
    }
    if (
      object.response?.$case === "internalServerError" &&
      object.response?.internalServerError !== undefined &&
      object.response?.internalServerError !== null
    ) {
      message.response = {
        $case: "internalServerError",
        internalServerError: InternalServerError.fromPartial(object.response.internalServerError),
      };
    }
    return message;
  }
}

function createBaseQuestDefinition(): QuestDefinition {
  return { steps: [], connections: [] };
}

export namespace QuestDefinition {
  export function encode(message: QuestDefinition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.steps) {
      Step.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.connections) {
      Connection.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): QuestDefinition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.steps.push(Step.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connections.push(Connection.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): QuestDefinition {
    return {
      steps: Array.isArray(object?.steps) ? object.steps.map((e: any) => Step.fromJSON(e)) : [],
      connections: Array.isArray(object?.connections) ? object.connections.map((e: any) => Connection.fromJSON(e)) : [],
    };
  }

  export function toJSON(message: QuestDefinition): unknown {
    const obj: any = {};
    if (message.steps) {
      obj.steps = message.steps.map((e) => e ? Step.toJSON(e) : undefined);
    } else {
      obj.steps = [];
    }
    if (message.connections) {
      obj.connections = message.connections.map((e) => e ? Connection.toJSON(e) : undefined);
    } else {
      obj.connections = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<QuestDefinition>, I>>(base?: I): QuestDefinition {
    return QuestDefinition.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<QuestDefinition>, I>>(object: I): QuestDefinition {
    const message = createBaseQuestDefinition();
    message.steps = object.steps?.map((e) => Step.fromPartial(e)) || [];
    message.connections = object.connections?.map((e) => Connection.fromPartial(e)) || [];
    return message;
  }
}

function createBaseConnection(): Connection {
  return { stepFrom: "", stepTo: "" };
}

export namespace Connection {
  export function encode(message: Connection, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stepFrom !== "") {
      writer.uint32(10).string(message.stepFrom);
    }
    if (message.stepTo !== "") {
      writer.uint32(18).string(message.stepTo);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Connection {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stepFrom = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepTo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Connection {
    return {
      stepFrom: isSet(object.stepFrom) ? String(object.stepFrom) : "",
      stepTo: isSet(object.stepTo) ? String(object.stepTo) : "",
    };
  }

  export function toJSON(message: Connection): unknown {
    const obj: any = {};
    message.stepFrom !== undefined && (obj.stepFrom = message.stepFrom);
    message.stepTo !== undefined && (obj.stepTo = message.stepTo);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Connection>, I>>(base?: I): Connection {
    return Connection.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Connection>, I>>(object: I): Connection {
    const message = createBaseConnection();
    message.stepFrom = object.stepFrom ?? "";
    message.stepTo = object.stepTo ?? "";
    return message;
  }
}

function createBaseStep(): Step {
  return { id: "", description: "", tasks: [] };
}

export namespace Step {
  export function encode(message: Step, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Step {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Step {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      description: isSet(object.description) ? String(object.description) : "",
      tasks: Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [],
    };
  }

  export function toJSON(message: Step): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.description !== undefined && (obj.description = message.description);
    if (message.tasks) {
      obj.tasks = message.tasks.map((e) => e ? Task.toJSON(e) : undefined);
    } else {
      obj.tasks = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Step>, I>>(base?: I): Step {
    return Step.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Step>, I>>(object: I): Step {
    const message = createBaseStep();
    message.id = object.id ?? "";
    message.description = object.description ?? "";
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    return message;
  }
}

function createBaseAction(): Action {
  return { type: "", parameters: {} };
}

export namespace Action {
  export function encode(message: Action, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      Action_ParametersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Action {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Action_ParametersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.parameters[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Action {
    return {
      type: isSet(object.type) ? String(object.type) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  }

  export function toJSON(message: Action): unknown {
    const obj: any = {};
    message.type !== undefined && (obj.type = message.type);
    obj.parameters = {};
    if (message.parameters) {
      Object.entries(message.parameters).forEach(([k, v]) => {
        obj.parameters[k] = v;
      });
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Action>, I>>(base?: I): Action {
    return Action.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Action>, I>>(object: I): Action {
    const message = createBaseAction();
    message.type = object.type ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  }
}

function createBaseAction_ParametersEntry(): Action_ParametersEntry {
  return { key: "", value: "" };
}

export namespace Action_ParametersEntry {
  export function encode(message: Action_ParametersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Action_ParametersEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Action_ParametersEntry {
    return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
  }

  export function toJSON(message: Action_ParametersEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Action_ParametersEntry>, I>>(base?: I): Action_ParametersEntry {
    return Action_ParametersEntry.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Action_ParametersEntry>, I>>(
    object: I,
  ): Action_ParametersEntry {
    const message = createBaseAction_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
}

function createBaseTask(): Task {
  return { id: "", description: "", actionItems: [] };
}

export namespace Task {
  export function encode(message: Task, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.actionItems) {
      Action.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Task {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actionItems.push(Action.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Task {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      description: isSet(object.description) ? String(object.description) : "",
      actionItems: Array.isArray(object?.actionItems) ? object.actionItems.map((e: any) => Action.fromJSON(e)) : [],
    };
  }

  export function toJSON(message: Task): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.description !== undefined && (obj.description = message.description);
    if (message.actionItems) {
      obj.actionItems = message.actionItems.map((e) => e ? Action.toJSON(e) : undefined);
    } else {
      obj.actionItems = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Task>, I>>(base?: I): Task {
    return Task.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Task>, I>>(object: I): Task {
    const message = createBaseTask();
    message.id = object.id ?? "";
    message.description = object.description ?? "";
    message.actionItems = object.actionItems?.map((e) => Action.fromPartial(e)) || [];
    return message;
  }
}

function createBaseStepContent(): StepContent {
  return { toDos: [], tasksCompleted: [] };
}

export namespace StepContent {
  export function encode(message: StepContent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.toDos) {
      Task.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.tasksCompleted) {
      Task.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): StepContent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toDos.push(Task.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tasksCompleted.push(Task.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): StepContent {
    return {
      toDos: Array.isArray(object?.toDos) ? object.toDos.map((e: any) => Task.fromJSON(e)) : [],
      tasksCompleted: Array.isArray(object?.tasksCompleted)
        ? object.tasksCompleted.map((e: any) => Task.fromJSON(e))
        : [],
    };
  }

  export function toJSON(message: StepContent): unknown {
    const obj: any = {};
    if (message.toDos) {
      obj.toDos = message.toDos.map((e) => e ? Task.toJSON(e) : undefined);
    } else {
      obj.toDos = [];
    }
    if (message.tasksCompleted) {
      obj.tasksCompleted = message.tasksCompleted.map((e) => e ? Task.toJSON(e) : undefined);
    } else {
      obj.tasksCompleted = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<StepContent>, I>>(base?: I): StepContent {
    return StepContent.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<StepContent>, I>>(object: I): StepContent {
    const message = createBaseStepContent();
    message.toDos = object.toDos?.map((e) => Task.fromPartial(e)) || [];
    message.tasksCompleted = object.tasksCompleted?.map((e) => Task.fromPartial(e)) || [];
    return message;
  }
}

function createBaseQuestState(): QuestState {
  return { currentSteps: {}, stepsLeft: 0, stepsCompleted: [], requiredSteps: [] };
}

export namespace QuestState {
  export function encode(message: QuestState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.currentSteps).forEach(([key, value]) => {
      QuestState_CurrentStepsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.stepsLeft !== 0) {
      writer.uint32(29).fixed32(message.stepsLeft);
    }
    for (const v of message.stepsCompleted) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.requiredSteps) {
      writer.uint32(42).string(v!);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): QuestState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = QuestState_CurrentStepsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.currentSteps[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.stepsLeft = reader.fixed32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stepsCompleted.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requiredSteps.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): QuestState {
    return {
      currentSteps: isObject(object.currentSteps)
        ? Object.entries(object.currentSteps).reduce<{ [key: string]: StepContent }>((acc, [key, value]) => {
          acc[key] = StepContent.fromJSON(value);
          return acc;
        }, {})
        : {},
      stepsLeft: isSet(object.stepsLeft) ? Number(object.stepsLeft) : 0,
      stepsCompleted: Array.isArray(object?.stepsCompleted) ? object.stepsCompleted.map((e: any) => String(e)) : [],
      requiredSteps: Array.isArray(object?.requiredSteps) ? object.requiredSteps.map((e: any) => String(e)) : [],
    };
  }

  export function toJSON(message: QuestState): unknown {
    const obj: any = {};
    obj.currentSteps = {};
    if (message.currentSteps) {
      Object.entries(message.currentSteps).forEach(([k, v]) => {
        obj.currentSteps[k] = StepContent.toJSON(v);
      });
    }
    message.stepsLeft !== undefined && (obj.stepsLeft = Math.round(message.stepsLeft));
    if (message.stepsCompleted) {
      obj.stepsCompleted = message.stepsCompleted.map((e) => e);
    } else {
      obj.stepsCompleted = [];
    }
    if (message.requiredSteps) {
      obj.requiredSteps = message.requiredSteps.map((e) => e);
    } else {
      obj.requiredSteps = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<QuestState>, I>>(base?: I): QuestState {
    return QuestState.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<QuestState>, I>>(object: I): QuestState {
    const message = createBaseQuestState();
    message.currentSteps = Object.entries(object.currentSteps ?? {}).reduce<{ [key: string]: StepContent }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = StepContent.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.stepsLeft = object.stepsLeft ?? 0;
    message.stepsCompleted = object.stepsCompleted?.map((e) => e) || [];
    message.requiredSteps = object.requiredSteps?.map((e) => e) || [];
    return message;
  }
}

function createBaseQuestState_CurrentStepsEntry(): QuestState_CurrentStepsEntry {
  return { key: "", value: undefined };
}

export namespace QuestState_CurrentStepsEntry {
  export function encode(message: QuestState_CurrentStepsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      StepContent.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): QuestState_CurrentStepsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestState_CurrentStepsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = StepContent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): QuestState_CurrentStepsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? StepContent.fromJSON(object.value) : undefined,
    };
  }

  export function toJSON(message: QuestState_CurrentStepsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? StepContent.toJSON(message.value) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<QuestState_CurrentStepsEntry>, I>>(
    base?: I,
  ): QuestState_CurrentStepsEntry {
    return QuestState_CurrentStepsEntry.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<QuestState_CurrentStepsEntry>, I>>(
    object: I,
  ): QuestState_CurrentStepsEntry {
    const message = createBaseQuestState_CurrentStepsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? StepContent.fromPartial(object.value)
      : undefined;
    return message;
  }
}

function createBaseQuest(): Quest {
  return {
    id: "",
    name: "",
    description: "",
    definition: undefined,
    creatorAddress: "",
    imageUrl: "",
    active: false,
    createdAt: 0,
  };
}

export namespace Quest {
  export function encode(message: Quest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.definition !== undefined) {
      QuestDefinition.encode(message.definition, writer.uint32(34).fork()).ldelim();
    }
    if (message.creatorAddress !== "") {
      writer.uint32(42).string(message.creatorAddress);
    }
    if (message.imageUrl !== "") {
      writer.uint32(50).string(message.imageUrl);
    }
    if (message.active === true) {
      writer.uint32(56).bool(message.active);
    }
    if (message.createdAt !== 0) {
      writer.uint32(69).fixed32(message.createdAt);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Quest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.definition = QuestDefinition.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creatorAddress = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.active = reader.bool();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.createdAt = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Quest {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
      definition: isSet(object.definition) ? QuestDefinition.fromJSON(object.definition) : undefined,
      creatorAddress: isSet(object.creatorAddress) ? String(object.creatorAddress) : "",
      imageUrl: isSet(object.imageUrl) ? String(object.imageUrl) : "",
      active: isSet(object.active) ? Boolean(object.active) : false,
      createdAt: isSet(object.createdAt) ? Number(object.createdAt) : 0,
    };
  }

  export function toJSON(message: Quest): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.name !== undefined && (obj.name = message.name);
    message.description !== undefined && (obj.description = message.description);
    message.definition !== undefined &&
      (obj.definition = message.definition ? QuestDefinition.toJSON(message.definition) : undefined);
    message.creatorAddress !== undefined && (obj.creatorAddress = message.creatorAddress);
    message.imageUrl !== undefined && (obj.imageUrl = message.imageUrl);
    message.active !== undefined && (obj.active = message.active);
    message.createdAt !== undefined && (obj.createdAt = Math.round(message.createdAt));
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Quest>, I>>(base?: I): Quest {
    return Quest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Quest>, I>>(object: I): Quest {
    const message = createBaseQuest();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.definition = (object.definition !== undefined && object.definition !== null)
      ? QuestDefinition.fromPartial(object.definition)
      : undefined;
    message.creatorAddress = object.creatorAddress ?? "";
    message.imageUrl = object.imageUrl ?? "";
    message.active = object.active ?? false;
    message.createdAt = object.createdAt ?? 0;
    return message;
  }
}

function createBaseQuestInstance(): QuestInstance {
  return { id: "", quest: undefined, state: undefined };
}

export namespace QuestInstance {
  export function encode(message: QuestInstance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.quest !== undefined) {
      Quest.encode(message.quest, writer.uint32(18).fork()).ldelim();
    }
    if (message.state !== undefined) {
      QuestState.encode(message.state, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): QuestInstance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quest = Quest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.state = QuestState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): QuestInstance {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      quest: isSet(object.quest) ? Quest.fromJSON(object.quest) : undefined,
      state: isSet(object.state) ? QuestState.fromJSON(object.state) : undefined,
    };
  }

  export function toJSON(message: QuestInstance): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.quest !== undefined && (obj.quest = message.quest ? Quest.toJSON(message.quest) : undefined);
    message.state !== undefined && (obj.state = message.state ? QuestState.toJSON(message.state) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<QuestInstance>, I>>(base?: I): QuestInstance {
    return QuestInstance.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<QuestInstance>, I>>(object: I): QuestInstance {
    const message = createBaseQuestInstance();
    message.id = object.id ?? "";
    message.quest = (object.quest !== undefined && object.quest !== null) ? Quest.fromPartial(object.quest) : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? QuestState.fromPartial(object.state)
      : undefined;
    return message;
  }
}

function createBaseQuestStateUpdate(): QuestStateUpdate {
  return { instanceId: "", questState: undefined, eventId: "" };
}

export namespace QuestStateUpdate {
  export function encode(message: QuestStateUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.questState !== undefined) {
      QuestState.encode(message.questState, writer.uint32(18).fork()).ldelim();
    }
    if (message.eventId !== "") {
      writer.uint32(26).string(message.eventId);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): QuestStateUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestStateUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.questState = QuestState.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): QuestStateUpdate {
    return {
      instanceId: isSet(object.instanceId) ? String(object.instanceId) : "",
      questState: isSet(object.questState) ? QuestState.fromJSON(object.questState) : undefined,
      eventId: isSet(object.eventId) ? String(object.eventId) : "",
    };
  }

  export function toJSON(message: QuestStateUpdate): unknown {
    const obj: any = {};
    message.instanceId !== undefined && (obj.instanceId = message.instanceId);
    message.questState !== undefined &&
      (obj.questState = message.questState ? QuestState.toJSON(message.questState) : undefined);
    message.eventId !== undefined && (obj.eventId = message.eventId);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<QuestStateUpdate>, I>>(base?: I): QuestStateUpdate {
    return QuestStateUpdate.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<QuestStateUpdate>, I>>(object: I): QuestStateUpdate {
    const message = createBaseQuestStateUpdate();
    message.instanceId = object.instanceId ?? "";
    message.questState = (object.questState !== undefined && object.questState !== null)
      ? QuestState.fromPartial(object.questState)
      : undefined;
    message.eventId = object.eventId ?? "";
    return message;
  }
}

function createBaseUserUpdate(): UserUpdate {
  return { message: undefined, userAddress: "" };
}

export namespace UserUpdate {
  export function encode(message: UserUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.message?.$case) {
      case "subscribed":
        writer.uint32(8).bool(message.message.subscribed);
        break;
      case "questStateUpdate":
        QuestStateUpdate.encode(message.message.questStateUpdate, writer.uint32(18).fork()).ldelim();
        break;
      case "newQuestStarted":
        QuestInstance.encode(message.message.newQuestStarted, writer.uint32(26).fork()).ldelim();
        break;
      case "eventIgnored":
        writer.uint32(34).string(message.message.eventIgnored);
        break;
    }
    if (message.userAddress !== "") {
      writer.uint32(42).string(message.userAddress);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): UserUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.message = { $case: "subscribed", subscribed: reader.bool() };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = {
            $case: "questStateUpdate",
            questStateUpdate: QuestStateUpdate.decode(reader, reader.uint32()),
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = {
            $case: "newQuestStarted",
            newQuestStarted: QuestInstance.decode(reader, reader.uint32()),
          };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = { $case: "eventIgnored", eventIgnored: reader.string() };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.userAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): UserUpdate {
    return {
      message: isSet(object.subscribed)
        ? { $case: "subscribed", subscribed: Boolean(object.subscribed) }
        : isSet(object.questStateUpdate)
        ? { $case: "questStateUpdate", questStateUpdate: QuestStateUpdate.fromJSON(object.questStateUpdate) }
        : isSet(object.newQuestStarted)
        ? { $case: "newQuestStarted", newQuestStarted: QuestInstance.fromJSON(object.newQuestStarted) }
        : isSet(object.eventIgnored)
        ? { $case: "eventIgnored", eventIgnored: String(object.eventIgnored) }
        : undefined,
      userAddress: isSet(object.userAddress) ? String(object.userAddress) : "",
    };
  }

  export function toJSON(message: UserUpdate): unknown {
    const obj: any = {};
    message.message?.$case === "subscribed" && (obj.subscribed = message.message?.subscribed);
    message.message?.$case === "questStateUpdate" &&
      (obj.questStateUpdate = message.message?.questStateUpdate
        ? QuestStateUpdate.toJSON(message.message?.questStateUpdate)
        : undefined);
    message.message?.$case === "newQuestStarted" &&
      (obj.newQuestStarted = message.message?.newQuestStarted
        ? QuestInstance.toJSON(message.message?.newQuestStarted)
        : undefined);
    message.message?.$case === "eventIgnored" && (obj.eventIgnored = message.message?.eventIgnored);
    message.userAddress !== undefined && (obj.userAddress = message.userAddress);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<UserUpdate>, I>>(base?: I): UserUpdate {
    return UserUpdate.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<UserUpdate>, I>>(object: I): UserUpdate {
    const message = createBaseUserUpdate();
    if (
      object.message?.$case === "subscribed" &&
      object.message?.subscribed !== undefined &&
      object.message?.subscribed !== null
    ) {
      message.message = { $case: "subscribed", subscribed: object.message.subscribed };
    }
    if (
      object.message?.$case === "questStateUpdate" &&
      object.message?.questStateUpdate !== undefined &&
      object.message?.questStateUpdate !== null
    ) {
      message.message = {
        $case: "questStateUpdate",
        questStateUpdate: QuestStateUpdate.fromPartial(object.message.questStateUpdate),
      };
    }
    if (
      object.message?.$case === "newQuestStarted" &&
      object.message?.newQuestStarted !== undefined &&
      object.message?.newQuestStarted !== null
    ) {
      message.message = {
        $case: "newQuestStarted",
        newQuestStarted: QuestInstance.fromPartial(object.message.newQuestStarted),
      };
    }
    if (
      object.message?.$case === "eventIgnored" &&
      object.message?.eventIgnored !== undefined &&
      object.message?.eventIgnored !== null
    ) {
      message.message = { $case: "eventIgnored", eventIgnored: object.message.eventIgnored };
    }
    message.userAddress = object.userAddress ?? "";
    return message;
  }
}

function createBaseQuests(): Quests {
  return { instances: [] };
}

export namespace Quests {
  export function encode(message: Quests, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.instances) {
      QuestInstance.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Quests {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuests();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instances.push(QuestInstance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Quests {
    return {
      instances: Array.isArray(object?.instances) ? object.instances.map((e: any) => QuestInstance.fromJSON(e)) : [],
    };
  }

  export function toJSON(message: Quests): unknown {
    const obj: any = {};
    if (message.instances) {
      obj.instances = message.instances.map((e) => e ? QuestInstance.toJSON(e) : undefined);
    } else {
      obj.instances = [];
    }
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Quests>, I>>(base?: I): Quests {
    return Quests.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Quests>, I>>(object: I): Quests {
    const message = createBaseQuests();
    message.instances = object.instances?.map((e) => QuestInstance.fromPartial(e)) || [];
    return message;
  }
}

function createBaseGetAllQuestsResponse(): GetAllQuestsResponse {
  return { response: undefined };
}

export namespace GetAllQuestsResponse {
  export function encode(message: GetAllQuestsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.response?.$case) {
      case "quests":
        Quests.encode(message.response.quests, writer.uint32(10).fork()).ldelim();
        break;
      case "internalServerError":
        InternalServerError.encode(message.response.internalServerError, writer.uint32(18).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): GetAllQuestsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllQuestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = { $case: "quests", quests: Quests.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = {
            $case: "internalServerError",
            internalServerError: InternalServerError.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): GetAllQuestsResponse {
    return {
      response: isSet(object.quests)
        ? { $case: "quests", quests: Quests.fromJSON(object.quests) }
        : isSet(object.internalServerError)
        ? {
          $case: "internalServerError",
          internalServerError: InternalServerError.fromJSON(object.internalServerError),
        }
        : undefined,
    };
  }

  export function toJSON(message: GetAllQuestsResponse): unknown {
    const obj: any = {};
    message.response?.$case === "quests" &&
      (obj.quests = message.response?.quests ? Quests.toJSON(message.response?.quests) : undefined);
    message.response?.$case === "internalServerError" &&
      (obj.internalServerError = message.response?.internalServerError
        ? InternalServerError.toJSON(message.response?.internalServerError)
        : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<GetAllQuestsResponse>, I>>(base?: I): GetAllQuestsResponse {
    return GetAllQuestsResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<GetAllQuestsResponse>, I>>(object: I): GetAllQuestsResponse {
    const message = createBaseGetAllQuestsResponse();
    if (
      object.response?.$case === "quests" && object.response?.quests !== undefined && object.response?.quests !== null
    ) {
      message.response = { $case: "quests", quests: Quests.fromPartial(object.response.quests) };
    }
    if (
      object.response?.$case === "internalServerError" &&
      object.response?.internalServerError !== undefined &&
      object.response?.internalServerError !== null
    ) {
      message.response = {
        $case: "internalServerError",
        internalServerError: InternalServerError.fromPartial(object.response.internalServerError),
      };
    }
    return message;
  }
}

function createBaseGetQuestDefinitionRequest(): GetQuestDefinitionRequest {
  return { questId: "" };
}

export namespace GetQuestDefinitionRequest {
  export function encode(message: GetQuestDefinitionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.questId !== "") {
      writer.uint32(10).string(message.questId);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): GetQuestDefinitionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestDefinitionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.questId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): GetQuestDefinitionRequest {
    return { questId: isSet(object.questId) ? String(object.questId) : "" };
  }

  export function toJSON(message: GetQuestDefinitionRequest): unknown {
    const obj: any = {};
    message.questId !== undefined && (obj.questId = message.questId);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<GetQuestDefinitionRequest>, I>>(
    base?: I,
  ): GetQuestDefinitionRequest {
    return GetQuestDefinitionRequest.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<GetQuestDefinitionRequest>, I>>(
    object: I,
  ): GetQuestDefinitionRequest {
    const message = createBaseGetQuestDefinitionRequest();
    message.questId = object.questId ?? "";
    return message;
  }
}

function createBaseGetQuestDefinitionResponse(): GetQuestDefinitionResponse {
  return { response: undefined };
}

export namespace GetQuestDefinitionResponse {
  export function encode(message: GetQuestDefinitionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.response?.$case) {
      case "quest":
        Quest.encode(message.response.quest, writer.uint32(10).fork()).ldelim();
        break;
      case "internalServerError":
        InternalServerError.encode(message.response.internalServerError, writer.uint32(18).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): GetQuestDefinitionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestDefinitionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = { $case: "quest", quest: Quest.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = {
            $case: "internalServerError",
            internalServerError: InternalServerError.decode(reader, reader.uint32()),
          };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): GetQuestDefinitionResponse {
    return {
      response: isSet(object.quest)
        ? { $case: "quest", quest: Quest.fromJSON(object.quest) }
        : isSet(object.internalServerError)
        ? {
          $case: "internalServerError",
          internalServerError: InternalServerError.fromJSON(object.internalServerError),
        }
        : undefined,
    };
  }

  export function toJSON(message: GetQuestDefinitionResponse): unknown {
    const obj: any = {};
    message.response?.$case === "quest" &&
      (obj.quest = message.response?.quest ? Quest.toJSON(message.response?.quest) : undefined);
    message.response?.$case === "internalServerError" &&
      (obj.internalServerError = message.response?.internalServerError
        ? InternalServerError.toJSON(message.response?.internalServerError)
        : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<GetQuestDefinitionResponse>, I>>(
    base?: I,
  ): GetQuestDefinitionResponse {
    return GetQuestDefinitionResponse.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<GetQuestDefinitionResponse>, I>>(
    object: I,
  ): GetQuestDefinitionResponse {
    const message = createBaseGetQuestDefinitionResponse();
    if (object.response?.$case === "quest" && object.response?.quest !== undefined && object.response?.quest !== null) {
      message.response = { $case: "quest", quest: Quest.fromPartial(object.response.quest) };
    }
    if (
      object.response?.$case === "internalServerError" &&
      object.response?.internalServerError !== undefined &&
      object.response?.internalServerError !== null
    ) {
      message.response = {
        $case: "internalServerError",
        internalServerError: InternalServerError.fromPartial(object.response.internalServerError),
      };
    }
    return message;
  }
}

export type QuestsServiceDefinition = typeof QuestsServiceDefinition;
export const QuestsServiceDefinition = {
  name: "QuestsService",
  fullName: "decentraland.quests.QuestsService",
  methods: {
    /** User actions */
    startQuest: {
      name: "StartQuest",
      requestType: StartQuestRequest,
      requestStream: false,
      responseType: StartQuestResponse,
      responseStream: false,
      options: {},
    },
    abortQuest: {
      name: "AbortQuest",
      requestType: AbortQuestRequest,
      requestStream: false,
      responseType: AbortQuestResponse,
      responseStream: false,
      options: {},
    },
    sendEvent: {
      name: "SendEvent",
      requestType: EventRequest,
      requestStream: false,
      responseType: EventResponse,
      responseStream: false,
      options: {},
    },
    /** Listen to changes in quest states and event processing updates */
    subscribe: {
      name: "Subscribe",
      requestType: Empty,
      requestStream: false,
      responseType: UserUpdate,
      responseStream: true,
      options: {},
    },
    /** Query quest information */
    getAllQuests: {
      name: "GetAllQuests",
      requestType: Empty,
      requestStream: false,
      responseType: GetAllQuestsResponse,
      responseStream: false,
      options: {},
    },
    getQuestDefinition: {
      name: "GetQuestDefinition",
      requestType: GetQuestDefinitionRequest,
      requestStream: false,
      responseType: GetQuestDefinitionResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
