/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Vector2 } from "./vectors.gen";

export const protobufPackage = "decentraland.common";

export enum TextureWrapMode {
  TWM_REPEAT = 0,
  TWM_CLAMP = 1,
  TWM_MIRROR = 2,
  UNRECOGNIZED = -1,
}

export function textureWrapModeFromJSON(object: any): TextureWrapMode {
  switch (object) {
    case 0:
    case "TWM_REPEAT":
      return TextureWrapMode.TWM_REPEAT;
    case 1:
    case "TWM_CLAMP":
      return TextureWrapMode.TWM_CLAMP;
    case 2:
    case "TWM_MIRROR":
      return TextureWrapMode.TWM_MIRROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TextureWrapMode.UNRECOGNIZED;
  }
}

export function textureWrapModeToJSON(object: TextureWrapMode): string {
  switch (object) {
    case TextureWrapMode.TWM_REPEAT:
      return "TWM_REPEAT";
    case TextureWrapMode.TWM_CLAMP:
      return "TWM_CLAMP";
    case TextureWrapMode.TWM_MIRROR:
      return "TWM_MIRROR";
    case TextureWrapMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TextureFilterMode {
  TFM_POINT = 0,
  TFM_BILINEAR = 1,
  TFM_TRILINEAR = 2,
  UNRECOGNIZED = -1,
}

export function textureFilterModeFromJSON(object: any): TextureFilterMode {
  switch (object) {
    case 0:
    case "TFM_POINT":
      return TextureFilterMode.TFM_POINT;
    case 1:
    case "TFM_BILINEAR":
      return TextureFilterMode.TFM_BILINEAR;
    case 2:
    case "TFM_TRILINEAR":
      return TextureFilterMode.TFM_TRILINEAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TextureFilterMode.UNRECOGNIZED;
  }
}

export function textureFilterModeToJSON(object: TextureFilterMode): string {
  switch (object) {
    case TextureFilterMode.TFM_POINT:
      return "TFM_POINT";
    case TextureFilterMode.TFM_BILINEAR:
      return "TFM_BILINEAR";
    case TextureFilterMode.TFM_TRILINEAR:
      return "TFM_TRILINEAR";
    case TextureFilterMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Texture {
  src: string;
  /** default = TextureWrapMode.Clamp */
  wrapMode?:
    | TextureWrapMode
    | undefined;
  /** default = FilterMode.Bilinear */
  filterMode?:
    | TextureFilterMode
    | undefined;
  /**
   * Final uv = offset + (input_uv * tiling)
   * Offset for texture positioning.
   */
  offset?:
    | Vector2
    | undefined;
  /** Tiling multiplier for texture repetition. */
  tiling?: Vector2 | undefined;
}

export interface AvatarTexture {
  userId: string;
  /** default = TextureWrapMode.Clamp */
  wrapMode?:
    | TextureWrapMode
    | undefined;
  /** default = FilterMode.Bilinear */
  filterMode?: TextureFilterMode | undefined;
}

export interface VideoTexture {
  videoPlayerEntity: number;
  /** default = TextureWrapMode.Clamp */
  wrapMode?:
    | TextureWrapMode
    | undefined;
  /** default = FilterMode.Bilinear */
  filterMode?: TextureFilterMode | undefined;
}

export interface TextureUnion {
  tex?: { $case: "texture"; texture: Texture } | { $case: "avatarTexture"; avatarTexture: AvatarTexture } | {
    $case: "videoTexture";
    videoTexture: VideoTexture;
  } | undefined;
}

function createBaseTexture(): Texture {
  return { src: "", wrapMode: undefined, filterMode: undefined, offset: undefined, tiling: undefined };
}

export namespace Texture {
  export function encode(message: Texture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.src !== "") {
      writer.uint32(10).string(message.src);
    }
    if (message.wrapMode !== undefined) {
      writer.uint32(16).int32(message.wrapMode);
    }
    if (message.filterMode !== undefined) {
      writer.uint32(24).int32(message.filterMode);
    }
    if (message.offset !== undefined) {
      Vector2.encode(message.offset, writer.uint32(34).fork()).ldelim();
    }
    if (message.tiling !== undefined) {
      Vector2.encode(message.tiling, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Texture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTexture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.src = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.wrapMode = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.filterMode = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.offset = Vector2.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tiling = Vector2.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Texture {
    return {
      src: isSet(object.src) ? String(object.src) : "",
      wrapMode: isSet(object.wrapMode) ? textureWrapModeFromJSON(object.wrapMode) : undefined,
      filterMode: isSet(object.filterMode) ? textureFilterModeFromJSON(object.filterMode) : undefined,
      offset: isSet(object.offset) ? Vector2.fromJSON(object.offset) : undefined,
      tiling: isSet(object.tiling) ? Vector2.fromJSON(object.tiling) : undefined,
    };
  }

  export function toJSON(message: Texture): unknown {
    const obj: any = {};
    message.src !== undefined && (obj.src = message.src);
    message.wrapMode !== undefined &&
      (obj.wrapMode = message.wrapMode !== undefined ? textureWrapModeToJSON(message.wrapMode) : undefined);
    message.filterMode !== undefined &&
      (obj.filterMode = message.filterMode !== undefined ? textureFilterModeToJSON(message.filterMode) : undefined);
    message.offset !== undefined && (obj.offset = message.offset ? Vector2.toJSON(message.offset) : undefined);
    message.tiling !== undefined && (obj.tiling = message.tiling ? Vector2.toJSON(message.tiling) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Texture>, I>>(base?: I): Texture {
    return Texture.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Texture>, I>>(object: I): Texture {
    const message = createBaseTexture();
    message.src = object.src ?? "";
    message.wrapMode = object.wrapMode ?? undefined;
    message.filterMode = object.filterMode ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Vector2.fromPartial(object.offset)
      : undefined;
    message.tiling = (object.tiling !== undefined && object.tiling !== null)
      ? Vector2.fromPartial(object.tiling)
      : undefined;
    return message;
  }
}

function createBaseAvatarTexture(): AvatarTexture {
  return { userId: "", wrapMode: undefined, filterMode: undefined };
}

export namespace AvatarTexture {
  export function encode(message: AvatarTexture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.wrapMode !== undefined) {
      writer.uint32(16).int32(message.wrapMode);
    }
    if (message.filterMode !== undefined) {
      writer.uint32(24).int32(message.filterMode);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): AvatarTexture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatarTexture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.wrapMode = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.filterMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): AvatarTexture {
    return {
      userId: isSet(object.userId) ? String(object.userId) : "",
      wrapMode: isSet(object.wrapMode) ? textureWrapModeFromJSON(object.wrapMode) : undefined,
      filterMode: isSet(object.filterMode) ? textureFilterModeFromJSON(object.filterMode) : undefined,
    };
  }

  export function toJSON(message: AvatarTexture): unknown {
    const obj: any = {};
    message.userId !== undefined && (obj.userId = message.userId);
    message.wrapMode !== undefined &&
      (obj.wrapMode = message.wrapMode !== undefined ? textureWrapModeToJSON(message.wrapMode) : undefined);
    message.filterMode !== undefined &&
      (obj.filterMode = message.filterMode !== undefined ? textureFilterModeToJSON(message.filterMode) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<AvatarTexture>, I>>(base?: I): AvatarTexture {
    return AvatarTexture.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<AvatarTexture>, I>>(object: I): AvatarTexture {
    const message = createBaseAvatarTexture();
    message.userId = object.userId ?? "";
    message.wrapMode = object.wrapMode ?? undefined;
    message.filterMode = object.filterMode ?? undefined;
    return message;
  }
}

function createBaseVideoTexture(): VideoTexture {
  return { videoPlayerEntity: 0, wrapMode: undefined, filterMode: undefined };
}

export namespace VideoTexture {
  export function encode(message: VideoTexture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.videoPlayerEntity !== 0) {
      writer.uint32(8).uint32(message.videoPlayerEntity);
    }
    if (message.wrapMode !== undefined) {
      writer.uint32(16).int32(message.wrapMode);
    }
    if (message.filterMode !== undefined) {
      writer.uint32(24).int32(message.filterMode);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): VideoTexture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoTexture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.videoPlayerEntity = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.wrapMode = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.filterMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): VideoTexture {
    return {
      videoPlayerEntity: isSet(object.videoPlayerEntity) ? Number(object.videoPlayerEntity) : 0,
      wrapMode: isSet(object.wrapMode) ? textureWrapModeFromJSON(object.wrapMode) : undefined,
      filterMode: isSet(object.filterMode) ? textureFilterModeFromJSON(object.filterMode) : undefined,
    };
  }

  export function toJSON(message: VideoTexture): unknown {
    const obj: any = {};
    message.videoPlayerEntity !== undefined && (obj.videoPlayerEntity = Math.round(message.videoPlayerEntity));
    message.wrapMode !== undefined &&
      (obj.wrapMode = message.wrapMode !== undefined ? textureWrapModeToJSON(message.wrapMode) : undefined);
    message.filterMode !== undefined &&
      (obj.filterMode = message.filterMode !== undefined ? textureFilterModeToJSON(message.filterMode) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<VideoTexture>, I>>(base?: I): VideoTexture {
    return VideoTexture.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<VideoTexture>, I>>(object: I): VideoTexture {
    const message = createBaseVideoTexture();
    message.videoPlayerEntity = object.videoPlayerEntity ?? 0;
    message.wrapMode = object.wrapMode ?? undefined;
    message.filterMode = object.filterMode ?? undefined;
    return message;
  }
}

function createBaseTextureUnion(): TextureUnion {
  return { tex: undefined };
}

export namespace TextureUnion {
  export function encode(message: TextureUnion, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.tex?.$case) {
      case "texture":
        Texture.encode(message.tex.texture, writer.uint32(10).fork()).ldelim();
        break;
      case "avatarTexture":
        AvatarTexture.encode(message.tex.avatarTexture, writer.uint32(18).fork()).ldelim();
        break;
      case "videoTexture":
        VideoTexture.encode(message.tex.videoTexture, writer.uint32(26).fork()).ldelim();
        break;
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): TextureUnion {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextureUnion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tex = { $case: "texture", texture: Texture.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tex = { $case: "avatarTexture", avatarTexture: AvatarTexture.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tex = { $case: "videoTexture", videoTexture: VideoTexture.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): TextureUnion {
    return {
      tex: isSet(object.texture)
        ? { $case: "texture", texture: Texture.fromJSON(object.texture) }
        : isSet(object.avatarTexture)
        ? { $case: "avatarTexture", avatarTexture: AvatarTexture.fromJSON(object.avatarTexture) }
        : isSet(object.videoTexture)
        ? { $case: "videoTexture", videoTexture: VideoTexture.fromJSON(object.videoTexture) }
        : undefined,
    };
  }

  export function toJSON(message: TextureUnion): unknown {
    const obj: any = {};
    message.tex?.$case === "texture" &&
      (obj.texture = message.tex?.texture ? Texture.toJSON(message.tex?.texture) : undefined);
    message.tex?.$case === "avatarTexture" &&
      (obj.avatarTexture = message.tex?.avatarTexture ? AvatarTexture.toJSON(message.tex?.avatarTexture) : undefined);
    message.tex?.$case === "videoTexture" &&
      (obj.videoTexture = message.tex?.videoTexture ? VideoTexture.toJSON(message.tex?.videoTexture) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<TextureUnion>, I>>(base?: I): TextureUnion {
    return TextureUnion.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<TextureUnion>, I>>(object: I): TextureUnion {
    const message = createBaseTextureUnion();
    if (object.tex?.$case === "texture" && object.tex?.texture !== undefined && object.tex?.texture !== null) {
      message.tex = { $case: "texture", texture: Texture.fromPartial(object.tex.texture) };
    }
    if (
      object.tex?.$case === "avatarTexture" &&
      object.tex?.avatarTexture !== undefined &&
      object.tex?.avatarTexture !== null
    ) {
      message.tex = { $case: "avatarTexture", avatarTexture: AvatarTexture.fromPartial(object.tex.avatarTexture) };
    }
    if (
      object.tex?.$case === "videoTexture" &&
      object.tex?.videoTexture !== undefined &&
      object.tex?.videoTexture !== null
    ) {
      message.tex = { $case: "videoTexture", videoTexture: VideoTexture.fromPartial(object.tex.videoTexture) };
    }
    return message;
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
