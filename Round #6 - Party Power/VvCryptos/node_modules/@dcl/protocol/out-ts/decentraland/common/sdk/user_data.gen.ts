/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "decentraland.common.sdk";

export interface Snapshots {
  face256: string;
  body: string;
}

export interface AvatarForUserData {
  bodyShape: string;
  skinColor: string;
  hairColor: string;
  eyeColor: string;
  wearables: string[];
  snapshots: Snapshots | undefined;
}

export interface UserData {
  displayName: string;
  publicKey?: string | undefined;
  hasConnectedWeb3: boolean;
  userId: string;
  version: number;
  avatar: AvatarForUserData | undefined;
}

function createBaseSnapshots(): Snapshots {
  return { face256: "", body: "" };
}

export namespace Snapshots {
  export function encode(message: Snapshots, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.face256 !== "") {
      writer.uint32(10).string(message.face256);
    }
    if (message.body !== "") {
      writer.uint32(18).string(message.body);
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): Snapshots {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapshots();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.face256 = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.body = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): Snapshots {
    return {
      face256: isSet(object.face256) ? String(object.face256) : "",
      body: isSet(object.body) ? String(object.body) : "",
    };
  }

  export function toJSON(message: Snapshots): unknown {
    const obj: any = {};
    message.face256 !== undefined && (obj.face256 = message.face256);
    message.body !== undefined && (obj.body = message.body);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<Snapshots>, I>>(base?: I): Snapshots {
    return Snapshots.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<Snapshots>, I>>(object: I): Snapshots {
    const message = createBaseSnapshots();
    message.face256 = object.face256 ?? "";
    message.body = object.body ?? "";
    return message;
  }
}

function createBaseAvatarForUserData(): AvatarForUserData {
  return { bodyShape: "", skinColor: "", hairColor: "", eyeColor: "", wearables: [], snapshots: undefined };
}

export namespace AvatarForUserData {
  export function encode(message: AvatarForUserData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bodyShape !== "") {
      writer.uint32(10).string(message.bodyShape);
    }
    if (message.skinColor !== "") {
      writer.uint32(18).string(message.skinColor);
    }
    if (message.hairColor !== "") {
      writer.uint32(26).string(message.hairColor);
    }
    if (message.eyeColor !== "") {
      writer.uint32(34).string(message.eyeColor);
    }
    for (const v of message.wearables) {
      writer.uint32(42).string(v!);
    }
    if (message.snapshots !== undefined) {
      Snapshots.encode(message.snapshots, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): AvatarForUserData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatarForUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bodyShape = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skinColor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hairColor = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eyeColor = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.wearables.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.snapshots = Snapshots.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): AvatarForUserData {
    return {
      bodyShape: isSet(object.bodyShape) ? String(object.bodyShape) : "",
      skinColor: isSet(object.skinColor) ? String(object.skinColor) : "",
      hairColor: isSet(object.hairColor) ? String(object.hairColor) : "",
      eyeColor: isSet(object.eyeColor) ? String(object.eyeColor) : "",
      wearables: Array.isArray(object?.wearables) ? object.wearables.map((e: any) => String(e)) : [],
      snapshots: isSet(object.snapshots) ? Snapshots.fromJSON(object.snapshots) : undefined,
    };
  }

  export function toJSON(message: AvatarForUserData): unknown {
    const obj: any = {};
    message.bodyShape !== undefined && (obj.bodyShape = message.bodyShape);
    message.skinColor !== undefined && (obj.skinColor = message.skinColor);
    message.hairColor !== undefined && (obj.hairColor = message.hairColor);
    message.eyeColor !== undefined && (obj.eyeColor = message.eyeColor);
    if (message.wearables) {
      obj.wearables = message.wearables.map((e) => e);
    } else {
      obj.wearables = [];
    }
    message.snapshots !== undefined &&
      (obj.snapshots = message.snapshots ? Snapshots.toJSON(message.snapshots) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<AvatarForUserData>, I>>(base?: I): AvatarForUserData {
    return AvatarForUserData.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<AvatarForUserData>, I>>(object: I): AvatarForUserData {
    const message = createBaseAvatarForUserData();
    message.bodyShape = object.bodyShape ?? "";
    message.skinColor = object.skinColor ?? "";
    message.hairColor = object.hairColor ?? "";
    message.eyeColor = object.eyeColor ?? "";
    message.wearables = object.wearables?.map((e) => e) || [];
    message.snapshots = (object.snapshots !== undefined && object.snapshots !== null)
      ? Snapshots.fromPartial(object.snapshots)
      : undefined;
    return message;
  }
}

function createBaseUserData(): UserData {
  return { displayName: "", publicKey: undefined, hasConnectedWeb3: false, userId: "", version: 0, avatar: undefined };
}

export namespace UserData {
  export function encode(message: UserData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.publicKey !== undefined) {
      writer.uint32(18).string(message.publicKey);
    }
    if (message.hasConnectedWeb3 === true) {
      writer.uint32(24).bool(message.hasConnectedWeb3);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.version !== 0) {
      writer.uint32(40).int32(message.version);
    }
    if (message.avatar !== undefined) {
      AvatarForUserData.encode(message.avatar, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  }

  export function decode(input: _m0.Reader | Uint8Array, length?: number): UserData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.hasConnectedWeb3 = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.avatar = AvatarForUserData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  }

  export function fromJSON(object: any): UserData {
    return {
      displayName: isSet(object.displayName) ? String(object.displayName) : "",
      publicKey: isSet(object.publicKey) ? String(object.publicKey) : undefined,
      hasConnectedWeb3: isSet(object.hasConnectedWeb3) ? Boolean(object.hasConnectedWeb3) : false,
      userId: isSet(object.userId) ? String(object.userId) : "",
      version: isSet(object.version) ? Number(object.version) : 0,
      avatar: isSet(object.avatar) ? AvatarForUserData.fromJSON(object.avatar) : undefined,
    };
  }

  export function toJSON(message: UserData): unknown {
    const obj: any = {};
    message.displayName !== undefined && (obj.displayName = message.displayName);
    message.publicKey !== undefined && (obj.publicKey = message.publicKey);
    message.hasConnectedWeb3 !== undefined && (obj.hasConnectedWeb3 = message.hasConnectedWeb3);
    message.userId !== undefined && (obj.userId = message.userId);
    message.version !== undefined && (obj.version = Math.round(message.version));
    message.avatar !== undefined &&
      (obj.avatar = message.avatar ? AvatarForUserData.toJSON(message.avatar) : undefined);
    return obj;
  }

  export function create<I extends Exact<DeepPartial<UserData>, I>>(base?: I): UserData {
    return UserData.fromPartial(base ?? {});
  }

  export function fromPartial<I extends Exact<DeepPartial<UserData>, I>>(object: I): UserData {
    const message = createBaseUserData();
    message.displayName = object.displayName ?? "";
    message.publicKey = object.publicKey ?? undefined;
    message.hasConnectedWeb3 = object.hasConnectedWeb3 ?? false;
    message.userId = object.userId ?? "";
    message.version = object.version ?? 0;
    message.avatar = (object.avatar !== undefined && object.avatar !== null)
      ? AvatarForUserData.fromPartial(object.avatar)
      : undefined;
    return message;
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
