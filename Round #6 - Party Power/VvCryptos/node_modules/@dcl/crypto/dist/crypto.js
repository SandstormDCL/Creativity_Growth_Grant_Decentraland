"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createUnsafeIdentity = exports.computeAddress = exports.ethSign = exports.createEthereumMessageHash = exports.sign = exports.recoverAddressFromEthSignature = exports.recoverPublicKey = void 0;
const eth_connect_1 = require("eth-connect");
const secp256k1_1 = require("ethereum-cryptography/secp256k1");
const secp256k1_compat_1 = require("ethereum-cryptography/secp256k1-compat");
/**
 * returns the publicKey for the privateKey with which the messageHash was signed
 * @param  {string} signature
 * @param  {string} hash
 */
function recoverPublicKey(signature, hash) {
    if (signature.length !== 65) {
        throw new Error('Invalid signature length' + signature.length);
    }
    // split into v-value and sig
    const sigOnly = signature.slice(0, signature.length - 1); // all but last 2 chars
    const recoveryNumber = signature[64] === 0x1c ? 1 : 0;
    const pubKey = (0, secp256k1_compat_1.ecdsaRecover)(sigOnly, recoveryNumber, hash, false);
    // remove trailing '04'
    return pubKey.slice(1);
}
exports.recoverPublicKey = recoverPublicKey;
function sanitizeSignature(signature) {
    if (signature.length !== 65)
        throw new Error('Invalid ethereum signature');
    const version = signature[64];
    if (version === 0 || version === 1) {
        const newSignature = new Uint8Array(signature);
        newSignature[64] = version + 27;
        return newSignature;
    }
    return signature;
}
function recoverAddressFromEthSignature(signature, msg) {
    if (typeof signature === 'string') {
        if ((0, eth_connect_1.isHex)(signature))
            return recoverAddressFromEthSignature((0, eth_connect_1.hexToBytes)(signature), msg);
        throw new Error('String signatures must be encoded in hex');
    }
    return computeAddress(recoverPublicKey(sanitizeSignature(signature), createEthereumMessageHash(msg)));
}
exports.recoverAddressFromEthSignature = recoverAddressFromEthSignature;
function sign(privateKey, hash) {
    const sigObj = (0, secp256k1_compat_1.ecdsaSign)(hash, privateKey);
    const recoveryId = sigObj.recid === 1 ? '1c' : '1b';
    return (0, eth_connect_1.toHex)(sigObj.signature) + recoveryId;
}
exports.sign = sign;
function createEthereumMessageHash(msg) {
    const message = typeof msg === 'string' ? (0, eth_connect_1.stringToUtf8Bytes)(msg) : msg;
    const bytes = (0, eth_connect_1.concatBytes)((0, eth_connect_1.stringToUtf8Bytes)(`\x19Ethereum Signed Message:\n`), (0, eth_connect_1.stringToUtf8Bytes)(String(message.length)), message);
    return (0, eth_connect_1.hexToBytes)((0, eth_connect_1.sha3)(bytes));
}
exports.createEthereumMessageHash = createEthereumMessageHash;
// Emulates eth_personalSign
function ethSign(privateKey, message) {
    return sign(privateKey, createEthereumMessageHash(message));
}
exports.ethSign = ethSign;
function computeAddress(key) {
    // Strip off the leading "0x04"
    const publicKey = key.length === 65 && key[0] === 0x04 ? key.slice(1) : key;
    return (0, eth_connect_1.getAddress)((0, eth_connect_1.sha3)(publicKey).substring(24));
}
exports.computeAddress = computeAddress;
/**
 * This method should not be used. It may use non-secure random number generators.
 */
function createUnsafeIdentity() {
    const privateKey = secp256k1_1.utils.randomPrivateKey();
    // remove heading 0x04
    const publicKey = (0, secp256k1_1.getPublicKey)(privateKey).slice(1);
    const address = computeAddress(publicKey);
    return {
        privateKey: (0, eth_connect_1.bytesToHex)(privateKey),
        publicKey: (0, eth_connect_1.bytesToHex)(publicKey),
        address
    };
}
exports.createUnsafeIdentity = createUnsafeIdentity;
//# sourceMappingURL=crypto.js.map