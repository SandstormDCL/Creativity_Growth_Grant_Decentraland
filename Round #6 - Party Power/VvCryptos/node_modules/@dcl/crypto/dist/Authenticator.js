"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidEIP1271Signature = exports.parseEmphemeralPayload = exports.getSignedIdentitySignatureType = exports.getEphemeralSignatureType = exports.EIP_1654_SIGNED_ENTITY_VALIDATOR = exports.ECDSA_EIP_1654_EPHEMERAL_VALIDATOR = exports.ECDSA_PERSONAL_EPHEMERAL_VALIDATOR = exports.ECDSA_SIGNED_ENTITY_VALIDATOR = exports.SIGNER_VALIDATOR = exports.Authenticator = exports.ERC1654_MAGIC_VALUE = exports.VALID_SIGNATURE = void 0;
const eth_connect_1 = __importStar(require("eth-connect"));
const SignatureValidator_1 = require("./contracts/SignatureValidator");
const types_1 = require("./types");
const utils_1 = require("./helper/utils");
const blocks_1 = __importDefault(require("./helper/blocks"));
const crypto_1 = require("./crypto");
exports.VALID_SIGNATURE = 'VALID_SIGNATURE';
// bytes4(keccak256("isValidSignature(bytes32,bytes)")
exports.ERC1654_MAGIC_VALUE = '1626ba7e';
const PERSONAL_SIGNATURE_LENGTH = 132;
var Authenticator;
(function (Authenticator) {
    /** Validate that the signature belongs to the Ethereum address */
    async function validateSignature(expectedFinalAuthority, authChain, provider, dateToValidateExpirationInMillis = Date.now()) {
        let currentAuthority = '';
        if (!Authenticator.isValidAuthChain(authChain)) {
            return {
                ok: false,
                message: 'ERROR: Malformed authChain'
            };
        }
        for (const authLink of authChain) {
            const validator = getValidatorByType(authLink.type);
            try {
                const { nextAuthority } = await validator(currentAuthority, authLink, {
                    provider,
                    dateToValidateExpirationInMillis
                });
                currentAuthority = nextAuthority ? nextAuthority : '';
            }
            catch (e) {
                return {
                    ok: false,
                    message: `ERROR. Link type: ${authLink.type}. ${e.message}.`
                };
            }
        }
        const ok = currentAuthority === expectedFinalAuthority;
        return {
            ok,
            message: ok
                ? undefined
                : `ERROR: Invalid final authority. Expected: ${expectedFinalAuthority}. Current ${currentAuthority}.`
        };
    }
    Authenticator.validateSignature = validateSignature;
    function isValidAuthChain(authChain) {
        for (const [index, authLink] of authChain.entries()) {
            // SIGNER should be the first one
            if (index === 0 && authLink.type !== types_1.AuthLinkType.SIGNER) {
                return false;
            }
            // SIGNER should be unique
            if (authLink.type === types_1.AuthLinkType.SIGNER && index !== 0) {
                return false;
            }
        }
        return true;
    }
    Authenticator.isValidAuthChain = isValidAuthChain;
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md
    function createEIP1271MessageHash(msg) {
        return (0, eth_connect_1.hexToBytes)((0, eth_connect_1.sha3)((0, eth_connect_1.stringToUtf8Bytes)(msg)));
    }
    Authenticator.createEIP1271MessageHash = createEIP1271MessageHash;
    function createSimpleAuthChain(finalPayload, ownerAddress, signature) {
        return [
            {
                type: types_1.AuthLinkType.SIGNER,
                payload: ownerAddress,
                signature: ''
            },
            {
                type: getSignedIdentitySignatureType(signature),
                payload: finalPayload,
                signature: signature
            }
        ];
    }
    Authenticator.createSimpleAuthChain = createSimpleAuthChain;
    function createAuthChain(ownerIdentity, ephemeralIdentity, ephemeralMinutesDuration, entityId) {
        const expiration = (0, utils_1.moveMinutes)(ephemeralMinutesDuration);
        const ephemeralMessage = Authenticator.getEphemeralMessage(ephemeralIdentity.address, expiration);
        const firstSignature = Authenticator.createSignature(ownerIdentity, ephemeralMessage);
        const secondSignature = Authenticator.createSignature(ephemeralIdentity, entityId);
        const authChain = [
            {
                type: types_1.AuthLinkType.SIGNER,
                payload: ownerIdentity.address,
                signature: ''
            },
            {
                type: types_1.AuthLinkType.ECDSA_PERSONAL_EPHEMERAL,
                payload: ephemeralMessage,
                signature: firstSignature
            },
            {
                type: types_1.AuthLinkType.ECDSA_PERSONAL_SIGNED_ENTITY,
                payload: entityId,
                signature: secondSignature
            }
        ];
        return authChain;
    }
    Authenticator.createAuthChain = createAuthChain;
    async function initializeAuthChain(ethAddress, ephemeralIdentity, ephemeralMinutesDuration, signer) {
        const expiration = new Date();
        expiration.setMinutes(expiration.getMinutes() + ephemeralMinutesDuration);
        const ephemeralMessage = Authenticator.getEphemeralMessage(ephemeralIdentity.address, expiration);
        const firstSignature = await signer(ephemeralMessage);
        const authChain = [
            { type: types_1.AuthLinkType.SIGNER, payload: ethAddress, signature: '' },
            {
                type: getEphemeralSignatureType(firstSignature),
                payload: ephemeralMessage,
                signature: firstSignature
            }
        ];
        return {
            ephemeralIdentity,
            expiration,
            authChain
        };
    }
    Authenticator.initializeAuthChain = initializeAuthChain;
    function signPayload(authIdentity, entityId) {
        const secondSignature = Authenticator.createSignature(authIdentity.ephemeralIdentity, entityId);
        return [
            ...authIdentity.authChain,
            {
                type: types_1.AuthLinkType.ECDSA_PERSONAL_SIGNED_ENTITY,
                payload: entityId,
                signature: secondSignature
            }
        ];
    }
    Authenticator.signPayload = signPayload;
    Authenticator.createEthereumMessageHash = crypto_1.createEthereumMessageHash;
    function createSignature(identity, message) {
        return (0, crypto_1.ethSign)((0, eth_connect_1.hexToBytes)(identity.privateKey), message);
    }
    Authenticator.createSignature = createSignature;
    function ownerAddress(authChain) {
        if (authChain.length > 0) {
            if (authChain[0].type === types_1.AuthLinkType.SIGNER) {
                return authChain[0].payload;
            }
        }
        return 'Invalid-Owner-Address';
    }
    Authenticator.ownerAddress = ownerAddress;
    function getEphemeralMessage(ephemeralAddress, expiration) {
        return `Decentraland Login\nEphemeral address: ${ephemeralAddress}\nExpiration: ${expiration.toISOString()}`;
    }
    Authenticator.getEphemeralMessage = getEphemeralMessage;
})(Authenticator = exports.Authenticator || (exports.Authenticator = {}));
const SIGNER_VALIDATOR = async (_, authLink) => {
    return { nextAuthority: authLink.payload };
};
exports.SIGNER_VALIDATOR = SIGNER_VALIDATOR;
const ECDSA_SIGNED_ENTITY_VALIDATOR = async (authority, authLink) => {
    if (!authLink.signature) {
        throw new Error(`Invalid AuthLink. 'signature' must be present for type 'ECDSA_SIGNED_ENTITY_VALIDATOR'`);
    }
    const signerAddress = (0, crypto_1.recoverAddressFromEthSignature)(authLink.signature, authLink.payload);
    const expectedSignedAddress = authority.toLocaleLowerCase();
    const actualSignedAddress = signerAddress.toLocaleLowerCase();
    if (expectedSignedAddress === actualSignedAddress) {
        return { nextAuthority: authLink.payload };
    }
    throw new Error(`Invalid signer address. Expected: ${expectedSignedAddress}. Actual: ${actualSignedAddress}`);
};
exports.ECDSA_SIGNED_ENTITY_VALIDATOR = ECDSA_SIGNED_ENTITY_VALIDATOR;
const ECDSA_PERSONAL_EPHEMERAL_VALIDATOR = async (authority, authLink, options) => {
    if (!authLink.signature) {
        throw new Error(`Invalid AuthLink. 'signature' must be present for type 'ECDSA_PERSONAL_EPHEMERAL_VALIDATOR'`);
    }
    const { message, ephemeralAddress, expiration } = parseEmphemeralPayload(authLink.payload);
    const dateToValidateExpirationInMillis = options.dateToValidateExpirationInMillis
        ? options.dateToValidateExpirationInMillis
        : Date.now();
    if (expiration > dateToValidateExpirationInMillis) {
        const signerAddress = (0, crypto_1.recoverAddressFromEthSignature)(authLink.signature, message);
        const expectedSignedAddress = authority.toLocaleLowerCase();
        const actualSignedAddress = signerAddress.toLocaleLowerCase();
        if (expectedSignedAddress === actualSignedAddress) {
            return { nextAuthority: ephemeralAddress };
        }
        throw new Error(`Invalid signer address. Expected: ${expectedSignedAddress}. Actual: ${actualSignedAddress}`);
    }
    throw new Error(`Ephemeral key expired. Expiration: ${expiration}. Test: ${dateToValidateExpirationInMillis}`);
};
exports.ECDSA_PERSONAL_EPHEMERAL_VALIDATOR = ECDSA_PERSONAL_EPHEMERAL_VALIDATOR;
const ECDSA_EIP_1654_EPHEMERAL_VALIDATOR = async (authority, authLink, options) => {
    if (!authLink.signature) {
        throw new Error(`Invalid AuthLink. 'signature' must be present for type 'ECDSA_EIP_1654_EPHEMERAL_VALIDATOR'`);
    }
    const { message, ephemeralAddress, expiration } = parseEmphemeralPayload(authLink.payload);
    const dateToValidateExpirationInMillis = (options === null || options === void 0 ? void 0 : options.dateToValidateExpirationInMillis)
        ? options === null || options === void 0 ? void 0 : options.dateToValidateExpirationInMillis
        : Date.now();
    if (expiration > dateToValidateExpirationInMillis) {
        if (await isValidEIP1654Message(options.provider, authority, message, authLink.signature, dateToValidateExpirationInMillis)) {
            return { nextAuthority: ephemeralAddress };
        }
    }
    throw new Error(`Ephemeral key expired. Expiration: ${expiration}. Test: ${dateToValidateExpirationInMillis}`);
};
exports.ECDSA_EIP_1654_EPHEMERAL_VALIDATOR = ECDSA_EIP_1654_EPHEMERAL_VALIDATOR;
const EIP_1654_SIGNED_ENTITY_VALIDATOR = async (authority, authLink, options) => {
    if (!authLink.signature) {
        throw new Error(`Invalid AuthLink. 'signature' must be present for type 'EIP_1654_SIGNED_ENTITY_VALIDATOR'`);
    }
    if (await isValidEIP1654Message(options.provider, authority, authLink.payload, authLink.signature, options.dateToValidateExpirationInMillis)) {
        return { nextAuthority: authLink.payload };
    }
    throw new Error(`Invalid validation`);
};
exports.EIP_1654_SIGNED_ENTITY_VALIDATOR = EIP_1654_SIGNED_ENTITY_VALIDATOR;
const ERROR_VALIDATOR = async (_, __) => {
    return { error: 'Error Validator.' };
};
function getEphemeralSignatureType(signature) {
    if (signature.length === PERSONAL_SIGNATURE_LENGTH) {
        return types_1.AuthLinkType.ECDSA_PERSONAL_EPHEMERAL;
    }
    else {
        return types_1.AuthLinkType.ECDSA_EIP_1654_EPHEMERAL;
    }
}
exports.getEphemeralSignatureType = getEphemeralSignatureType;
function getSignedIdentitySignatureType(signature) {
    if (signature.length === PERSONAL_SIGNATURE_LENGTH) {
        return types_1.AuthLinkType.ECDSA_PERSONAL_SIGNED_ENTITY;
    }
    else {
        return types_1.AuthLinkType.ECDSA_EIP_1654_SIGNED_ENTITY;
    }
}
exports.getSignedIdentitySignatureType = getSignedIdentitySignatureType;
function parseEmphemeralPayload(payload) {
    // authLink payload structure: <human-readable message >\nEphemeral address: <ephemeral-eth - address >\nExpiration: <timestamp>
    // authLink payload example: Decentraland Login\nEphemeral address: 0x123456\nExpiration: 2020 - 01 - 20T22: 57: 11.334Z
    const message = payload.replace(/\r/g, '');
    const payloadParts = message.split('\n');
    const ephemeralAddress = payloadParts[1].substring('Ephemeral address: '.length);
    const expirationString = payloadParts[2].substring('Expiration: '.length);
    const expiration = Date.parse(expirationString);
    return { message, ephemeralAddress, expiration };
}
exports.parseEmphemeralPayload = parseEmphemeralPayload;
async function isValidEIP1271Signature(signatureValidator, message, signature, block) {
    const hashedMessage = Authenticator.createEIP1271MessageHash(message);
    const _signature = (0, eth_connect_1.hexToBytes)(signature);
    let result;
    try {
        result = (0, eth_connect_1.bytesToHex)(await signatureValidator.isValidSignature(hashedMessage, _signature, block));
    }
    catch (e) {
        // Can revert if the signature is not valid
    }
    if (result === exports.ERC1654_MAGIC_VALUE) {
        return true;
    }
    const hashedMessageWithPrefix = (0, crypto_1.createEthereumMessageHash)(message);
    try {
        result = (0, eth_connect_1.bytesToHex)(await signatureValidator.isValidSignature(hashedMessageWithPrefix, _signature, block));
    }
    catch (e) {
        // Can revert if the signature is not valid
    }
    return result === exports.ERC1654_MAGIC_VALUE;
}
exports.isValidEIP1271Signature = isValidEIP1271Signature;
async function isValidEIP1654Message(provider, contractAddress, message, signature, dateToValidateExpirationInMillis) {
    if (!provider) {
        throw new Error('Missing provider');
    }
    const requestManager = new eth_connect_1.default(provider);
    const signatureValidator = await (0, SignatureValidator_1.SignatureValidator)(requestManager, contractAddress);
    let result = await isValidEIP1271Signature(signatureValidator, message, signature);
    if (result) {
        return true;
    }
    // check based on the dateToValidateExpirationInMillis
    const dater = new blocks_1.default(requestManager);
    try {
        const { block } = await dater.getDate(dateToValidateExpirationInMillis, false);
        result = await isValidEIP1271Signature(signatureValidator, message, signature, block);
        if (result) {
            return true;
        }
    }
    catch (e) {
        throw new Error(`Invalid validation. Error: ${e.message}`);
    }
    throw new Error(`Invalid validation. Expected: ${exports.ERC1654_MAGIC_VALUE}. Actual: ${result}`);
}
function getValidatorByType(type) {
    switch (type) {
        case types_1.AuthLinkType.SIGNER:
            return exports.SIGNER_VALIDATOR;
        case types_1.AuthLinkType.ECDSA_PERSONAL_EPHEMERAL:
            return exports.ECDSA_PERSONAL_EPHEMERAL_VALIDATOR;
        case types_1.AuthLinkType.ECDSA_PERSONAL_SIGNED_ENTITY:
            return exports.ECDSA_SIGNED_ENTITY_VALIDATOR;
        case types_1.AuthLinkType.ECDSA_EIP_1654_EPHEMERAL:
            return exports.ECDSA_EIP_1654_EPHEMERAL_VALIDATOR;
        case types_1.AuthLinkType.ECDSA_EIP_1654_SIGNED_ENTITY:
            return exports.EIP_1654_SIGNED_ENTITY_VALIDATOR;
        default:
            return ERROR_VALIDATOR;
    }
}
//# sourceMappingURL=Authenticator.js.map