"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wsAsAsyncChannel = void 0;
const push_channel_1 = require("@dcl/rpc/dist/push-channel");
const ws_comms_gen_1 = require("@dcl/protocol/out-js/decentraland/kernel/comms/rfc5/ws_comms.gen");
function wsAsAsyncChannel(socket) {
    // Wire the socket to a pushable channel
    const channel = new push_channel_1.AsyncQueue((queue, action) => {
        if (action === 'close') {
            socket.off('message', processMessage);
            socket.off('close', closeChannel);
        }
    });
    function processMessage(data) {
        try {
            channel.enqueue(ws_comms_gen_1.WsPacket.decode(new Uint8Array(data)));
        }
        catch (error) {
            socket.emit('error', error);
            socket.terminate();
        }
    }
    function closeChannel() {
        channel.close();
    }
    socket.on('message', processMessage);
    socket.on('close', closeChannel);
    return Object.assign(channel, {
        async yield(timeoutMs, error) {
            if (timeoutMs) {
                const next = (await Promise.race([channel.next(), timeout(timeoutMs, error)]));
                if (next.done)
                    throw new Error('Cannot consume message from closed AsyncQueue. ' + error);
                return next.value;
            }
            else {
                const next = await channel.next();
                if (next.done)
                    throw new Error('Cannot consume message from closed AsyncQueue.' + error);
                return next.value;
            }
        }
    });
}
exports.wsAsAsyncChannel = wsAsAsyncChannel;
function timeout(ms, error = 'Timed out') {
    return new Promise((_, reject) => {
        setTimeout(() => reject(new Error(error)), ms);
    });
}
//# sourceMappingURL=ws-as-async-channel.js.map