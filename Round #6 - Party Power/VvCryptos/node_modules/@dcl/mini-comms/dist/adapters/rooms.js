"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRoomsComponent = exports.craftMessage = exports.roomsMetrics = void 0;
const minimal_1 = require("protobufjs/minimal");
const proto = __importStar(require("@dcl/protocol/out-js/decentraland/kernel/comms/rfc5/ws_comms.gen"));
const metrics_1 = require("@well-known-components/metrics");
exports.roomsMetrics = (0, metrics_1.validateMetricsDeclaration)({
    dcl_ws_rooms_count: {
        help: 'Current amount of rooms',
        type: 'gauge'
    },
    dcl_ws_rooms_sent_messages_total: {
        help: 'Amount of user sent messages',
        type: 'counter'
    },
    dcl_ws_rooms_connections: {
        help: 'Current amount of connections',
        type: 'gauge'
    },
    dcl_ws_rooms_connections_total: {
        help: 'Total amount of connections',
        type: 'counter'
    },
    dcl_ws_rooms_kicks_total: {
        help: 'Total amount of kicked players',
        type: 'counter'
    },
    dcl_ws_rooms_unknown_sent_messages_total: {
        help: 'Total amount of unkown messages',
        type: 'counter'
    },
    dcl_ws_rooms_dropped_unreliable_messages_total: {
        help: 'Total amount of dropped unreliable messages',
        type: 'counter'
    }
});
// we use a shared writer to reduce allocations and leverage its allocation pool
const writer = new minimal_1.Writer();
function craftMessage(packet) {
    writer.reset();
    proto.WsPacket.encode(packet, writer);
    return writer.finish();
}
exports.craftMessage = craftMessage;
async function createRoomsComponent(components) {
    const rooms = new Map();
    const addressToSocket = new Map();
    const logger = components.logs.getLogger('RoomsComponent');
    const unreliableThreshold = (await components.config.getNumber('WS_MAX_BUFFERED_AMOUNT')) || 0;
    let connectionCounter = 0;
    // gets or creates a room
    function getRoom(room) {
        let r = rooms.get(room);
        if (!r) {
            logger.debug('Creating room', { room });
            r = new Set();
            rooms.set(room, r);
        }
        observeRoomCount();
        return r;
    }
    function observeRoomCount() {
        components.metrics.observe('dcl_ws_rooms_count', {}, rooms.size);
    }
    function observeConnectionCount() {
        components.metrics.observe('dcl_ws_rooms_connections', {}, addressToSocket.size);
    }
    // Removes a socket from a room in the data structure and also forwards the
    // message to the rest of the room.
    // Deletes the room if it becomes empty
    function removeFromRoom(roomSocket) {
        const roomInstance = getRoom(roomSocket.room);
        logger.debug('Disconnecting user', {
            room: roomSocket.room,
            address: roomSocket.address,
            alias: roomSocket.alias,
            count: addressToSocket.size
        });
        roomInstance.delete(roomSocket);
        addressToSocket.delete(roomSocket.address);
        if (roomInstance.size === 0) {
            logger.debug('Destroying room', { room: roomSocket.room, count: rooms.size });
            rooms.delete(roomSocket.room);
            observeRoomCount();
        }
        else {
            broadcastToRoom(roomInstance, craftMessage({ message: { $case: 'peerLeaveMessage', peerLeaveMessage: { alias: roomSocket.alias } } }), roomSocket, true);
        }
        observeConnectionCount();
    }
    // simply sends a message to a socket. disconnects the socket upon failure
    function sendMessage(socket, message, reliable) {
        if (socket.readyState === socket.OPEN) {
            if ((socket.bufferedAmount <= unreliableThreshold || reliable) && !socket.isPaused) {
                try {
                    socket.send(message, (err) => {
                        if (err) {
                            socket.terminate();
                        }
                    });
                }
                catch (err) {
                    socket.terminate();
                }
            }
            else {
                components.metrics.increment('dcl_ws_rooms_dropped_unreliable_messages_total');
            }
        }
    }
    // broadcasts a message to a room. optionally it can skip one socket
    function broadcastToRoom(roomSockets, message, excludePeer, reliable) {
        for (const peer of roomSockets) {
            if (peer === excludePeer)
                continue;
            sendMessage(peer.ws, message, reliable);
        }
    }
    // receives an authenticated socket and adds it to a room
    function addSocketToRoom(ws, address, room) {
        const alias = ++connectionCounter;
        const newRoomSocket = {
            ws,
            alias,
            address,
            room
        };
        logger.debug('Connecting user', { room, address, alias });
        // disconnect previous session
        const kicked = addressToSocket.get(newRoomSocket.address);
        if (kicked) {
            logger.info('Kicking user', { room, address, alias: kicked.alias });
            sendMessage(kicked.ws, craftMessage({ message: { $case: 'peerKicked', peerKicked: { reason: 'Already logged in' } } }), true);
            kicked.ws.close();
            removeFromRoom(kicked);
            logger.info('Kicked user', { room, address, alias: kicked.alias });
            components.metrics.increment('dcl_ws_rooms_kicks_total');
        }
        const roomInstance = getRoom(room);
        // 0. before anything else, add the user to the room and hook the 'close' and 'message' events
        roomInstance.add(newRoomSocket);
        addressToSocket.set(newRoomSocket.address, newRoomSocket);
        newRoomSocket.ws.on('error', (err) => {
            logger.error(err);
            removeFromRoom(newRoomSocket);
        });
        newRoomSocket.ws.on('close', () => removeFromRoom(newRoomSocket));
        newRoomSocket.ws.on('message', (body) => {
            const msg = proto.WsPacket.decode(body);
            if (msg.message?.$case === 'peerUpdateMessage') {
                broadcastToRoom(roomInstance, craftMessage({
                    message: {
                        $case: 'peerUpdateMessage',
                        peerUpdateMessage: {
                            fromAlias: newRoomSocket.alias,
                            body: msg.message.peerUpdateMessage.body,
                            unreliable: msg.message.peerUpdateMessage.unreliable
                        }
                    }
                }), newRoomSocket, !msg.message.peerUpdateMessage.unreliable);
                components.metrics.increment('dcl_ws_rooms_sent_messages_total');
            }
            else {
                // we accept unknown messages to enable protocol extensibility and compatibility.
                // do NOT kick the users when they send unknown messages
                components.metrics.increment('dcl_ws_rooms_unknown_sent_messages_total');
            }
        });
        observeConnectionCount();
        // 1. tell the user about their identity and the neighbouring peers,
        //    and disconnect other peers if the address is repeated
        const peerIdentities = {};
        for (const peer of roomInstance) {
            if (peer.address !== newRoomSocket.address) {
                peerIdentities[peer.alias] = peer.address;
            }
        }
        const welcomeMessage = craftMessage({
            message: {
                $case: 'welcomeMessage',
                welcomeMessage: { alias: newRoomSocket.alias, peerIdentities }
            }
        });
        sendMessage(ws, welcomeMessage, true);
        // 2. broadcast to all room that this user is joining them
        const joinedMessage = craftMessage({
            message: {
                $case: 'peerJoinMessage',
                peerJoinMessage: { alias: newRoomSocket.alias, address: newRoomSocket.address }
            }
        });
        broadcastToRoom(roomInstance, joinedMessage, newRoomSocket, true);
        components.metrics.increment('dcl_ws_rooms_connections_total');
    }
    function isAddressConnected(address) {
        return addressToSocket.has(address);
    }
    return {
        addSocketToRoom,
        isAddressConnected
    };
}
exports.createRoomsComponent = createRoomsComponent;
//# sourceMappingURL=rooms.js.map