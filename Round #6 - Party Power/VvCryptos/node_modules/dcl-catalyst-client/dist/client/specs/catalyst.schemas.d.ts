/**
 * Generated by orval v6.20.0 üç∫
 * Do not edit manually.
 * API Specification for the Decentraland Catalyst Server (BETA)
 * A Catalyst is a Server that runs different services. These services currently work as the backbone for Decentraland and work in a decentralized network. The current specification details the following services: <br/><br/>- Archipelago <br/>- Content Server <br/>- Lambdas Service <br/> <br/>WARNING: We are working to close the version 1.0 of the Catalyst Protocol defined by this API. So far this is what we have and it's public but we are still working on refinement and during this process we may decided to deprecate or change some of the endpoints.
 * OpenAPI spec version: 1.0
 */
export type ValidateSignature200 = {
    [key: string]: any;
};
export type ValidateSignatureBody = {
    [key: string]: any;
};
export type SearchWearablesParams = {
    /**
     * Lis of URNs that identify the collection. Maximum amount of ids allowed is 500.
     */
    collectionId?: string[];
    /**
     * List of wearables URNs to search. Maximum amount of ids allowed is 500.
     */
    wearableId?: string[];
    /**
     * Search text
     */
    textSearch?: string;
    /**
     * Limit the quantity of results that will be returned by the request. You can only request up to 500 results.
     */
    limit?: number;
    /**
     * The result will always be ordered by the local timestamp fields but in case of timestamp collisions, you can use the lastId field to filter the result
     */
    lastId?: string;
};
export type GetThirdPartyCollection200 = {
    elements: ThirdPartyWearable[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
};
export type GetThirdPartyCollectionParams = {
    /**
     * The number of the requested page.
     */
    pageNum?: string;
    /**
     * The size of the requested page.
     */
    pageSize?: string;
};
export type GetThirdPartyWearables200 = {
    elements: ThirdPartyWearable[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
};
export type GetThirdPartyWearablesParams = {
    /**
     * The number of the requested page.
     */
    pageNum?: string;
    /**
     * The size of the requested page.
     */
    pageSize?: string;
};
export type GetLandsParams = {
    /**
     * The number of the requested page. It needs `pageSize` to be present to enable a paginated response.
     */
    pageNum?: string;
    /**
     * The size of the requested page. It needs `pageNum` to be present to enable a paginated response.
     */
    pageSize?: string;
};
export type GetNamesParams = {
    /**
     * The number of the requested page. It needs `pageSize` to be present to enable a paginated response.
     */
    pageNum?: string;
    /**
     * The size of the requested page. It needs `pageNum` to be present to enable a paginated response.
     */
    pageSize?: string;
};
export type GetEmotes200 = {
    elements: Emote[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
};
export type GetEmotesParams = {
    /**
     * Third Party collection Id to filter emotes, if this param is not sent then the 3rd parties emotes are not shown. If it is sent, only the 3rd parties emotes are shown.
     */
    collectionId?: string;
    /**
     * If present, response will be extended with the entity data.
     */
    includeEntities?: boolean;
    /**
     * The number of the requested page.
     */
    pageNum?: string;
    /**
     * The size of the requested page
     */
    pageSize?: string;
};
export type GetWearables200 = {
    elements: Wearable[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
};
export type GetWearablesParams = {
    /**
     * If present, response will be extended with the entity data.
     */
    includeEntities?: boolean;
    /**
     * If present, response will include the third-party wearables owned by the address. They will appear before other wearables if the response is paginated.
     */
    includeThirdParty?: boolean;
    /**
     * The number of the requested page.
     */
    pageNum?: string;
    /**
     * The size of the requested page.
     */
    pageSize?: string;
    /**
     * Determines the field to be sort by. By default it will be by `transferredAt`. Possible values: `transferredAt` and `rarity`.
     */
    orderBy?: string;
};
export type GetCollections200CollectionsItem = {
    id: string;
    name: string;
};
export type GetCollections200 = {
    collections?: GetCollections200CollectionsItem[];
};
export type GetPointerChangesSortingOrder = (typeof GetPointerChangesSortingOrder)[keyof typeof GetPointerChangesSortingOrder];
export declare const GetPointerChangesSortingOrder: {
    readonly ASC: "ASC";
    readonly DESC: "DESC";
};
export type GetPointerChangesSortingField = (typeof GetPointerChangesSortingField)[keyof typeof GetPointerChangesSortingField];
export declare const GetPointerChangesSortingField: {
    readonly local_timestamp: "local_timestamp";
    readonly entity_timestamp: "entity_timestamp";
};
export type GetPointerChangesEntityType = (typeof GetPointerChangesEntityType)[keyof typeof GetPointerChangesEntityType];
export declare const GetPointerChangesEntityType: {
    readonly scene: "scene";
    readonly profile: "profile";
    readonly wearable: "wearable";
};
export type GetPointerChangesParams = {
    /**
     * Acts as a filter in the collection of deployments, this value is the minimum value of local timestamp that any deployment in the collection will have.
     */
    from?: number;
    /**
     * Acts as a filter in the collection of deployments, this value is the maximum value of local timestamp that any deployment in the collection will have.
     */
    to?: number;
    /**
     * It is the last entity id that was visited, so it will be skipped when showing current page.
     */
    lastId?: string;
    /**
     * The deployments are a paginated collection, this parameter corresponds to the limit for each page. The default value is 500.
     */
    limit?: number;
    /**
     * The type of entities that will be shown in the collection, many values can be sent. Valid values are: profile, scene and wearable.
     */
    entityType?: GetPointerChangesEntityType;
    /**
     * This value is used as the field to order all the deployments in the collection. If no parameter is sent, then the default field to order with will be local_timestamp.
     */
    sortingField?: GetPointerChangesSortingField;
    /**
     * This value is used as the order for all the deployments in the collection. If no parameter is sent, then the default field to order with will be DESC.
     */
    sortingOrder?: GetPointerChangesSortingOrder;
};
export type GetActiveEntitiesBody = {
    /** Entities must be filtered by pointer (pointers) XOR entityId. Use this parameter if you want to retrieve an entity of the specified type with this entityId. */
    ids?: string[];
    /** Entities must be filtered by pointer XOR entityId (ids). Use this parameter if you want to retrieve an entity of the specified type with this pointer. */
    pointers?: string[];
};
export type GetEntitiesByPointerPrefix200 = {
    entities: Entity[];
    total: number;
};
export type GetEntitiesByPointerPrefixParams = {
    /**
     * Page size (max 1000)
     */
    pageSize?: number;
    /**
     * Page number (default: 1)
     */
    pageNumber?: number;
};
export type PostEntity400 = Error | Errors;
export type PostEntity200 = {
    creationTimestamp: number;
};
export type PostEntityBody = {
    authChain?: string;
    entityId?: string;
    ethAddress?: string;
    files?: Blob[];
    signature?: string;
};
export type GetAvailableContentParams = {
    /**
     * Hash of the content file
     */
    cid: string[];
};
export type GetEntityIdsByHashId404 = {
    error: string;
};
export type GetChallenge200 = {
    challengeText: string;
};
export type PeersPeersItem = {
    address?: string;
    id?: string;
    lastPing?: number;
    parcel?: number[];
    position?: number[];
};
export interface Peers {
    ok?: boolean;
    peers?: PeersPeersItem[];
}
export type IslandIdPeersItem = {
    address?: string;
    id?: string;
    lastPing?: number;
    parcel?: number[];
    position?: number[];
    preferedIslandId?: string;
};
export interface IslandId {
    center?: number[];
    id?: string;
    maxPeers?: number;
    peers?: IslandIdPeersItem[];
    radius?: number;
}
export type IslandsIslandsItemPeersItem = {
    address?: string;
    id?: string;
    lastPing?: number;
    parcel?: number[];
    position?: number[];
    preferedIslandId?: string;
};
export type IslandsIslandsItem = {
    center?: number[];
    id?: string;
    maxPeers?: number;
    peers?: IslandsIslandsItemPeersItem[];
    radius?: number;
};
export interface Islands {
    islands?: IslandsIslandsItem[];
    ok?: boolean;
}
export type ThirdPartyIntegrationsDataItem = {
    description?: string;
    name?: string;
    urn: string;
};
export interface ThirdPartyIntegrations {
    data: ThirdPartyIntegrationsDataItem[];
}
export type ProfileAvatarsItemAvatarSnapshots = {
    body?: string;
    face?: string;
    face128?: string;
    face256?: string;
};
export type ProfileAvatarsItemAvatar = {
    bodyShape?: string;
    eyes?: ProfileAvatarsItemAvatarEyes;
    hair?: ProfileAvatarsItemAvatarHair;
    skin?: ProfileAvatarsItemAvatarSkin;
    snapshots?: ProfileAvatarsItemAvatarSnapshots;
    wearables?: string[];
};
export type ProfileAvatarsItem = {
    avatar?: ProfileAvatarsItemAvatar;
    description?: string;
    email?: string;
    ethAddress?: string;
    hasClaimedName?: boolean;
    interests?: string[];
    name?: string;
    tutorialStep?: number;
    unclaimedName?: string;
    userId?: string;
    version?: number;
};
export interface Profile {
    avatars?: ProfileAvatarsItem[];
}
export type ProfileAvatarsItemAvatarSkinColor = {
    b?: number;
    g?: number;
    r?: number;
};
export type ProfileAvatarsItemAvatarSkin = {
    color?: ProfileAvatarsItemAvatarSkinColor;
};
export type ProfileAvatarsItemAvatarHairColor = {
    b?: number;
    g?: number;
    r?: number;
};
export type ProfileAvatarsItemAvatarHair = {
    color?: ProfileAvatarsItemAvatarHairColor;
};
export type ProfileAvatarsItemAvatarEyesColor = {
    b?: number;
    g?: number;
    r?: number;
};
export type ProfileAvatarsItemAvatarEyes = {
    color?: ProfileAvatarsItemAvatarEyesColor;
};
export interface PostProfiles {
    ids?: string[];
}
export type RealmsItem = {
    layer?: string;
    maxUsers?: number;
    serverName?: string;
    url?: string;
    userParcels?: number[][];
    usersCount?: number;
};
export type Realms = RealmsItem[];
export type HotScenesItemRealmsItem = {
    layer?: string;
    maxUsers?: number;
    serverName?: string;
    url?: string;
    userParcels?: number[][];
    usersCount?: number;
};
export type HotScenesItem = {
    baseCoords?: number[];
    creator?: string;
    description?: string;
    id?: string;
    name?: string;
    parcels?: number[][];
    realms?: HotScenesItemRealmsItem[];
    thumbnail?: string;
    usersTotalCount?: number;
};
export type HotScenes = HotScenesItem[];
export type DenylistedUsernames = string[];
export type Pois = string[];
export type ServersItem = {
    baseUrl: string;
    id: string;
    owner: string;
};
export type Servers = ServersItem[];
export type WearablesWearablesItemI18nItem = {
    code?: string;
    text?: string;
};
export type WearablesWearablesItem = {
    collectionAddress?: string;
    createdAt?: number;
    data?: WearablesWearablesItemData;
    description?: string;
    i18n?: WearablesWearablesItemI18nItem[];
    id?: string;
    image?: string;
    rarity?: string;
    thumbnail?: string;
    updatedAt?: number;
};
export interface Wearables {
    filters?: WearablesFilters;
    pagination?: WearablesPagination;
    wearables?: WearablesWearablesItem[];
}
export type WearablesWearablesItemDataRepresentationsItemOverrideReplacesItem = {
    [key: string]: any;
};
export type WearablesWearablesItemDataRepresentationsItemOverrideHidesItem = {
    [key: string]: any;
};
export type WearablesWearablesItemDataRepresentationsItemContentsItem = {
    key?: string;
    url?: string;
};
export type WearablesWearablesItemDataRepresentationsItem = {
    bodyShapes?: string[];
    contents?: WearablesWearablesItemDataRepresentationsItemContentsItem[];
    mainFile?: string;
    overrideHides?: WearablesWearablesItemDataRepresentationsItemOverrideHidesItem[];
    overrideReplaces?: WearablesWearablesItemDataRepresentationsItemOverrideReplacesItem[];
};
export type WearablesWearablesItemData = {
    category?: string;
    hides?: string[];
    replaces?: string[];
    representations?: WearablesWearablesItemDataRepresentationsItem[];
    tags?: string[];
};
export type WearablesPagination = {
    limit?: number;
    next?: string;
};
export type WearablesFilters = {
    textSearch?: string;
};
export type ThirdPartyWearableIndividualDataItem = {
    id?: string;
};
export interface ThirdPartyWearable {
    amount?: number;
    category: string;
    entity: Entity;
    individualData?: ThirdPartyWearableIndividualDataItem[];
    name: string;
    urn: string;
}
export type LandsPaginatedElementsItem = {
    category: string;
    contractAddress: string;
    description?: string;
    image?: string;
    name?: string;
    price?: number;
    tokenId: string;
    x?: string;
    y?: string;
};
export interface LandsPaginated {
    elements: LandsPaginatedElementsItem[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
}
export type NamesPaginatedElementsItem = {
    contractAddress: string;
    name: string;
    price?: number;
    tokenId: string;
};
export interface NamesPaginated {
    elements: NamesPaginatedElementsItem[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
}
export interface LambdasError {
    error: string;
    message: string;
}
export type WearableIndividualDataItem = {
    id?: string;
    price?: number;
    tokenId?: string;
    transferredAt?: number;
};
export interface Wearable {
    amount?: number;
    category: string;
    entity?: Entity;
    individualData?: WearableIndividualDataItem[];
    name: string;
    rarity: string;
    urn: string;
}
export type Erc721AttributesItem = {
    trait_type?: string;
    value?: string;
};
export interface Erc721 {
    attributes?: Erc721AttributesItem[];
    description?: string;
    id?: string;
    image?: string;
    language?: string;
    name?: string;
    thumbnail?: string;
}
export interface StatusLambdas {
    commitHash?: string;
    currentTime?: number;
    version?: string;
}
export type StatusContentSynchronizationStatusOtherServersItem = {
    address: string;
    connectionState: string;
    lastDeploymentTimestamp: number;
};
export type StatusContentSynchronizationStatus = {
    lastSyncWithDAO: number;
    lastSyncWithOtherServers?: number;
    otherServers?: StatusContentSynchronizationStatusOtherServersItem[];
    synchronizationState: string;
};
export interface StatusContent {
    commitHash: string;
    currentTime?: number;
    ethNetwork: string;
    historySize?: number;
    lastImmutableTime?: number;
    name?: string;
    synchronizationStatus: StatusContentSynchronizationStatus;
    version: string;
}
export type SnapshotsItemTimeRange = {
    endTimestamp: number;
    initTimestamp: number;
};
export type SnapshotsItem = {
    generationTimestamp: number;
    hash: string;
    numberOfEntities: number;
    replacedSnapshotHashes?: string[];
    timeRange: SnapshotsItemTimeRange;
};
export type Snapshots = SnapshotsItem[];
export type PointerChangesDeltasItem = {
    authChain: AuthChain;
    entityId: string;
    entityType: string;
    localTimestamp: number;
    pointers: string[];
};
export interface PointerChanges {
    deltas: PointerChangesDeltasItem[];
}
export type FailedDeploymentsItem = {
    entityId: string;
    entityType: string;
    errorDescription: string;
    failedDeploymentsRepo?: string;
    reason: string;
};
export type FailedDeployments = FailedDeploymentsItem[];
export type EntityMetadata = {
    [key: string]: any;
};
export type EntityContentItem = {
    file: string;
    hash: string;
};
export interface Entity {
    content: EntityContentItem[];
    id: string;
    metadata?: EntityMetadata;
    pointers: string[];
    timestamp: number;
    type: string;
    version: string;
}
export interface Emote {
    amount?: number;
    category: string;
    entity?: Entity;
    urn: string;
}
export interface Errors {
    errors: string[];
}
export type AvailableContentItem = {
    available: boolean;
    cid: string;
};
export type AvailableContent = AvailableContentItem[];
export interface Error {
    error: string;
}
export type AuthChainItem = {
    payload: string;
    signature?: string;
    type: string;
};
export type AuthChain = AuthChainItem[];
export interface AuditResponse {
    authChain: AuthChain;
    denylistedContent?: string[];
    isDenylisted?: boolean;
    localTimestamp: number;
    overwrittenBy?: string;
    version: string;
}
export type StatsParcelsParcelsItemParcel = {
    x?: number;
    y?: number;
};
export type StatsParcelsParcelsItem = {
    parcel?: StatsParcelsParcelsItemParcel;
    peersCount?: number;
};
export interface StatsParcels {
    parcels?: StatsParcelsParcelsItem[];
}
export type AboutLambdas = {
    commitHash?: string;
    healthy: boolean;
    publicUrl: string;
    version?: string;
};
export type AboutContent = {
    commitHash?: string;
    healthy: boolean;
    publicUrl: string;
    synchronizationStatus: string;
    version?: string;
};
export interface About {
    acceptingUsers: boolean;
    bff?: AboutBff;
    comms?: AboutComms;
    configurations: AboutConfigurations;
    content: AboutContent;
    healthy: boolean;
    lambdas: AboutLambdas;
}
export type AboutConfigurationsSkybox = {
    fixedHour?: number;
    textures?: string[];
};
export type AboutConfigurationsMinimap = {
    dataImage?: string;
    enabled: boolean;
    estateImage?: string;
};
export type AboutConfigurations = {
    globalScenesUrn: string[];
    minimap?: AboutConfigurationsMinimap;
    networkId: number;
    realmName?: string;
    scenesUrn: string[];
    skybox?: AboutConfigurationsSkybox;
};
export type AboutComms = {
    adapter?: string;
    commitHash?: string;
    healthy: boolean;
    protocol: string;
    usersCount?: number;
    version?: string;
};
export type AboutBff = {
    commitHash?: string;
    healthy: boolean;
    protocolVersion: string;
    publicUrl: string;
    userCount?: number;
};
//# sourceMappingURL=catalyst.schemas.d.ts.map