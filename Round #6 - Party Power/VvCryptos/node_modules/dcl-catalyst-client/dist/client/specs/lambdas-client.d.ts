export type ValidateSignature200 = {
    [key: string]: any;
};
export type ValidateSignatureBody = {
    [key: string]: any;
};
export type SearchWearablesParams = {
    /**
     * Lis of URNs that identify the collection. Maximum amount of ids allowed is 500.
     */
    collectionId?: string[];
    /**
     * List of wearables URNs to search. Maximum amount of ids allowed is 500.
     */
    wearableId?: string[];
    /**
     * Search text
     */
    textSearch?: string;
    /**
     * Limit the quantity of results that will be returned by the request. You can only request up to 500 results.
     */
    limit?: number;
    /**
     * The result will always be ordered by the local timestamp fields but in case of timestamp collisions, you can use the lastId field to filter the result
     */
    lastId?: string;
};
export type GetThirdPartyCollection200 = {
    elements: ThirdPartyWearable[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
};
export type GetThirdPartyCollectionParams = {
    /**
     * The number of the requested page.
     */
    pageNum?: string;
    /**
     * The size of the requested page.
     */
    pageSize?: string;
};
export type GetThirdPartyWearables200 = {
    elements: ThirdPartyWearable[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
};
export type GetThirdPartyWearablesParams = {
    /**
     * The number of the requested page.
     */
    pageNum?: string;
    /**
     * The size of the requested page.
     */
    pageSize?: string;
};
export type GetLandsParams = {
    /**
     * The number of the requested page. It needs `pageSize` to be present to enable a paginated response.
     */
    pageNum?: string;
    /**
     * The size of the requested page. It needs `pageNum` to be present to enable a paginated response.
     */
    pageSize?: string;
};
export type GetNamesParams = {
    /**
     * The number of the requested page. It needs `pageSize` to be present to enable a paginated response.
     */
    pageNum?: string;
    /**
     * The size of the requested page. It needs `pageNum` to be present to enable a paginated response.
     */
    pageSize?: string;
};
export type GetEmotes200 = {
    elements: Emote[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
};
export type GetEmotesParams = {
    /**
     * Third Party collection Id to filter emotes, if this param is not sent then the 3rd parties emotes are not shown. If it is sent, only the 3rd parties emotes are shown.
     */
    collectionId?: string;
    /**
     * If present, response will be extended with the entity data.
     */
    includeEntities?: boolean;
    /**
     * The number of the requested page.
     */
    pageNum?: string;
    /**
     * The size of the requested page
     */
    pageSize?: string;
};
export type GetWearables200 = {
    elements: Wearable[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
};
export type GetWearablesParams = {
    /**
     * If present, response will be extended with the entity data.
     */
    includeEntities?: boolean;
    /**
     * If present, response will include the third-party wearables owned by the address. They will appear before other wearables if the response is paginated.
     */
    includeThirdParty?: boolean;
    /**
     * The number of the requested page.
     */
    pageNum?: string;
    /**
     * The size of the requested page.
     */
    pageSize?: string;
    /**
     * Determines the field to be sort by. By default it will be by `transferredAt`. Possible values: `transferredAt` and `rarity`.
     */
    orderBy?: string;
};
export type GetCollections200CollectionsItem = {
    id: string;
    name: string;
};
export type GetCollections200 = {
    collections?: GetCollections200CollectionsItem[];
};
export type PeersPeersItem = {
    address?: string;
    id?: string;
    lastPing?: number;
    parcel?: number[];
    position?: number[];
};
export interface Peers {
    ok?: boolean;
    peers?: PeersPeersItem[];
}
export type IslandIdPeersItem = {
    address?: string;
    id?: string;
    lastPing?: number;
    parcel?: number[];
    position?: number[];
    preferedIslandId?: string;
};
export interface IslandId {
    center?: number[];
    id?: string;
    maxPeers?: number;
    peers?: IslandIdPeersItem[];
    radius?: number;
}
export type IslandsIslandsItemPeersItem = {
    address?: string;
    id?: string;
    lastPing?: number;
    parcel?: number[];
    position?: number[];
    preferedIslandId?: string;
};
export type IslandsIslandsItem = {
    center?: number[];
    id?: string;
    maxPeers?: number;
    peers?: IslandsIslandsItemPeersItem[];
    radius?: number;
};
export interface Islands {
    islands?: IslandsIslandsItem[];
    ok?: boolean;
}
export type ThirdPartyIntegrationsDataItem = {
    description?: string;
    name?: string;
    urn: string;
};
export interface ThirdPartyIntegrations {
    data: ThirdPartyIntegrationsDataItem[];
}
export type ProfileAvatarsItemAvatarSnapshots = {
    body?: string;
    face?: string;
    face128?: string;
    face256?: string;
};
export type ProfileAvatarsItemAvatarSkinColor = {
    b?: number;
    g?: number;
    r?: number;
};
export type ProfileAvatarsItemAvatarSkin = {
    color?: ProfileAvatarsItemAvatarSkinColor;
};
export type ProfileAvatarsItemAvatarHairColor = {
    b?: number;
    g?: number;
    r?: number;
};
export type ProfileAvatarsItemAvatarHair = {
    color?: ProfileAvatarsItemAvatarHairColor;
};
export type ProfileAvatarsItemAvatar = {
    bodyShape?: string;
    eyes?: ProfileAvatarsItemAvatarEyes;
    hair?: ProfileAvatarsItemAvatarHair;
    skin?: ProfileAvatarsItemAvatarSkin;
    snapshots?: ProfileAvatarsItemAvatarSnapshots;
    wearables?: string[];
};
export type ProfileAvatarsItem = {
    avatar?: ProfileAvatarsItemAvatar;
    description?: string;
    email?: string;
    ethAddress?: string;
    hasClaimedName?: boolean;
    interests?: string[];
    name?: string;
    tutorialStep?: number;
    unclaimedName?: string;
    userId?: string;
    version?: number;
};
export interface Profile {
    avatars?: ProfileAvatarsItem[];
}
export type ProfileAvatarsItemAvatarEyesColor = {
    b?: number;
    g?: number;
    r?: number;
};
export type ProfileAvatarsItemAvatarEyes = {
    color?: ProfileAvatarsItemAvatarEyesColor;
};
export interface PostProfiles {
    ids?: string[];
}
export type RealmsItem = {
    layer?: string;
    maxUsers?: number;
    serverName?: string;
    url?: string;
    userParcels?: number[][];
    usersCount?: number;
};
export type Realms = RealmsItem[];
export type HotScenesItemRealmsItem = {
    layer?: string;
    maxUsers?: number;
    serverName?: string;
    url?: string;
    userParcels?: number[][];
    usersCount?: number;
};
export type HotScenesItem = {
    baseCoords?: number[];
    creator?: string;
    description?: string;
    id?: string;
    name?: string;
    parcels?: number[][];
    realms?: HotScenesItemRealmsItem[];
    thumbnail?: string;
    usersTotalCount?: number;
};
export type HotScenes = HotScenesItem[];
export type DenylistedUsernames = string[];
export type Pois = string[];
export type ServersItem = {
    baseUrl: string;
    id: string;
    owner: string;
};
export type Servers = ServersItem[];
export type WearablesWearablesItemI18nItem = {
    code?: string;
    text?: string;
};
export type WearablesWearablesItem = {
    collectionAddress?: string;
    createdAt?: number;
    data?: WearablesWearablesItemData;
    description?: string;
    i18n?: WearablesWearablesItemI18nItem[];
    id?: string;
    image?: string;
    rarity?: string;
    thumbnail?: string;
    updatedAt?: number;
};
export interface Wearables {
    filters?: WearablesFilters;
    pagination?: WearablesPagination;
    wearables?: WearablesWearablesItem[];
}
export type WearablesWearablesItemDataRepresentationsItemOverrideReplacesItem = {
    [key: string]: any;
};
export type WearablesWearablesItemDataRepresentationsItemOverrideHidesItem = {
    [key: string]: any;
};
export type WearablesWearablesItemDataRepresentationsItemContentsItem = {
    key?: string;
    url?: string;
};
export type WearablesWearablesItemDataRepresentationsItem = {
    bodyShapes?: string[];
    contents?: WearablesWearablesItemDataRepresentationsItemContentsItem[];
    mainFile?: string;
    overrideHides?: WearablesWearablesItemDataRepresentationsItemOverrideHidesItem[];
    overrideReplaces?: WearablesWearablesItemDataRepresentationsItemOverrideReplacesItem[];
};
export type WearablesWearablesItemData = {
    category?: string;
    hides?: string[];
    replaces?: string[];
    representations?: WearablesWearablesItemDataRepresentationsItem[];
    tags?: string[];
};
export type WearablesPagination = {
    limit?: number;
    next?: string;
};
export type WearablesFilters = {
    textSearch?: string;
};
export type ThirdPartyWearableIndividualDataItem = {
    id?: string;
};
export interface ThirdPartyWearable {
    amount?: number;
    category: string;
    entity: Entity;
    individualData?: ThirdPartyWearableIndividualDataItem[];
    name: string;
    urn: string;
}
export type LandsPaginatedElementsItem = {
    category: string;
    contractAddress: string;
    description?: string;
    image?: string;
    name?: string;
    price?: number;
    tokenId: string;
    x?: string;
    y?: string;
};
export interface LandsPaginated {
    elements: LandsPaginatedElementsItem[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
}
export type NamesPaginatedElementsItem = {
    contractAddress: string;
    name: string;
    price?: number;
    tokenId: string;
};
export interface NamesPaginated {
    elements: NamesPaginatedElementsItem[];
    pageNum: number;
    pageSize: number;
    totalAmount: number;
}
export interface LambdasError {
    error: string;
    message: string;
}
export type WearableIndividualDataItem = {
    id?: string;
    price?: number;
    tokenId?: string;
    transferredAt?: number;
};
export interface Wearable {
    amount?: number;
    category: string;
    entity?: Entity;
    individualData?: WearableIndividualDataItem[];
    name: string;
    rarity: string;
    urn: string;
}
export type Erc721AttributesItem = {
    trait_type?: string;
    value?: string;
};
export interface Erc721 {
    attributes?: Erc721AttributesItem[];
    description?: string;
    id?: string;
    image?: string;
    language?: string;
    name?: string;
    thumbnail?: string;
}
export interface StatusLambdas {
    commitHash?: string;
    currentTime?: number;
    version?: string;
}
export type StatusContentSynchronizationStatusOtherServersItem = {
    address: string;
    connectionState: string;
    lastDeploymentTimestamp: number;
};
export type StatusContentSynchronizationStatus = {
    lastSyncWithDAO: number;
    lastSyncWithOtherServers?: number;
    otherServers?: StatusContentSynchronizationStatusOtherServersItem[];
    synchronizationState: string;
};
export interface StatusContent {
    commitHash: string;
    currentTime?: number;
    ethNetwork: string;
    historySize?: number;
    lastImmutableTime?: number;
    name?: string;
    synchronizationStatus: StatusContentSynchronizationStatus;
    version: string;
}
export type SnapshotsItemTimeRange = {
    endTimestamp: number;
    initTimestamp: number;
};
export type SnapshotsItem = {
    generationTimestamp: number;
    hash: string;
    numberOfEntities: number;
    replacedSnapshotHashes?: string[];
    timeRange: SnapshotsItemTimeRange;
};
export type Snapshots = SnapshotsItem[];
export type PointerChangesDeltasItem = {
    authChain: AuthChain;
    entityId: string;
    entityType: string;
    localTimestamp: number;
    pointers: string[];
};
export interface PointerChanges {
    deltas: PointerChangesDeltasItem[];
}
export type FailedDeploymentsItem = {
    entityId: string;
    entityType: string;
    errorDescription: string;
    failedDeploymentsRepo?: string;
    reason: string;
};
export type FailedDeployments = FailedDeploymentsItem[];
export type EntityMetadata = {
    [key: string]: any;
};
export type EntityContentItem = {
    file: string;
    hash: string;
};
export interface Entity {
    content: EntityContentItem[];
    id: string;
    metadata?: EntityMetadata;
    pointers: string[];
    timestamp: number;
    type: string;
    version: string;
}
export interface Emote {
    amount?: number;
    category: string;
    entity?: Entity;
    urn: string;
}
export interface Errors {
    errors: string[];
}
export type AvailableContentItem = {
    available: boolean;
    cid: string;
};
export type AvailableContent = AvailableContentItem[];
export interface Error {
    error: string;
}
export type AuthChainItem = {
    payload: string;
    signature?: string;
    type: string;
};
export type AuthChain = AuthChainItem[];
export interface AuditResponse {
    authChain: AuthChain;
    denylistedContent?: string[];
    isDenylisted?: boolean;
    localTimestamp: number;
    overwrittenBy?: string;
    version: string;
}
export type StatsParcelsParcelsItemParcel = {
    x?: number;
    y?: number;
};
export type StatsParcelsParcelsItem = {
    parcel?: StatsParcelsParcelsItemParcel;
    peersCount?: number;
};
export interface StatsParcels {
    parcels?: StatsParcelsParcelsItem[];
}
export type AboutLambdas = {
    commitHash?: string;
    healthy: boolean;
    publicUrl: string;
    version?: string;
};
export type AboutContent = {
    commitHash?: string;
    healthy: boolean;
    publicUrl: string;
    synchronizationStatus: string;
    version?: string;
};
export interface About {
    acceptingUsers: boolean;
    bff?: AboutBff;
    comms?: AboutComms;
    configurations: AboutConfigurations;
    content: AboutContent;
    healthy: boolean;
    lambdas: AboutLambdas;
}
export type AboutConfigurationsSkybox = {
    fixedHour?: number;
    textures?: string[];
};
export type AboutConfigurationsMinimap = {
    dataImage?: string;
    enabled: boolean;
    estateImage?: string;
};
export type AboutConfigurations = {
    globalScenesUrn: string[];
    minimap?: AboutConfigurationsMinimap;
    networkId: number;
    realmName?: string;
    scenesUrn: string[];
    skybox?: AboutConfigurationsSkybox;
};
export type AboutComms = {
    adapter?: string;
    commitHash?: string;
    healthy: boolean;
    protocol: string;
    usersCount?: number;
    version?: string;
};
export type AboutBff = {
    commitHash?: string;
    healthy: boolean;
    protocolVersion: string;
    publicUrl: string;
    userCount?: number;
};
/**
 * Retrieve detailed information about the services
 * @summary Catalyst Server status
 */
export declare const getLambdaStatus: () => import("../utils/fetcher").CustomClient<StatusLambdas>;
/**
 * Retrieve the list of collections URNs
 * @summary Get Collections
 */
export declare const getCollections: () => import("../utils/fetcher").CustomClient<GetCollections200>;
/**
 * Downloads a thumbnail image for the specified urn
 * @summary Download thumbnail image
 */
export declare const getThumbnail: (urn: string) => import("../utils/fetcher").CustomClient<Blob>;
/**
 * Downloads the image for the specified urn
 * @summary Download URN image
 */
export declare const getImage: (urn: string) => import("../utils/fetcher").CustomClient<Blob>;
/**
 * Retrieve ERC721/NFT Entity details
 * @summary Get ERC721 Entity
 */
export declare const getStandardErc721: (chainId: string, contract: string, option: string, emission: string) => import("../utils/fetcher").CustomClient<Erc721>;
/**
 * Get a list of wearables owned by the given address
 * @summary Get list of wearables for an address
 */
export declare const getWearables: (address: string, params?: GetWearablesParams) => import("../utils/fetcher").CustomClient<GetWearables200>;
/**
 * Get a list of emotes owned by the given address
 * @summary Get list of emotes for an address
 */
export declare const getEmotes: (address: string, params?: GetEmotesParams) => import("../utils/fetcher").CustomClient<GetEmotes200>;
/**
 * Get a list of names owned by the given address
 * @summary Get list of names for an address
 */
export declare const getNames: (address: string, params?: GetNamesParams) => import("../utils/fetcher").CustomClient<NamesPaginated>;
/**
 * Get a list of lands owned by the given address
 * @summary Get list of lands for an address
 */
export declare const getLands: (address: string, params?: GetLandsParams) => import("../utils/fetcher").CustomClient<LandsPaginated>;
/**
 * Returns the list of third party wearables for the provided address
 * @summary Returns the list of third party wearables for the provided address
 */
export declare const getThirdPartyWearables: (address: string, params?: GetThirdPartyWearablesParams) => import("../utils/fetcher").CustomClient<GetThirdPartyWearables200>;
/**
 * Returns the list of third party wearables for the given collection
 * @summary Returns the list of third party wearables for the given collection
 */
export declare const getThirdPartyCollection: (address: string, collectionId: string, params?: GetThirdPartyCollectionParams) => import("../utils/fetcher").CustomClient<GetThirdPartyCollection200>;
/**
 * Search for wearables based on the applied filters and retrieve detailed information
 * @deprecated
 * @summary Search Wearables
 */
export declare const searchWearables: (params?: SearchWearablesParams) => import("../utils/fetcher").CustomClient<Wearables>;
/**
 * Retrieve the list of Catalyst Servers
 * @summary Get Catalyst Servers
 */
export declare const getCatalystServers: () => import("../utils/fetcher").CustomClient<Servers>;
/**
 * Retrieve the Point of Interest list of coordinates
 * @summary Retrieve DCL Point of Interests
 */
export declare const getPois: () => import("../utils/fetcher").CustomClient<Pois>;
/**
 * Retrieve list of forbidden user names. The prohibition of these names is decided through the DAO and need to be voted, the list lives in a Smart Contract and the Catalyst just consumes this information to present it to the client. In order to add a new name a new proposal needs to be created, approved and a transaction should be sent by a DAO committee member.
 * @summary Denylisted user names
 */
export declare const getDenylistedUserNames: () => import("../utils/fetcher").CustomClient<DenylistedUsernames>;
/**
 * Given a signed message and it's AuthChain, validate it's authenticity. A message can be signed, for example, to prove ownership of the Entity pointers that they want to modify.
 * @deprecated
 * @summary Validate signed message
 */
export declare const validateSignature: (validateSignatureBody: ValidateSignatureBody) => import("../utils/fetcher").CustomClient<ValidateSignature200>;
/**
 * Returns the list of scenes where there are more users with coordinates and the list of parcels that compose the scene.
 * @summary Hot Scenes
 */
export declare const getHotScenes: () => import("../utils/fetcher").CustomClient<HotScenes>;
/**
 * Returns the list of realms with details about the users in it
 * @summary Get Realms status
 */
export declare const getRealms: () => import("../utils/fetcher").CustomClient<Realms>;
/**
 * Returns all the Avatars details associated with the Ethereum addresses in the body
 * @summary Get Avatars details
 */
export declare const getAvatarsDetailsByPost: (postProfiles: PostProfiles) => import("../utils/fetcher").CustomClient<Profile[]>;
/**
 * Given a Ethereum address of a user, return the Avatars details associated with it.
 * @summary Get Avatar details
 */
export declare const getAvatarDetails: (id: string) => import("../utils/fetcher").CustomClient<Profile>;
/**
 * Given a Ethereum address of a user, return the Outfits entity.
 * @summary Get Outfits
 */
export declare const getOutfits: (id: string) => import("../utils/fetcher").CustomClient<Entity>;
/**
 * Returns the list of third party integrations and collections
 * @summary Returns the list of third party integrations as well as collections
 */
export declare const getThirdPartyIntegrations: () => import("../utils/fetcher").CustomClient<ThirdPartyIntegrations>;
type AwaitedInput<T> = PromiseLike<T> | T;
type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;
export type GetLambdaStatusResult = NonNullable<Awaited<ReturnType<typeof getLambdaStatus>>>;
export type GetCollectionsResult = NonNullable<Awaited<ReturnType<typeof getCollections>>>;
export type GetThumbnailResult = NonNullable<Awaited<ReturnType<typeof getThumbnail>>>;
export type GetImageResult = NonNullable<Awaited<ReturnType<typeof getImage>>>;
export type GetStandardErc721Result = NonNullable<Awaited<ReturnType<typeof getStandardErc721>>>;
export type GetWearablesResult = NonNullable<Awaited<ReturnType<typeof getWearables>>>;
export type GetEmotesResult = NonNullable<Awaited<ReturnType<typeof getEmotes>>>;
export type GetNamesResult = NonNullable<Awaited<ReturnType<typeof getNames>>>;
export type GetLandsResult = NonNullable<Awaited<ReturnType<typeof getLands>>>;
export type GetThirdPartyWearablesResult = NonNullable<Awaited<ReturnType<typeof getThirdPartyWearables>>>;
export type GetThirdPartyCollectionResult = NonNullable<Awaited<ReturnType<typeof getThirdPartyCollection>>>;
export type SearchWearablesResult = NonNullable<Awaited<ReturnType<typeof searchWearables>>>;
export type GetCatalystServersResult = NonNullable<Awaited<ReturnType<typeof getCatalystServers>>>;
export type GetPoisResult = NonNullable<Awaited<ReturnType<typeof getPois>>>;
export type GetDenylistedUserNamesResult = NonNullable<Awaited<ReturnType<typeof getDenylistedUserNames>>>;
export type ValidateSignatureResult = NonNullable<Awaited<ReturnType<typeof validateSignature>>>;
export type GetHotScenesResult = NonNullable<Awaited<ReturnType<typeof getHotScenes>>>;
export type GetRealmsResult = NonNullable<Awaited<ReturnType<typeof getRealms>>>;
export type GetAvatarsDetailsByPostResult = NonNullable<Awaited<ReturnType<typeof getAvatarsDetailsByPost>>>;
export type GetAvatarDetailsResult = NonNullable<Awaited<ReturnType<typeof getAvatarDetails>>>;
export type GetOutfitsResult = NonNullable<Awaited<ReturnType<typeof getOutfits>>>;
export type GetThirdPartyIntegrationsResult = NonNullable<Awaited<ReturnType<typeof getThirdPartyIntegrations>>>;
export {};
//# sourceMappingURL=lambdas-client.d.ts.map