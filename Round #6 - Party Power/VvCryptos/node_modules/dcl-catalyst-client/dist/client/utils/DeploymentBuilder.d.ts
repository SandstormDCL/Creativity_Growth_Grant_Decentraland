import { AuthChain, ContentMapping, Entity, EntityType } from '@dcl/schemas';
import { IFetchComponent } from '@well-known-components/interfaces';
/**
 * Take all the entity's data, build the entity file with it, and calculate its id
 */
export declare function buildEntityAndFile({ type, pointers, timestamp, content, metadata }: {
    type: EntityType;
    pointers: string[];
    timestamp: number;
    content: ContentMapping[];
    metadata?: any;
}): Promise<{
    entity: Entity;
    entityFile: Uint8Array;
}>;
/**
 * As part of the deployment process, an entity has to be built. In this method, we are building it, based on the data provided.
 * After the entity is built, the user will have to sign the entity id, to prove they are actually who they say they are.
 */
export declare function buildEntity({ type, pointers, files, metadata, timestamp }: {
    type: EntityType;
    pointers: string[];
    files?: Map<string, Uint8Array>;
    metadata?: any;
    timestamp?: number;
}): Promise<DeploymentPreparationData>;
/**
 * In cases where we don't need upload content files, we can simply generate the new entity.
 * We can still use already uploaded hashes on this new entity.
 */
export declare function buildEntityWithoutNewFiles(fetcher: IFetchComponent, { contentUrl, type, pointers, hashesByKey, metadata, timestamp }: {
    contentUrl: string;
    type: EntityType;
    pointers: string[];
    hashesByKey?: Map<string, string>;
    metadata?: any;
    timestamp?: number;
}): Promise<DeploymentPreparationData>;
/** This data contains everything necessary for the user to sign, so that then a deployment can be executed */
export type DeploymentPreparationData = {
    entityId: string;
    files: Map<string, Uint8Array>;
};
export type DeploymentData = DeploymentPreparationData & {
    authChain: AuthChain;
};
//# sourceMappingURL=DeploymentBuilder.d.ts.map