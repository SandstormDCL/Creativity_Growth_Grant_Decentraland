"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lifecycle = void 0;
function stopAllComponents(components) {
    const pending = [];
    for (let c in components) {
        const component = components[c];
        if (!component)
            throw new Error('Component is null: ' + c);
        if (component.stop && typeof component.stop == "function") {
            pending.push(component.stop());
        }
    }
    return Promise.all(pending);
}
async function allSettled(promises) {
    let mappedPromises = promises.map((p) => {
        let r = p.then((value) => {
            return {
                status: "fulfilled",
                value,
            };
        });
        if ("catch" in p) {
            r = p.catch((reason) => {
                return {
                    status: "rejected",
                    reason,
                };
            });
        }
        return r;
    });
    return Promise.all(mappedPromises);
}
// gracefully finalizes all the components on SIGTERM
async function startComponentsLifecycle(components) {
    process.stdout.write("<<< Starting components >>>\n");
    const pending = [];
    let mutStarted = false;
    let mutLive = false;
    const immutableStartOptions = {
        started() {
            return mutStarted;
        },
        live() {
            return mutLive;
        },
        getComponents() {
            return components;
        },
    };
    for (let c in components) {
        const component = components[c];
        if ((await components[c]) !== components[c]) {
            process.stderr.write("<<< Error initializing components. Component '" +
                c +
                "' is a Promise, it should be an object, did you miss an await in the initComponents?. >>>\n");
        }
        if (!component)
            throw new Error('Null or empty components are not allowed: ' + c);
        if (component.start && typeof component.start == "function") {
            const awaitable = component.start(immutableStartOptions);
            if (awaitable && typeof awaitable == "object" && "then" in awaitable) {
                pending.push(awaitable);
                if (awaitable.catch) {
                    // avoid unhanled catch error messages in node.
                    // real catch happens below in `Promise.all(pending)`
                    awaitable.catch((err) => {
                        process.stderr.write(`<<< Error initializing component: ${JSON.stringify(c)}. Error will appear in the next line >>>\n${err}\n`);
                    });
                }
            }
        }
    }
    // application started
    mutLive = true;
    if (pending.length == 0)
        return;
    try {
        await Promise.all(pending);
        mutStarted = true;
    }
    catch (e) {
        process.stderr.write("<<< Error initializing components. Stopping components and closing application. >>>\n");
        await allSettled(pending);
        throw e;
    }
}
/**
 * handles an async function, if it fails the program exits with exit code 1
 */
function asyncTopLevelExceptionHanler(fn) {
    return fn().catch((error) => {
        // print error and stacktrace
        console.error(error);
        // exit program with error
        process.exit(1);
    });
}
/**
 * This namespace handles the basic lifecycle of the components.
 * @public
 */
var Lifecycle;
(function (Lifecycle) {
    /**
     * Program entry point, this should be the one and only top level
     * expression of your program.
     *
     * @deprecated Lifecycle.programEntryPoint is deprecated, please use Lifecycle.run()
     */
    async function programEntryPoint(config) {
        return run(Object.assign(Object.assign({}, config), { async main(program) {
                const r = await config.main(program.components);
                await program.startComponents();
                return r;
            } }));
    }
    Lifecycle.programEntryPoint = programEntryPoint;
    /**
     * Program entry point, this should be the one and only top level
     * expression of your program.
     */
    function run(config) {
        return asyncTopLevelExceptionHanler(async () => {
            // pick a componentInitializer
            const componentInitializer = config.initComponents;
            // init ports & components
            process.stdout.write("<<< Initializing components >>>\n");
            const components = Object.freeze(await componentInitializer());
            let componentsStarted;
            const termHandler = () => {
                process.stdout.write("<<< SIGTERM received >>>\n");
                stopAllComponents(components)
                    .then(() => process.exit())
                    .catch((e) => {
                    process.stderr.write(e + "\n");
                    console.error(e);
                    process.exit(1);
                });
            };
            const program = {
                get components() {
                    return components;
                },
                async stop() {
                    await stopAllComponents(components);
                    process.off('SIGTERM', termHandler);
                },
                async startComponents() {
                    if (!componentsStarted) {
                        // start components & ports
                        componentsStarted = startComponentsLifecycle(components);
                    }
                    else {
                        process.stderr.write("Warning: startComponents must be called once\n");
                    }
                    return componentsStarted;
                },
            };
            try {
                // wire adapters
                process.stdout.write("<<< Wiring app >>>\n");
                await config.main(program);
                if (!componentsStarted) {
                    process.stderr.write("Warning: startComponents was not called inside programEntryPoint.main function\n");
                }
                else {
                    await componentsStarted;
                    // gracefully finalizes all the components on SIGTERM
                    process.on("SIGTERM", termHandler);
                }
            }
            catch (e) {
                try {
                    // gracefully stop all components
                    await program.stop();
                }
                catch (err) {
                    console.error(err);
                }
                finally {
                    // the following throw is handled by asyncTopLevelExceptionHanler
                    // exiting the program
                    throw e;
                }
            }
            return program;
        });
    }
    Lifecycle.run = run;
})(Lifecycle || (exports.Lifecycle = Lifecycle = {}));
//# sourceMappingURL=lifecycle.js.map