"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetchComponent = void 0;
const crossFetch = __importStar(require("cross-fetch"));
const environment_1 = require("./environment");
const NON_RETRYABLE_STATUS_CODES = [400, 401, 403, 404];
const IDEMPOTENT_HTTP_METHODS = ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE'];
async function fetchWithRetriesAndTimeout(url, options) {
    const { timeout, abortController, signal: timeoutSignal, retryDelay } = options;
    let attempts = options.attempts;
    let timer = null;
    let response = undefined;
    do {
        try {
            if (timeout) {
                timer = setTimeout(() => {
                    abortController.abort();
                }, timeout);
            }
            const fetchPromise = crossFetch.default(url.toString(), Object.assign(Object.assign({}, options), { signal: timeoutSignal }));
            const racePromise = Promise.race([
                fetchPromise,
                new Promise((resolve, _) => {
                    timeoutSignal.addEventListener('abort', () => {
                        resolve(new crossFetch.Response('timeout', { status: 408, statusText: 'Request Timeout' }));
                    });
                })
            ]);
            --attempts;
            response = (await racePromise);
            if (timer)
                clearTimeout(timer);
        }
        finally {
            if (!!response && (response.ok || NON_RETRYABLE_STATUS_CODES.includes(response.status) || attempts === 0))
                break;
            else
                await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
    } while ((!response || !response.ok) && attempts > 0);
    return response;
}
/**
 * @public
 * Creates a fetch component
 * @param defaultHeaders - default headers to be injected on every call performed by this component
 */
function createFetchComponent(defaultOptions) {
    async function fetch(url, options) {
        // Parse options
        const optionsWithDefault = Object.assign(Object.assign({}, defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.defaultFetcherOptions), options);
        const _a = optionsWithDefault || {}, { timeout, method = 'GET', retryDelay = 0, abortController } = _a, fetchOptions = __rest(_a, ["timeout", "method", "retryDelay", "abortController"]);
        let attempts = fetchOptions.attempts || 1;
        const controller = abortController || new AbortController();
        const { signal } = controller;
        // Add default headers
        if (defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.defaultHeaders)
            fetchOptions.headers = Object.assign(Object.assign({}, defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.defaultHeaders), (fetchOptions.headers || {}));
        // Fix attempts in case of POST
        if (!IDEMPOTENT_HTTP_METHODS.includes(method.toUpperCase()))
            attempts = 1;
        // Fetch with retries and timeout
        const response = await fetchWithRetriesAndTimeout(url, Object.assign(Object.assign({}, fetchOptions), { attempts,
            method,
            timeout,
            retryDelay, signal: signal, abortController: controller }));
        // Throw in case of error
        if (!(response === null || response === void 0 ? void 0 : response.ok)) {
            const responseText = await (response === null || response === void 0 ? void 0 : response.text());
            throw new Error(`Failed to fetch ${url}. Got status ${response === null || response === void 0 ? void 0 : response.status}. Response was '${responseText}'`);
        }
        if (!(0, environment_1.isUsingNode)() && !!response) {
            Object.defineProperty(response, 'buffer', {
                value: async function () {
                    return Buffer.from(await response.arrayBuffer());
                },
                configurable: true
            });
        }
        // Parse response in case of abortion
        return signal.aborted ? undefined : response;
    }
    return { fetch };
}
exports.createFetchComponent = createFetchComponent;
//# sourceMappingURL=fetcher.js.map