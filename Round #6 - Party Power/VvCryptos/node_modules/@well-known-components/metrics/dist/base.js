"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTestMetricsComponent = void 0;
const interfaces_1 = require("@well-known-components/interfaces");
const prom_client_1 = require("prom-client");
/**
 * @public
 */
function createTestMetricsComponent(metricsDefinition) {
    const registry = new prom_client_1.Registry();
    const metricsMap = new Map();
    Object.entries(metricsDefinition).forEach(([name, definition]) => {
        let value;
        let args = Object.assign(Object.assign({ name: name }, definition), { registers: [registry] });
        if (definition.type == interfaces_1.IMetricsComponent.CounterType) {
            value = new prom_client_1.Counter(args);
        }
        else if (definition.type == interfaces_1.IMetricsComponent.HistogramType) {
            value = new prom_client_1.Histogram(args);
        }
        else if (definition.type == interfaces_1.IMetricsComponent.SummaryType) {
            value = new prom_client_1.Summary(args);
        }
        else if (definition.type == interfaces_1.IMetricsComponent.GaugeType) {
            value = new prom_client_1.Gauge(args);
        }
        if (!value)
            throw new Error(`Unknown metric type ${definition.type}`);
        const metric = {
            definition: Object.assign({}, definition),
            type: definition.type,
            value,
        };
        metricsMap.set(name, metric);
    });
    registry.resetMetrics();
    return {
        observe(metricName, labels, value) {
            if (metricsMap.has(metricName)) {
                const metric = metricsMap.get(metricName);
                if (metric.type == interfaces_1.IMetricsComponent.GaugeType) {
                    metric.value.set(labels, value);
                }
                else if (metric.type == interfaces_1.IMetricsComponent.SummaryType) {
                    metric.value.observe(labels, value);
                }
                else if (metric.type == interfaces_1.IMetricsComponent.HistogramType) {
                    metric.value.observe(labels, value);
                }
                else
                    throw new Error(`Only "${interfaces_1.IMetricsComponent.GaugeType}" and "${interfaces_1.IMetricsComponent.SummaryType}" can be used with .observe`);
            }
            else {
                throw new Error(`Unknown metric ${metricName}`);
            }
        },
        increment(metricName, labels, value) {
            if (metricsMap.has(metricName)) {
                const metric = metricsMap.get(metricName);
                if (metric.type == interfaces_1.IMetricsComponent.CounterType) {
                    metric.value.inc(labels || {}, value);
                }
                else if (metric.type == interfaces_1.IMetricsComponent.GaugeType) {
                    metric.value.inc(labels || {}, value);
                }
                else
                    throw new Error(`Only "${interfaces_1.IMetricsComponent.GaugeType}" and "${interfaces_1.IMetricsComponent.CounterType}" metrics can be used with .increment`);
            }
            else {
                throw new Error(`Unknown metric ${metricName}`);
            }
        },
        decrement(metricName, labels, value) {
            if (metricsMap.has(metricName)) {
                const metric = metricsMap.get(metricName);
                if (metric.type == interfaces_1.IMetricsComponent.GaugeType) {
                    metric.value.dec(labels || {}, value);
                }
                else
                    throw new Error(`Only "${interfaces_1.IMetricsComponent.GaugeType}" metrics can be used with .decrement`);
            }
            else {
                throw new Error(`Unknown metric ${metricName}`);
            }
        },
        startTimer(metricName, labels) {
            if (metricsMap.has(metricName)) {
                const metric = metricsMap.get(metricName);
                if (metric.type == interfaces_1.IMetricsComponent.GaugeType) {
                    const end = metric.value.startTimer(labels);
                    return { end };
                }
                else if (metric.type == interfaces_1.IMetricsComponent.HistogramType) {
                    const end = metric.value.startTimer(labels);
                    return { end };
                }
                else if (metric.type == interfaces_1.IMetricsComponent.SummaryType) {
                    const end = metric.value.startTimer(labels);
                    return { end };
                }
                else
                    throw new Error(`Only "${interfaces_1.IMetricsComponent.GaugeType}", "${interfaces_1.IMetricsComponent.HistogramType}" and "${interfaces_1.IMetricsComponent.SummaryType}" metrics can be used with .startTimer`);
            }
            else {
                throw new Error(`Unknown metric ${metricName}`);
            }
        },
        reset(metricName) {
            if (metricsMap.has(metricName)) {
                const metric = metricsMap.get(metricName);
                metric.value.reset();
            }
            else {
                throw new Error(`Unknown metric ${metricName}`);
            }
        },
        resetAll() {
            registry.resetMetrics();
        },
        getValue(metricName) {
            if (metricsMap.has(metricName)) {
                const metric = metricsMap.get(metricName);
                return metric.value.get();
            }
            else {
                throw new Error(`Unknown metric ${metricName}`);
            }
        },
        registry,
    };
}
exports.createTestMetricsComponent = createTestMetricsComponent;
//# sourceMappingURL=base.js.map