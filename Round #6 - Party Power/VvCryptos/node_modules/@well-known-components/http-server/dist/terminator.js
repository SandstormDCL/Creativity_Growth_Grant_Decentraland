"use strict";
// Based on work of https://github.com/gajus/http-terminator
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServerTerminator = void 0;
const fp_future_1 = __importDefault(require("fp-future"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const configurationDefaults = {
    gracefulTerminationTimeout: 1000,
};
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
function createServerTerminator(server, components, configurationInput) {
    const { logger } = components;
    const configuration = {
        ...configurationDefaults,
        ...configurationInput,
    };
    const sockets = new Set();
    const secureSockets = new Set();
    let terminating;
    server.on("connection", (socket) => {
        if (terminating) {
            socket.destroy();
        }
        else {
            sockets.add(socket);
            socket.once("close", () => {
                sockets.delete(socket);
            });
        }
    });
    server.on("secureConnection", (socket) => {
        if (terminating) {
            socket.destroy();
        }
        else {
            secureSockets.add(socket);
            socket.once("close", () => {
                secureSockets.delete(socket);
            });
        }
    });
    /**
     * Evaluate whether additional steps are required to destroy the socket.
     *
     * @see https://github.com/nodejs/node/blob/57bd715d527aba8dae56b975056961b0e429e91e/lib/_http_client.js#L363-L413
     */
    const destroySocket = (socket) => {
        socket.destroy();
        if (socket.server instanceof http_1.default.Server) {
            sockets.delete(socket);
        }
        else {
            secureSockets.delete(socket);
        }
    };
    const terminate = async () => {
        if (terminating) {
            logger.warn("Already terminating HTTP server");
            return terminating;
        }
        terminating = (0, fp_future_1.default)();
        server.on("request", (incomingMessage, outgoingMessage) => {
            if (!outgoingMessage.headersSent) {
                outgoingMessage.setHeader("connection", "close");
            }
        });
        for (const socket of sockets) {
            // This is the HTTP CONNECT request socket.
            // Unclear if I am using wrong type or how else this should be handled.
            if (!(socket.server instanceof https_1.default.Server) && !(socket.server instanceof http_1.default.Server)) {
                continue;
            }
            // @ts-expect-error Unclear if I am using wrong type or how else this should be handled.
            const serverResponse = socket._httpMessage;
            if (serverResponse) {
                if (!serverResponse.headersSent) {
                    serverResponse.setHeader("connection", "close");
                }
                continue;
            }
            destroySocket(socket);
        }
        for (const socket of secureSockets) {
            // @ts-expect-error Unclear if I am using wrong type or how else this should be handled.
            const serverResponse = socket._httpMessage;
            if (serverResponse) {
                if (!serverResponse.headersSent) {
                    serverResponse.setHeader("connection", "close");
                }
                continue;
            }
            destroySocket(socket);
        }
        if (sockets.size) {
            await delay(configuration.gracefulTerminationTimeout);
            for (const socket of sockets) {
                destroySocket(socket);
            }
        }
        if (secureSockets.size) {
            await delay(configuration.gracefulTerminationTimeout);
            for (const socket of secureSockets) {
                destroySocket(socket);
            }
        }
        server.close((error) => {
            if (error) {
                terminating.reject(error);
            }
            else {
                terminating.resolve();
            }
        });
        return terminating;
    };
    return {
        secureSockets,
        sockets,
        terminate,
    };
}
exports.createServerTerminator = createServerTerminator;
//# sourceMappingURL=terminator.js.map