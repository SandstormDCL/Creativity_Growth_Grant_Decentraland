"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServerComponent = void 0;
const injectors_1 = require("./injectors");
const logic_1 = require("./logic");
const server_handler_1 = require("./server-handler");
const http = __importStar(require("http"));
const terminator_1 = require("./terminator");
const ws_1 = require("./ws");
const destroy_1 = __importDefault(require("destroy"));
const cors_1 = require("./cors");
/**
 * Creates a http-server component
 * @public
 */
async function createServerComponent(components, options) {
    const { config, logs, ws } = components;
    const logger = logs.getLogger("http-server");
    // config
    const port = await config.requireNumber("HTTP_SERVER_PORT");
    const host = await config.requireString("HTTP_SERVER_HOST");
    let handlerFn = handler;
    const server = (0, logic_1.getServer)(options, handlerFn);
    let listen;
    const terminator = (0, terminator_1.createServerTerminator)(server, { logger }, {});
    async function start() {
        if (listen) {
            logger.error("start() called more than once");
            await listen;
            return;
        }
        listen = new Promise((resolve, reject) => {
            const errorHandler = (err) => {
                logger.error(err);
                reject(err);
            };
            server.once("error", errorHandler).listen(port, host, () => {
                // logger.log(`Listening ${host}:${port}`)
                // resolve(server)
                // server!.off("error", errorHandler)
            });
            server.once("listening", () => {
                logger.log(`Listening ${host}:${port}`);
                resolve(server);
                server.off("error", errorHandler);
            });
        });
        await listen;
    }
    async function stop() {
        logger.info(`Closing server`);
        await terminator.terminate();
        logger.info(`Server closed`);
    }
    let configuredContext = Object.create({});
    const serverHandler = (0, server_handler_1.createServerHandler)();
    const ret = {
        // IBaseComponent
        start,
        stop,
        // IStatusCheckCapableComponent
        async startupProbe() {
            return true;
        },
        async readynessProbe() {
            return server.listening;
        },
        // IHttpServerComponent
        use: serverHandler.use,
        setContext(context) {
            configuredContext = context;
        },
        // extra
        resetMiddlewares: serverHandler.resetMiddlewares,
    };
    async function asyncHandle(req, res) {
        const request = (0, logic_1.getRequestFromNodeMessage)(req, host);
        const response = await serverHandler.processRequest(configuredContext, request);
        (0, logic_1.success)(response, res);
    }
    async function handleUpgrade(req, socket, head) {
        if (!ws) {
            throw new Error("No WebSocketServer present");
        }
        const request = (0, logic_1.getRequestFromNodeMessage)(req, host);
        const response = await serverHandler.processRequest(configuredContext, request);
        const websocketConnect = (0, ws_1.getWebSocketCallback)(response);
        if (websocketConnect) {
            ws.handleUpgrade(req, socket, head, async (wsSocket) => {
                try {
                    await websocketConnect(wsSocket);
                }
                catch (err) {
                    logger.error(err);
                    (0, destroy_1.default)(socket);
                }
            });
        }
        else {
            if (response.status) {
                const statusCode = isNaN(response.status) ? 404 : response.status;
                const statusText = http.STATUS_CODES[statusCode] || "Not Found";
                socket.end(`HTTP/${req.httpVersion} ${statusCode} ${statusText}\r\n\r\n`);
            }
            else {
                socket.end();
            }
        }
    }
    if (ws) {
        server.on("upgrade", (req, socket, head) => {
            return handleUpgrade(req, socket, head).catch((err) => {
                logger.error(err);
                (0, destroy_1.default)(socket);
            });
        });
    }
    function handler(request, response) {
        asyncHandle(request, response).catch((error) => {
            logger.error(error);
            if (error.code == "ERR_INVALID_URL") {
                response.statusCode = 404;
                response.end();
            }
            else {
                response.statusCode = 500;
                response.end();
            }
        });
    }
    (0, injectors_1._setUnderlyingServer)(ret, async () => {
        if (!server)
            throw new Error("The server is stopped");
        return (await listen) || server;
    });
    if (options.cors) {
        ret.use((0, cors_1.createCorsMiddleware)(options.cors));
    }
    return ret;
}
exports.createServerComponent = createServerComponent;
//# sourceMappingURL=server.js.map