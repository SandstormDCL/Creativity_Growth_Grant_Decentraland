"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.contextFromRequest = exports.normalizeResponseBody = exports.defaultHandler = exports.coerceErrorsMiddleware = exports.getRequestFromNodeMessage = exports.getDefaultMiddlewares = exports.success = exports.isBlob = exports.getServer = void 0;
const fetch = __importStar(require("node-fetch"));
const stream_1 = require("stream");
const http = __importStar(require("http"));
const https = __importStar(require("https"));
const destroy_1 = __importDefault(require("destroy"));
const on_finished_1 = __importDefault(require("on-finished"));
const http_errors_1 = require("http-errors");
const ws_1 = require("./ws");
/**
 * @internal
 */
function getServer(options, listener) {
    if ("https" in options && options.https)
        return https.createServer(options.https, listener);
    if ("http" in options && options.http)
        return http.createServer(options.http, listener);
    return http.createServer(listener);
}
exports.getServer = getServer;
const NAME = Symbol.toStringTag;
/**
 * Check if `object` is a W3C `Blob` object (which `File` inherits from)
 *
 * @internal
 */
const isBlob = (object) => {
    return (object !== null &&
        typeof object === "object" &&
        typeof object.arrayBuffer === "function" &&
        typeof object.type === "string" &&
        typeof object.stream === "function" &&
        typeof object.constructor === "function" &&
        /^(Blob|File)$/.test(object[NAME]));
};
exports.isBlob = isBlob;
/**
 * @internal
 */
function success(data, res) {
    if (data.statusText)
        res.statusMessage = data.statusText;
    if (data.status)
        res.statusCode = data.status;
    if (data.headers) {
        const headers = new fetch.Headers(data.headers);
        headers.forEach((value, key) => {
            if (value !== undefined) {
                res.setHeader(key, value);
            }
        });
    }
    const body = data.body;
    if (Buffer.isBuffer(body)) {
        res.end(body);
    }
    else if ((0, exports.isBlob)(body)) {
        // const blob = body as Blob
        // const stream = blob.stream()
        // if (stream.pipeTo) {
        //   stream.pipeTo(res as any)
        // } else {
        //   ;(blob.stream() as any).pipe(res)
        // }
        throw new Error("Unknown response body (Blob)");
    }
    else if (body && body.pipe) {
        body.pipe(res);
        // Note: for context about why this is necessary, check https://github.com/nodejs/node/issues/1180
        (0, on_finished_1.default)(res, () => (0, destroy_1.default)(body));
    }
    else if (body !== undefined && body !== null) {
        throw new Error("Unknown response body");
    }
    else {
        res.end();
    }
}
exports.success = success;
// @internal
function getDefaultMiddlewares() {
    return [exports.coerceErrorsMiddleware];
}
exports.getDefaultMiddlewares = getDefaultMiddlewares;
const getRequestFromNodeMessage = (request, host) => {
    const headers = new fetch.Headers();
    for (let key in request.headers) {
        if (request.headers.hasOwnProperty(key)) {
            const h = request.headers[key];
            if (typeof h == "string") {
                headers.append(key, h);
            }
            else if (Array.isArray(h)) {
                h.forEach(($) => headers.append(key, $));
            }
        }
    }
    const requestInit = {
        headers: headers,
        method: request.method.toUpperCase(),
    };
    if (requestInit.method != "GET" && requestInit.method != "HEAD") {
        requestInit.body = request;
    }
    const protocol = headers.get("X-Forwarded-Proto") == "https" ? "https" : "http";
    const baseUrl = protocol + "://" + (headers.get("X-Forwarded-Host") || headers.get("host") || host || "0.0.0.0");
    // Note: Express.js overwrite `req.url` freely for internal routing
    // purposes and retains the original value on `req.originalUrl`
    // @see https://expressjs.com/en/api.html#req.originalUrl
    const originalUrl = request.originalUrl ?? request.url;
    let url = new URL(baseUrl + originalUrl);
    try {
        url = new URL(originalUrl, baseUrl);
    }
    catch { }
    const ret = new fetch.Request(url.toString(), requestInit);
    return ret;
};
exports.getRequestFromNodeMessage = getRequestFromNodeMessage;
const coerceErrorsMiddleware = async (_, next) => {
    try {
        return await next();
    }
    catch (e) {
        if (e instanceof http_errors_1.HttpError ||
            (("status" in e || "statusCode" in e) && (typeof e.status == "number" || typeof e.statusCode == "number"))) {
            return {
                status: e.status || e.statusCode,
                body: e.body || e.message,
                headers: e.headers,
            };
        }
        throw e;
    }
};
exports.coerceErrorsMiddleware = coerceErrorsMiddleware;
function respondBuffer(buffer, response, mutableHeaders) {
    // TODO: test
    mutableHeaders.set("Content-Length", buffer.byteLength.toFixed());
    return new fetch.Response(buffer, {
        ...response,
        headers: mutableHeaders,
    });
}
function respondJson(json, response, mutableHeaders) {
    // TODO: test
    if (!mutableHeaders.has("content-type")) {
        mutableHeaders.set("content-type", "application/json");
    }
    return respondString(JSON.stringify(json), response, mutableHeaders);
}
function respondString(txt, response, mutableHeaders) {
    // TODO: test
    // TODO: accept encoding
    const returnEncoding = "utf-8";
    const retBuffer = Buffer.from(txt, returnEncoding);
    if (!mutableHeaders.has("content-type")) {
        mutableHeaders.set("content-type", `text/plain; charset=${returnEncoding}`);
    }
    return respondBuffer(retBuffer, response, mutableHeaders);
}
const initialResponse = {
    status: 404,
    body: "Not found",
};
/**
 * Default middleware
 * @public
 */
async function defaultHandler() {
    return initialResponse;
}
exports.defaultHandler = defaultHandler;
// @internal
function normalizeResponseBody(request, response) {
    if (!response) {
        // Not Implemented
        return new fetch.Response(undefined, { status: 501, statusText: "Server did not produce a valid response" });
    }
    if (response.status == 101) {
        const cb = (0, ws_1.getWebSocketCallback)(response);
        return (0, ws_1.withWebSocketCallback)(new fetch.Response(void 0, { ...response, body: undefined }), cb);
    }
    if (response instanceof fetch.Response) {
        return new fetch.Response(response.body, {
            headers: response.headers,
            status: response.status,
            statusText: response.statusText,
        });
    }
    const is1xx = response.status && response.status >= 100 && response.status < 200;
    const is204 = response.status == 204;
    const is304 = response.status == 304;
    const isHEAD = request.method == "HEAD";
    const mutableHeaders = new fetch.Headers(response.headers);
    if (is204 || is304) {
        // TODO: TEST this code path
        mutableHeaders.delete("Content-Type");
        mutableHeaders.delete("Content-Length");
        mutableHeaders.delete("Transfer-Encoding");
    }
    // https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4
    // the following responses must not contain any content nor content-length
    if (is1xx || is204 || is304 || isHEAD) {
        // TODO: TEST this code path
        return new fetch.Response(undefined, { ...response, headers: mutableHeaders, body: undefined });
    }
    if (Buffer.isBuffer(response.body)) {
        return respondBuffer(response.body, response, mutableHeaders);
    }
    else if (response.body instanceof ArrayBuffer || response.body instanceof Uint8Array) {
        return respondBuffer(response.body, response, mutableHeaders);
    }
    else if (typeof response.body == "string") {
        return respondString(response.body, response, mutableHeaders);
    }
    else if (response.body instanceof stream_1.Stream) {
        return new fetch.Response(response.body, response);
    }
    else if (response.body != undefined) {
        // TODO: test
        return respondJson(response.body, response, mutableHeaders);
    }
    // Applications SHOULD use this field to indicate the transfer-length of the
    // message-body, unless this is prohibited by the rules in section 4.4.
    // (https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4)
    if (!mutableHeaders.has("content-length")) {
        mutableHeaders.set("content-length", "0");
    }
    return new fetch.Response(undefined, { ...response, headers: mutableHeaders });
}
exports.normalizeResponseBody = normalizeResponseBody;
/**
 * @internal
 */
function contextFromRequest(baseCtx, request) {
    const newContext = Object.create(baseCtx);
    // hidrate context with the request
    newContext.request = request;
    newContext.url = new URL(request.url);
    return newContext;
}
exports.contextFromRequest = contextFromRequest;
//# sourceMappingURL=logic.js.map