import { Layer, LayerOptions } from "./layer";
import type { IHttpServerComponent } from "@well-known-components/interfaces";
/** @public */
export type RouterOptions = Partial<{
    methods: IHttpServerComponent.HTTPMethod[];
    prefix: string;
    routerPath: string;
    sensitive: boolean;
    strict: boolean;
}>;
/** @public */
export type AllowedMethodOptions = Partial<{
    throw: boolean;
    notImplemented: NewableFunction;
    methodNotAllowed: NewableFunction;
}>;
/** @public */
export type RoutedContext<Context, Path extends string> = IHttpServerComponent.PathAwareContext<Context, Path> & {
    captures: string[];
    matched?: Layer<Context, Path>[];
    routerPath?: string;
};
/** @public */
export type RoutePathSignature<Context extends {}> = <T extends string>(path: T, ...middlewares: Array<IHttpServerComponent.IRequestHandler<RoutedContext<Context, T>>>) => Router<Context>;
/**
 * Create a new router.
 *
 * @example
 *
 * Basic usage:
 *
 * ```javascript
 * const app = createTestServerComponent();
 * const router = new Router();
 *
 * router.get('/', (ctx, next) => {
 *   // ctx.router available
 * });
 *
 * app
 *   .use(router.routes())
 *   .use(router.allowedMethods());
 * ```
 * @public
 */
export declare class Router<Context extends {}> implements IHttpServerComponent.MethodHandlers<Context> {
    opts: RouterOptions;
    methods: (IHttpServerComponent.HTTPMethod | string)[];
    stack: Layer<Context, any>[];
    constructor(opts?: RouterOptions);
    connect: RoutePathSignature<Context>;
    delete: RoutePathSignature<Context>;
    get: RoutePathSignature<Context>;
    head: RoutePathSignature<Context>;
    options: RoutePathSignature<Context>;
    patch: RoutePathSignature<Context>;
    post: RoutePathSignature<Context>;
    put: RoutePathSignature<Context>;
    trace: RoutePathSignature<Context>;
    /**
     * Use given middleware.
     *
     * Middleware run in the order they are defined by `.use()`. They are invoked
     * sequentially, requests start at the first middleware and work their way
     * "down" the middleware stack.
     *
     * @example
     *
     * ```javascript
     * // session middleware will run before authorize
     * router
     *   .use(session())
     *   .use(authorize());
     *
     * // use middleware only with given path
     * router.use('/users', userAuth());
     *
     * // or with an array of paths
     * router.use(['/users', '/admin'], userAuth());
     *
     * app.use(router.routes());
     * ```
     *
     * @param path -
     * @param middleware -
     */
    use(...middlewares: IHttpServerComponent.IRequestHandler<RoutedContext<Context, string>>[]): this;
    use<P extends string>(route: P, ...middlewares: IHttpServerComponent.IRequestHandler<RoutedContext<Context, P>>[]): this;
    /**
     * Set the path prefix for a Router instance that was already initialized.
     *
     * @example
     *
     * ```javascript
     * router.prefix('/things/:thing_id')
     * ```
     *
     * @param prefix -
     */
    prefix(prefix: string): this;
    /**
     * Returns router middleware which dispatches a route matching the request.
     */
    middleware(): IHttpServerComponent.IRequestHandler<Context>;
    /**
     * Returns separate middleware for responding to `OPTIONS` requests with
     * an `Allow` header containing the allowed methods, as well as responding
     * with `405 Method Not Allowed` and `501 Not Implemented` as appropriate.
     *
     * @example
     *
     * ```javascript
     * const app = createTestServerComponent();
     * const router = new Router();
     *
     * app.use(router.routes());
     * app.use(router.allowedMethods());
     * ```
     *
     * **Example with [Boom](https://github.com/hapijs/boom)**
     *
     * ```javascript
     * const Boom = require('boom');
     *
     * const app = createTestServerComponent();
     * const router = new Router();
     *
     * app.use(router.routes());
     * app.use(router.allowedMethods({
     *   throw: true,
     *   notImplemented: () => new Boom.notImplemented(),
     *   methodNotAllowed: () => new Boom.methodNotAllowed()
     * }));
     * ```
     *
     * @param options -
     */
    allowedMethods(options?: AllowedMethodOptions): IHttpServerComponent.IRequestHandler<Context>;
    /**
     * Register route with all methods.
     *
     * @param name - Optional.
     * @param path -
     * @param middleware - You may also pass multiple middleware.
     * @param callback -
     */
    all<T extends string>(path: T, middleware: IHttpServerComponent.IRequestHandler<RoutedContext<Context, T>>): this;
    /**
     * Redirect `source` to `destination` URL with optional 30x status `code`.
     *
     * Both `source` and `destination` can be route names.
     *
     * ```javascript
     * router.redirect('/login', 'sign-in');
     * ```
     *
     * This is equivalent to:
     *
     * ```javascript
     * router.all('/login', ctx => {
     *   ctx.redirect('/sign-in');
     *   ctx.status = 301;
     * });
     * ```
     *
     * @param source - URL or route name.
     * @param destination - URL or route name.
     * @param code - HTTP status code (default: 301).
     */
    redirect(source: string, destination: string, code?: number): this;
    /**
     * Create and register a route.
     *
     * @param path - Path string.
     * @param methods - Array of HTTP verbs.
     * @param middleware - Multiple middleware also accepted.
     */
    register<Path extends string>(path: Path, methods: ReadonlyArray<IHttpServerComponent.HTTPMethod>, middleware: IHttpServerComponent.IRequestHandler<Context>, opts?: LayerOptions): Layer<Context, Path>;
    /**
     * Match given `path` and return corresponding routes.
     *
     * @param path -
     * @param method -
     */
    match(path: string, method: string): {
        path: Layer<Context, string>[];
        pathAndMethod: Layer<Context, string>[];
        route: boolean;
    };
}
