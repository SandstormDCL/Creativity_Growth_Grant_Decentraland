"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Layer = void 0;
const path_to_regexp_1 = require("path-to-regexp");
/**
 * Initialize a new routing Layer with given `method`, `path`, and `middleware`.
 *
 * @param path - Path string or regular expression.
 * @param methods - Array of HTTP verbs.
 * @param middleware - Layer callback/middleware or series of.
 * @param opts - Layer options
 *
 * @public
 */
class Layer {
    constructor(path, methods, middleware, opts) {
        this.opts = opts || {};
        this.name = this.opts.name || null;
        this.methods = [];
        this.paramNames = [];
        this.stack = Array.isArray(middleware) ? middleware : [middleware];
        for (let i = 0; i < methods.length; i++) {
            const l = this.methods.push(methods[i].toUpperCase());
            if (this.methods[l - 1] === "GET")
                this.methods.unshift("HEAD");
        }
        // ensure middleware is a function
        for (let i = 0; i < this.stack.length; i++) {
            const fn = this.stack[i];
            const type = typeof fn;
            if (type !== "function")
                throw new Error(`${methods.toString()} \`${this.opts.name || path}\`: \`middleware\` must be a function, not \`${type}\``);
        }
        this.path = path;
        this.regexp = (0, path_to_regexp_1.pathToRegexp)(path, this.paramNames, this.opts);
    }
    /**
     * Returns whether request `path` matches route.
     *
     * @param path -
     */
    match(path) {
        return this.regexp.test(path);
    }
    /**
     * Returns map of URL parameters for given `path` and `paramNames`.
     *
     * @param path -
     * @param captures -
     * @param existingParams -
     */
    params(captures, existingParams) {
        const params = existingParams || {};
        for (let len = captures.length, i = 0; i < len; i++) {
            if (this.paramNames[i]) {
                const c = captures[i];
                params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c;
            }
        }
        return params;
    }
    /**
     * Returns array of regexp url path captures.
     *
     * @param path -
     */
    captures(path) {
        const r = path.match(this.regexp);
        if (!r)
            return [];
        return this.opts.ignoreCaptures ? [] : r.slice(1);
    }
    /**
     * Prefix route path.
     *
     * @param prefix -
     */
    setPrefix(prefix) {
        if (this.path) {
            this.path = this.path !== "/" || this.opts.strict === true ? `${prefix}${this.path}` : prefix;
            this.paramNames = [];
            this.regexp = (0, path_to_regexp_1.pathToRegexp)(this.path, this.paramNames, this.opts);
        }
        return this;
    }
}
exports.Layer = Layer;
/**
 * Safe decodeURIComponent, won't throw any error.
 * If `decodeURIComponent` error happen, just return the original value.
 *
 * @param text -
 */
function safeDecodeURIComponent(text) {
    try {
        return decodeURIComponent(text);
    }
    catch (e) {
        return text;
    }
}
//# sourceMappingURL=layer.js.map